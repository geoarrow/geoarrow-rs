{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"geoarrow.rust","text":"<p>Python bindings to the GeoArrow Rust implementation.</p>"},{"location":"#overview","title":"Overview","text":"<p>This library contains Python bindings to the GeoArrow Rust implementation.</p> <ul> <li>Fast: Connects to algorithms implemented in GeoRust, which compile to native code.</li> <li>Parallel: Multi-threading is enabled out-of-the-box for all operations on chunked data structures.</li> <li>Self-contained: <code>pyproj</code> is the only Python dependency.</li> <li>Easy to install: Distributed as static binary wheels with zero C dependencies.</li> <li>Static typing: type hints for all operations.</li> <li>Interoperable ecosystem: Efficient data exchange with other libraries in the Python Arrow and GeoArrow ecosystems. , such as geoarrow-c or lightning-fast map rendering.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Refer to the documentation website.</p>"},{"location":"#modules","title":"Modules","text":"<p><code>geoarrow.rust</code> is distributed with namespace packaging, meaning that each Python submodule is published to PyPI independently. This allows for separation of concerns and smaller environments when only some portion of functionality is necessary.</p> <p>Existing modules:</p> <ul> <li><code>geoarrow-rust-core</code>: Data structures to store and manage geometry data in GeoArrow format.</li> <li><code>geoarrow-rust-compute</code>: Compute operations on GeoArrow data.</li> <li><code>geoarrow-rust-io</code>: Pure-rust readers and writers for geospatial file formats.</li> </ul> <p>In order to obtain relevant modules, you should install them from PyPI directly, e.g.:</p> <pre><code>pip install geoarrow-rust-core geoarrow-rust-compute geoarrow-rust-io\n</code></pre> <p>Future potential modules:</p> <ul> <li><code>geoarrow-rust-geos</code>: GEOS-based algorithms on GeoArrow memory.</li> <li><code>geoarrow-rust-proj</code>: PROJ-based coordinate reprojection on GeoArrow memory.</li> </ul> <p>See DEVELOP.md for more information on developing and building the Python bindings.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#020-2024-03-22","title":"[0.2.0] - 2024-03-22","text":""},{"location":"CHANGELOG/#new","title":"New!","text":""},{"location":"CHANGELOG/#new-io-support-for-reading-and-writing-to-geospatial-formats","title":"New I/O support for reading and writing to geospatial formats","text":"<ul> <li>Asynchronous FlatGeobuf reader. This also supports passing a spatial filter.</li> <li>Initial support for reading from PostGIS. Note that not all Postgres data types are supported yet. Create an issue if your query fails.</li> <li>Reading and writing newline-delimited GeoJSON.</li> <li>Pyogrio integration for reading from OGR/GDAL.</li> <li>Asynchronous GeoParquet reader for reading from remote files. By @weiji14 in geoarrow/geoarrow-rs!493</li> <li>Also new support for writing GeoParquet files.</li> <li>Most I/O readers and writers support Python file-like objects (in binary mode).</li> <li>Support for reading and writing Arrow IPC files.</li> </ul>"},{"location":"CHANGELOG/#better-interoperability-with-the-python-geospatial-ecosystem","title":"Better interoperability with the Python geospatial ecosystem.","text":"<ul> <li>Import from and export to GeoPandas GeoDataFrames. Refer to the GeoPandas interoperability documentation.</li> <li>Import from and export to Shapely arrays. Refer to the Shapely interoperability documentation.</li> <li>Better integration with Lonboard for fast visualization in Jupyter.</li> <li>All scalars, arrays, chunked arrays, and table objects implement <code>__geo_interface__</code> for interoperability with existing tools.</li> <li>Numpy interoperability for float array output from algorithms. Pass any <code>Float64Array</code> or <code>BooleanArray</code> to <code>numpy.asarray</code>. You can also pass a numpy array as vectorized input into a function like <code>line_interpolate_point</code>.</li> </ul>"},{"location":"CHANGELOG/#new-algorithms","title":"New algorithms!","text":"<ul> <li>Explode a Table where each multi-geometry expands into multiple rows of single geometries.</li> <li><code>total_bounds</code></li> <li>Unified <code>area</code> function for planar and geodesic area.</li> <li>Unified <code>simplify</code> function for multiple simplification methods. Also new support for topology-preserving simplification.</li> <li>Unified <code>length</code> function for euclidean and geodesic length calculations.</li> <li><code>frechet_distance</code> for LineString similarity.</li> <li><code>affine_transform</code>, which integrates with the Python <code>affine</code> library.</li> <li><code>line_interpolate_point</code> and <code>line_locate_point</code> for linear referencing.</li> <li><code>polylabel</code> for polygon labeling.</li> </ul>"},{"location":"CHANGELOG/#improved-display-of-python-objects","title":"Improved display of Python objects:","text":"<ul> <li>Scalars now display as SVG geometries inside Jupyter environments.</li> <li>Tables, arrays, and chunked arrays implement <code>__repr__</code> so that you can inspect data easily.</li> </ul>"},{"location":"CHANGELOG/#improved-usability","title":"Improved usability:","text":"<ul> <li><code>PointArray.from_xy</code> to simplify creating a point array from numpy arrays of coordinates.</li> <li>Index into arrays and chunked arrays with square brackets. E.g. <code>point_array[0]</code> will access the first point in the array. Negative indexing is also supported, so <code>point_array[-1]</code> will get the last item in the array.</li> <li>New top-level docs website.</li> </ul>"},{"location":"CHANGELOG/#new-contributors","title":"New Contributors","text":"<ul> <li>@Robinlovelace made their first contribution in geoarrow/geoarrow-rs!484</li> <li>@weiji14 made their first contribution in geoarrow/geoarrow-rs!493</li> </ul> <p>Full Changelog: github.com/geoarrow/geoarrow-rs/compare/py-v0.1.0...py-v0.2.0</p>"},{"location":"CHANGELOG/#010-2024-01-08","title":"[0.1.0] - 2024-01-08","text":"<ul> <li>Initial public release.</li> </ul>"},{"location":"api/compute/enums/","title":"Enums","text":""},{"location":"api/compute/enums/#geoarrow.rust.compute.enums","title":"geoarrow.rust.compute.enums","text":""},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod","title":"AreaMethod","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Ellipsoidal","title":"Ellipsoidal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ellipsoidal = auto()\n</code></pre> <p>Use an ellipsoidal model of the Earth for area calculations.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Ellipsoidal--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction for the exterior   ring and a clockwise direction for interior rings. This is the standard winding   for geometries that follow the Simple Feature standard. Alternative windings may   result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect   to be dealing with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Ellipsoidal--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Ellipsoidal--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things:</p> <ol> <li>The winding of the polygon is in the clockwise direction (reverse winding). If    this is the case, and you know the polygon is smaller than half the area of    earth, you can take the absolute value of the reported area to get the correct    area.</li> <li>The polygon is larger than half the planet. In this case, the returned area of    the polygon is not correct. If you expect to be dealing with very large polygons,    please use the <code>unsigned</code> methods.</li> </ol>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Euclidean","title":"Euclidean  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Euclidean = auto()\n</code></pre> <p>Calculate planar area.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Spherical","title":"Spherical  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Spherical = auto()\n</code></pre> <p>Use a spherical model of the Earth for area calculations.</p> <p>Calculate the geodesic area of a geometry on a sphere using the algorithm presented in Some Algorithms for Polygons on a Sphere by Chamberlain and Duquette (2007).</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Spherical--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.LengthMethod","title":"LengthMethod","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.LengthMethod.Ellipsoidal","title":"Ellipsoidal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ellipsoidal = auto()\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.LengthMethod.Euclidean","title":"Euclidean  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Euclidean = auto()\n</code></pre> <p>Determine the length of a geometry using planar calculations.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.LengthMethod.Haversine","title":"Haversine  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Haversine = auto()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.LengthMethod.Vincenty","title":"Vincenty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Vincenty = auto()\n</code></pre> <p>Determine the length of a geometry using Vincenty's formulae.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.RotateOrigin","title":"RotateOrigin","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.RotateOrigin.Center","title":"Center  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Center = auto()\n</code></pre> <p>Use the center of a geometry for rotation</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.RotateOrigin.Centroid","title":"Centroid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Centroid = auto()\n</code></pre> <p>Use the centroid of a geometry for rotation</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.SimplifyMethod","title":"SimplifyMethod","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.SimplifyMethod.RDP","title":"RDP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RDP = auto()\n</code></pre> <p>Use the Ramer-Douglas-Peucker algorithm for LineString simplificatino.</p> <p>Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.SimplifyMethod.VW","title":"VW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VW = auto()\n</code></pre> <p>Use the Visvalingam-Whyatt algorithm for LineString simplification.</p> <p>See here for a graphical explanation Polygons are simplified by running the algorithm on all their constituent rings.</p> <p>This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.SimplifyMethod.VW_Preserve","title":"VW_Preserve  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VW_Preserve = auto()\n</code></pre> <p>Use a topology-preserving variant of the Visvalingam-Whyatt algorithm for LineString simplification.</p> <p>See here for a graphical explanation.</p> <p>The topology-preserving algorithm uses an R* tree to efficiently find candidate line segments which are tested for intersection with a given triangle. If intersections are found, the previous point (i.e. the left component of the current triangle) is also removed, altering the geometry and removing the intersection.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.SimplifyMethod.VW_Preserve--notes","title":"Notes","text":"<ul> <li>It is possible for the simplification algorithm to displace a Polygon's interior   ring outside its shell.</li> <li>The algorithm does not guarantee a valid output geometry, especially on   smaller geometries.</li> <li>If removal of a point causes a self-intersection, but the geometry only has <code>n +   1</code> points remaining (3 for a <code>LineString</code>, 5 for a <code>Polygon</code>), the point is   retained and the simplification process ends. This is because there is no   guarantee that removal of two points will remove the intersection, but removal of   further points would leave too few points to form a valid geometry.</li> <li>The tolerance used to remove a point is <code>epsilon</code>, in keeping with GEOS. JTS uses   <code>epsilon ^ 2</code></li> </ul>"},{"location":"api/compute/functions/","title":"Functions","text":""},{"location":"api/compute/functions/#arraychunked-array-functions","title":"Array/Chunked Array functions","text":""},{"location":"api/compute/functions/#geoarrow.rust.compute","title":"geoarrow.rust.compute","text":""},{"location":"api/compute/functions/#geoarrow.rust.compute.affine_transform","title":"affine_transform","text":"<pre><code>affine_transform(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    transform: AffineTransform,\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array other: an affine</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.area","title":"area","text":"<pre><code>area(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    *,\n    method: AreaMethod | AreaMethodT = AreaMethod.Euclidean\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Determine the area of an array of geometries</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>               (<code>AreaMethod | AreaMethodT</code>)           \u2013            <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array or chunked array with area values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.center","title":"center","text":"<pre><code>center(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>Array or chunked array with center values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.centroid","title":"centroid","text":"<pre><code>centroid(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>Array or chunked array with centroid values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.chaikin_smoothing","title":"chaikin_smoothing","text":"<pre><code>chaikin_smoothing(\n    input: ArrowArrayExportable | ArrowStreamExportable, n_iterations: int\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array n_iterations: Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>Smoothed geometry array or chunked geometry array.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.convex_hull","title":"convex_hull","text":"<pre><code>convex_hull(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.densify","title":"densify","text":"<pre><code>densify(\n    input: ArrowArrayExportable, max_distance: float\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable</code>)           \u2013            <p>input geometry array</p> </li> <li> <code>max_distance</code>               (<code>float</code>)           \u2013            <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>Densified geometry array</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.envelope","title":"envelope","text":"<pre><code>envelope(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.frechet_distance","title":"frechet_distance","text":"<pre><code>frechet_distance(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    other: BroadcastGeometry,\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Determine the similarity between two arrays of <code>LineStrings</code> using the [Frechet distance].</p> <p>The Fr\u00e9chet distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter \u2018densify\u2019 makes this approximation less coarse by splitting the line segments between vertices before computing the distance.</p> <p>Fr\u00e9chet distance sweep continuously along their respective curves and the direction of curves is significant. This makes it a better measure of similarity than Hausdorff distance for curve or surface matching.</p> <p>This implementation is based on [Computing Discrete Frechet Distance] by T. Eiter and H. Mannila.</p> <p>[Frechet distance]: en.wikipedia.org/wiki/Fr%C3%A9chet_distance [Computing Discrete Frechet Distance]: www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array other: the geometry or</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array or chunked array with float distance values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.geodesic_perimeter","title":"geodesic_perimeter","text":"<pre><code>geodesic_perimeter(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/compute/functions/#geoarrow.rust.compute.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array with output values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.is_empty","title":"is_empty","text":"<pre><code>is_empty(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Result array.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.length","title":"length","text":"<pre><code>length(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    *,\n    method: LengthMethod | LengthMethodT = LengthMethod.Euclidean\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Calculation of the length of a Line</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>               (<code>LengthMethod | LengthMethodT</code>)           \u2013            <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information. Defaults to LengthMethod.Euclidean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array or chunked array with length values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.line_interpolate_point","title":"line_interpolate_point","text":"<pre><code>line_interpolate_point(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    fraction: (\n        float\n        | int\n        | ArrowArrayExportable\n        | ArrowStreamExportable\n        | NumpyArrayProtocolf64\n    ),\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Returns a point interpolated at given distance on a line.</p> <p>This is intended to be equivalent to <code>shapely.line_interpolate_point</code> when <code>normalized=True</code>.</p> <p>If the given fraction is</p> <ul> <li>less than zero (including negative infinity): returns the starting point</li> <li>greater than one (including infinity): returns the ending point</li> <li>If either the fraction is NaN, or any coordinates of the line are not finite, returns <code>Point EMPTY</code>.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> <li> <code>fraction</code>               (<code>float | int | ArrowArrayExportable | ArrowStreamExportable | NumpyArrayProtocolf64</code>)           \u2013            <p>the fractional distance along the line. A variety of inputs are accepted:</p> <ul> <li>A Python <code>float</code> or <code>int</code></li> <li>A numpy <code>ndarray</code> with <code>float64</code> data type.</li> <li>An Arrow array or chunked array with <code>float64</code> data type.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>PointArray or ChunkedPointArray with result values</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.line_locate_point","title":"line_locate_point","text":"<pre><code>line_locate_point(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    point: GeoInterfaceProtocol | ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Returns a fraction of the line's total length representing the location of the closest point on the line to the given point.</p> <p>This is intended to be equivalent to <code>shapely.line_locate_point</code> when <code>normalized=True</code>.</p> <p>If the line has zero length the fraction returned is zero.</p> <p>If either the point's coordinates or any coordinates of the line are not finite, returns <code>NaN</code>.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> <li> <code>point</code>               (<code>GeoInterfaceProtocol | ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>the fractional distance along the line. A variety of inputs are accepted:</p> <ul> <li>A scalar <code>Point</code></li> <li>A <code>PointArray</code></li> <li>A <code>ChunkedPointArray</code></li> <li>Any Python class that implements the Geo Interface, such as a <code>shapely</code> Point</li> <li>Any GeoArrow array or chunked array of <code>Point</code> type</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array or chunked array with float fraction values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.polylabel","title":"polylabel","text":"<pre><code>polylabel(\n    input: ArrowArrayExportable | ArrowStreamExportable, tolerance: float\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Calculate a Polygon's ideal label position by calculating its pole of inaccessibility.</p> <p>The pole of inaccessibility is the most distant internal point from the polygon outline (not to be confused with centroid), and is useful for optimal placement of a text label on a polygon.</p> <p>The calculation uses an iterative grid-based algorithm, ported from the original JavaScript implementation.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> <li> <code>tolerance</code>               (<code>float</code>)           \u2013            <p>precision of algorithm. Refer to the original JavaScript documentation for more information</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>PointArray or ChunkedPointArray with result values</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.rotate","title":"rotate","text":"<pre><code>rotate(\n    geom: ArrowArrayExportable | ArrowStreamExportable,\n    angle: float,\n    *,\n    origin: RotateOrigin | RotateOriginT | tuple[float, float]\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre>"},{"location":"api/compute/functions/#geoarrow.rust.compute.scale","title":"scale","text":"<pre><code>scale(\n    geom: ArrowArrayExportable | ArrowStreamExportable,\n    xfact: float,\n    yfact: float,\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Returns a scaled geometry, scaled by factors along each dimension.</p> <p>Parameters:</p> <ul> <li> <code>geom</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>description</p> </li> <li> <code>xfact</code>               (<code>float</code>)           \u2013            <p>description</p> </li> <li> <code>yfact</code>               (<code>float</code>)           \u2013            <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.signed_area","title":"signed_area","text":"<pre><code>signed_area(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    *,\n    method: AreaMethod | AreaMethodT = AreaMethod.Euclidean\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>               (<code>AreaMethod | AreaMethodT</code>)           \u2013            <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array or chunked array with area values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.simplify","title":"simplify","text":"<pre><code>simplify(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    epsilon: float,\n    *,\n    method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> <li> <code>epsilon</code>               (<code>float</code>)           \u2013            <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>               (<code>SimplifyMethod | SimplifyMethodT</code>)           \u2013            <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information. Defaults to SimplifyMethod.RDP.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.skew","title":"skew","text":"<pre><code>skew(\n    geom: ArrowArrayExportable | ArrowStreamExportable, xs: float, ys: float\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>xs</code> and <code>ys</code> to distort the geometry's aspect ratio.</p> <p>Parameters:</p> <ul> <li> <code>geom</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>description</p> </li> <li> <code>xs</code>               (<code>float</code>)           \u2013            <p>description</p> </li> <li> <code>ys</code>               (<code>float</code>)           \u2013            <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.total_bounds","title":"total_bounds","text":"<pre><code>total_bounds(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>           \u2013            <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.translate","title":"translate","text":"<pre><code>translate(\n    geom: ArrowArrayExportable | ArrowStreamExportable, xoff: float, yoff: float\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Returns a scaled geometry, scaled by factors along each dimension.</p> <p>Parameters:</p> <ul> <li> <code>geom</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>description</p> </li> <li> <code>xoff</code>               (<code>float</code>)           \u2013            <p>description</p> </li> <li> <code>yoff</code>               (<code>float</code>)           \u2013            <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/compute/functions/#table-functions","title":"Table functions","text":""},{"location":"api/compute/functions/#geoarrow.rust.compute","title":"geoarrow.rust.compute","text":""},{"location":"api/compute/functions/#geoarrow.rust.compute.explode","title":"explode","text":"<pre><code>explode(input: ArrowStreamExportable) -&gt; Table\n</code></pre> <p>Explode a table.</p> <p>This is intended to be equivalent to the <code>explode</code> function in GeoPandas.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowStreamExportable</code>)           \u2013            <p>input table</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A new table with multi-part geometries exploded to separate rows.</p> </li> </ul>"},{"location":"api/compute/types/","title":"Types","text":""},{"location":"api/compute/types/#geoarrow.rust.compute.types","title":"geoarrow.rust.compute.types","text":""},{"location":"api/compute/types/#geoarrow.rust.compute.types.AreaMethodT","title":"AreaMethodT  <code>module-attribute</code>","text":"<pre><code>AreaMethodT = Literal['ellipsoidal', 'euclidean', 'spherical']\n</code></pre> <p>Acceptable strings to be passed into the <code>method</code> parameter for <code>area</code> and <code>signed_area</code>.</p>"},{"location":"api/compute/types/#geoarrow.rust.compute.types.LengthMethodT","title":"LengthMethodT  <code>module-attribute</code>","text":"<pre><code>LengthMethodT = Literal['ellipsoidal', 'euclidean', 'haversine', 'vincenty']\n</code></pre> <p>Acceptable strings to be passed into the <code>method</code> parameter for <code>length</code>.</p>"},{"location":"api/compute/types/#geoarrow.rust.compute.types.RotateOriginT","title":"RotateOriginT  <code>module-attribute</code>","text":"<pre><code>RotateOriginT = Literal['center', 'centroid']\n</code></pre> <p>Acceptable strings to be passed into the <code>origin</code> parameter for <code>rotate</code>.</p>"},{"location":"api/compute/types/#geoarrow.rust.compute.types.SimplifyMethodT","title":"SimplifyMethodT  <code>module-attribute</code>","text":"<pre><code>SimplifyMethodT = Literal['rdp', 'vw', 'vw_preserve']\n</code></pre> <p>Acceptable strings to be passed into the <code>method</code> parameter for <code>simplify</code>.</p>"},{"location":"api/compute/types/#geoarrow.rust.compute.types.GeoInterfaceProtocol","title":"GeoInterfaceProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>A scalar geometry that implements the Geo Interface protocol.</p>"},{"location":"api/compute/types/#geoarrow.rust.compute.types.NumpyArrayProtocolf64","title":"NumpyArrayProtocolf64","text":"<p>               Bases: <code>Protocol</code></p> <p>An object that implements the numpy array method.</p>"},{"location":"api/core/","title":"<code>geoarrow.rust.core</code>","text":"<p>Root for <code>geoarrow.rust.core</code> API docs.</p> <p>All functionality described within this directory are part of the <code>geoarrow.rust.core</code> submodule. To use, install the <code>geoarrow-rust-core</code> PyPI package:</p> <pre><code>pip install geoarrow-rust-core\n</code></pre>"},{"location":"api/core/enums/","title":"Enums","text":""},{"location":"api/core/enums/#geoarrow.rust.core.enums","title":"geoarrow.rust.core.enums","text":""},{"location":"api/core/enums/#geoarrow.rust.core.enums.CoordType","title":"CoordType","text":"<p>               Bases: <code>StrEnum</code></p> <p>Available GeoArrow coordinate types.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.CoordType.Interleaved","title":"Interleaved  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Interleaved = auto()\n</code></pre> <p>Interleaved coordinate layout.</p> <p>All coordinates are stored in a single buffer, as <code>XYXYXY</code>.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.CoordType.Separated","title":"Separated  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Separated = auto()\n</code></pre> <p>Separated coordinate layout.</p> <p>Coordinates are stored in a separate buffer per dimension, e.g. <code>XXXX</code> and <code>YYYY</code>.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.Dimension","title":"Dimension","text":"<p>               Bases: <code>StrEnum</code></p> <p>Geometry dimensions.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.Dimension.XY","title":"XY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XY = auto()\n</code></pre> <p>Two dimensions, X and Y</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.Dimension.XYZ","title":"XYZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XYZ = auto()\n</code></pre> <p>Three dimensions, X, Y, and Z</p>"},{"location":"api/core/functions/","title":"Functions","text":"<p>Interoperability with other Python geospatial libraries (Shapely, GeoPandas) and in-memory geospatial formats (WKB, WKT).</p>"},{"location":"api/core/functions/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/functions/#geoarrow.rust.core.read_pyogrio","title":"read_pyogrio","text":"<pre><code>read_pyogrio(\n    path_or_buffer: Path | str | bytes,\n    /,\n    layer: int | str | None = None,\n    encoding: str | None = None,\n    columns: Sequence[str] | None = None,\n    read_geometry: bool = True,\n    skip_features: int = 0,\n    max_features: int | None = None,\n    where: str | None = None,\n    bbox: Tuple[float, float, float, float] | Sequence[float] | None = None,\n    mask=None,\n    fids=None,\n    sql: str | None = None,\n    sql_dialect: str | None = None,\n    return_fids=False,\n    batch_size=65536,\n    **kwargs,\n) -&gt; RecordBatchReader\n</code></pre> <p>Read from an OGR data source to an Arrow Table</p> <p>Parameters:</p> <ul> <li> <code>path_or_buffer</code>               (<code>Path | str | bytes</code>)           \u2013            <p>A dataset path or URI, or raw buffer.</p> </li> <li> <code>layer</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>If an integer is provided, it corresponds to the index of the layer with the data source. If a string is provided, it must match the name of the layer in the data source. Defaults to first layer in data source.</p> </li> <li> <code>encoding</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If present, will be used as the encoding for reading string values from the data source, unless encoding can be inferred directly from the data source.</p> </li> <li> <code>columns</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of column names to import from the data source. Column names must exactly match the names in the data source, and will be returned in the order they occur in the data source. To avoid reading any columns, pass an empty list-like.</p> </li> <li> <code>read_geometry</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will read geometry into a GeoSeries. If False, a Pandas DataFrame will be returned instead. Default: <code>True</code>.</p> </li> <li> <code>skip_features</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of features to skip from the beginning of the file before returning features. If greater than available number of features, an empty DataFrame will be returned. Using this parameter may incur significant overhead if the driver does not support the capability to randomly seek to a specific feature, because it will need to iterate over all prior features.</p> </li> <li> <code>max_features</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of features to read from the file. Default: <code>None</code>.</p> </li> <li> <code>where</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Where clause to filter features in layer by attribute values. If the data source natively supports SQL, its specific SQL dialect should be used (eg. SQLite and GeoPackage: <code>SQLITE</code>, PostgreSQL). If it doesn't, the <code>OGRSQL WHERE</code> syntax should be used. Note that it is not possible to overrule the SQL dialect, this is only possible when you use the <code>sql</code> parameter.</p> <p>Examples: <code>\"ISO_A3 = 'CAN'\"</code>, <code>\"POP_EST &gt; 10000000 AND POP_EST &lt; 100000000\"</code></p> </li> <li> <code>bbox</code>               (<code>Tuple[float, float, float, float] | Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>If present, will be used to filter records whose geometry intersects this box. This must be in the same CRS as the dataset. If GEOS is present and used by GDAL, only geometries that intersect this bbox will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect this bbox will be returned. Cannot be combined with <code>mask</code> keyword.</p> </li> <li> <code>mask</code>           \u2013            <p>Shapely geometry, optional (default: <code>None</code>) If present, will be used to filter records whose geometry intersects this geometry. This must be in the same CRS as the dataset. If GEOS is present and used by GDAL, only geometries that intersect this geometry will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect the bounding box of this geometry will be returned. Requires Shapely &gt;= 2.0. Cannot be combined with <code>bbox</code> keyword.</p> </li> <li> <code>fids</code>           \u2013            <p>array-like, optional (default: <code>None</code>) Array of integer feature id (FID) values to select. Cannot be combined with other keywords to select a subset (<code>skip_features</code>, <code>max_features</code>, <code>where</code>, <code>bbox</code>, <code>mask</code>, or <code>sql</code>). Note that the starting index is driver and file specific (e.g. typically 0 for Shapefile and 1 for GeoPackage, but can still depend on the specific file). The performance of reading a large number of features usings FIDs is also driver specific.</p> </li> <li> <code>sql</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The SQL statement to execute. Look at the sql_dialect parameter for more information on the syntax to use for the query. When combined with other keywords like <code>columns</code>, <code>skip_features</code>, <code>max_features</code>, <code>where</code>, <code>bbox</code>, or <code>mask</code>, those are applied after the SQL query. Be aware that this can have an impact on performance, (e.g. filtering with the <code>bbox</code> or <code>mask</code> keywords may not use spatial indexes). Cannot be combined with the <code>layer</code> or <code>fids</code> keywords.</p> </li> <li> <code>sql_dialect</code>           \u2013            <p>str, optional (default: <code>None</code>) The SQL dialect the SQL statement is written in. Possible values:</p> <ul> <li>None: if the data source natively supports SQL, its specific SQL dialect     will be used by default (eg. SQLite and Geopackage: <code>SQLITE</code>, PostgreSQL).     If the data source doesn't natively support SQL, the <code>OGRSQL</code> dialect is     the default.</li> <li><code>'OGRSQL'</code>: can be used on any data source. Performance can suffer     when used on data sources with native support for SQL.</li> <li><code>'SQLITE'</code>: can be used on any data source. All spatialite     functions can be used. Performance can suffer on data sources with     native support for SQL, except for Geopackage and SQLite as this is     their native SQL dialect.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>RecordBatchReader</code>           \u2013            <p>Table</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.from_ewkb","title":"from_ewkb","text":"<pre><code>from_ewkb(input: ArrowArrayExportable) -&gt; GeometryArray\n</code></pre> <p>Parse an Arrow BinaryArray from EWKB to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable</code>)           \u2013            <p>An Arrow array of Binary type holding EWKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray</code>           \u2013            <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.from_geopandas","title":"from_geopandas","text":"<pre><code>from_geopandas(input: GeoDataFrame) -&gt; Table\n</code></pre> <p>Create a GeoArrow Table from a GeoPandas GeoDataFrame.</p>"},{"location":"api/core/functions/#geoarrow.rust.core.from_geopandas--notes","title":"Notes:","text":"<ul> <li>Currently this will always generate a non-chunked GeoArrow array. This is partly because pyarrow.Table.from_pandas always creates a single batch.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>GeoDataFrame</code>)           \u2013            <p>A GeoPandas GeoDataFrame.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A GeoArrow Table</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.from_shapely","title":"from_shapely","text":"<pre><code>from_shapely(input, *, crs: Any | None = None) -&gt; GeometryArray\n</code></pre> <p>Create a GeoArrow array from an array of Shapely geometries.</p>"},{"location":"api/core/functions/#geoarrow.rust.core.from_shapely--notes","title":"Notes:","text":"<ul> <li>Currently this will always generate a non-chunked GeoArrow array. Use the <code>from_shapely</code> method on a chunked GeoArrow array class to construct a chunked array.</li> <li>This will first call <code>to_ragged_array</code>, falling back to <code>to_wkb</code> if necessary. If you know you have mixed-type geometries in your column, use <code>MixedGeometryArray.from_shapely</code>.</li> </ul> <p>This is because <code>to_ragged_array</code> is the fastest approach but fails on mixed-type geometries. It supports combining Multi-* geometries with non-multi-geometries in the same array, so you can combine e.g. Point and MultiPoint geometries in the same array, but <code>to_ragged_array</code> doesn't work if you have Point and Polygon geometries in the same array.</p> <p>Args:</p> <p>input: Any array object accepted by Shapely, including numpy object arrays and <code>geopandas.GeoSeries</code>.</p> <p>Returns:</p> <pre><code>A GeoArrow array\n</code></pre>"},{"location":"api/core/functions/#geoarrow.rust.core.from_wkb","title":"from_wkb","text":"<pre><code>from_wkb(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    *,\n    coord_type: CoordType | CoordTypeT = CoordType.Interleaved\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>coord_type</code>               (<code>CoordType | CoordTypeT</code>)           \u2013            <p>Specify the coordinate type of the generated GeoArrow data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.from_wkt","title":"from_wkt","text":"<pre><code>from_wkt(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    *,\n    coord_type: CoordType | CoordTypeT = CoordType.Interleaved\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Parse an Arrow StringArray from WKT to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>An Arrow array of string type holding WKT-formatted geometries.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>coord_type</code>               (<code>CoordType | CoordTypeT</code>)           \u2013            <p>Specify the coordinate type of the generated GeoArrow data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.to_geopandas","title":"to_geopandas","text":"<pre><code>to_geopandas(input: ArrowStreamExportable) -&gt; GeoDataFrame\n</code></pre> <p>Convert a GeoArrow Table to a GeoPandas GeoDataFrame.</p>"},{"location":"api/core/functions/#geoarrow.rust.core.to_geopandas--notes","title":"Notes:","text":"<ul> <li>This is an alias to GeoDataFrame.from_arrow.</li> </ul> <p>Args: input: A GeoArrow Table.</p> <p>Returns:</p> <ul> <li> <code>GeoDataFrame</code>           \u2013            <p>the converted GeoDataFrame</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.to_shapely","title":"to_shapely","text":"<pre><code>to_shapely(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; NDArray[object_]\n</code></pre> <p>Convert a GeoArrow array to a numpy array of Shapely objects</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray[object_]</code>           \u2013            <p>numpy array with Shapely objects</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.to_wkb","title":"to_wkb","text":"<pre><code>to_wkb(input: ArrowArrayExportable) -&gt; GeometryArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable</code>)           \u2013            <p>A GeoArrow-native geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray</code>           \u2013            <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/functions/#table-functions","title":"Table functions","text":""},{"location":"api/core/functions/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/functions/#geoarrow.rust.core.geometry_col","title":"geometry_col","text":"<pre><code>geometry_col(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; GeometryArray | ChunkedGeometryArray\n</code></pre> <p>Access the geometry column of a Table or RecordBatch</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>The Arrow RecordBatch or Table to extract the geometry column from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray | ChunkedGeometryArray</code>           \u2013            <p>A geometry array or chunked array.</p> </li> </ul>"},{"location":"api/core/types/","title":"Types","text":""},{"location":"api/core/types/#geoarrow.rust.core.types","title":"geoarrow.rust.core.types","text":""},{"location":"api/core/types/#geoarrow.rust.core.types.CoordTypeT","title":"CoordTypeT  <code>module-attribute</code>","text":"<pre><code>CoordTypeT = Literal['interleaved', 'separated']\n</code></pre> <p>Acceptable coord_type strings.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.DimensionT","title":"DimensionT  <code>module-attribute</code>","text":"<pre><code>DimensionT = Literal['XY', 'XYZ', 'xy', 'xyz']\n</code></pre> <p>Acceptable dimension strings.</p>"},{"location":"api/core/geometry/array/","title":"GeometryArray","text":""},{"location":"api/core/geometry/array/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryArray","title":"GeometryArray","text":"<p>An immutable array of geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryArray.__geo_interface__","title":"__geo_interface__  <code>property</code>","text":"<pre><code>__geo_interface__: dict\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryArray.type","title":"type  <code>property</code>","text":"<pre><code>type: GeometryType\n</code></pre> <p>Get the geometry type of this array.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryArray.__arrow_c_array__","title":"__arrow_c_array__","text":"<pre><code>__arrow_c_array__(\n    requested_schema: object | None = None,\n) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryArray.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: int) -&gt; Geometry\n</code></pre> <p>Access the item at a given index</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryArray.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Text representation</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryArray.from_arrow","title":"from_arrow  <code>classmethod</code>","text":"<pre><code>from_arrow(data: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>           \u2013            <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryArray.from_arrow_pycapsule","title":"from_arrow_pycapsule  <code>classmethod</code>","text":"<pre><code>from_arrow_pycapsule(schema_capsule: object, array_capsule: object) -&gt; Self\n</code></pre> <p>Construct this object from raw Arrow capsules.</p>"},{"location":"api/core/geometry/chunked/","title":"ChunkedGeometryArray","text":""},{"location":"api/core/geometry/chunked/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryArray","title":"ChunkedGeometryArray","text":"<p>An immutable chunked array of geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryArray.type","title":"type  <code>property</code>","text":"<pre><code>type: GeometryType\n</code></pre> <p>Get the geometry type of this array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryArray.__arrow_c_stream__","title":"__arrow_c_stream__","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryArray.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: int) -&gt; Geometry\n</code></pre> <p>Access the item at a given index.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryArray.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Text representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryArray.chunk","title":"chunk","text":"<pre><code>chunk(i: int) -&gt; GeometryArray\n</code></pre> <p>Access a single underlying chunk.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryArray.chunks","title":"chunks","text":"<pre><code>chunks() -&gt; List[GeometryArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryArray.from_arrow","title":"from_arrow  <code>classmethod</code>","text":"<pre><code>from_arrow(data: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>           \u2013            <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryArray.from_arrow_pycapsule","title":"from_arrow_pycapsule  <code>classmethod</code>","text":"<pre><code>from_arrow_pycapsule(schema_capsule: object, array_capsule: object) -&gt; Self\n</code></pre> <p>Construct this object from raw Arrow capsules.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryArray.num_chunks","title":"num_chunks","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/scalar/","title":"Geometry","text":""},{"location":"api/core/geometry/scalar/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Geometry","title":"Geometry","text":"<p>An immutable geometry scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Geometry.__geo_interface__","title":"__geo_interface__  <code>property</code>","text":"<pre><code>__geo_interface__: dict\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Geometry.__arrow_c_array__","title":"__arrow_c_array__","text":"<pre><code>__arrow_c_array__(\n    requested_schema: object | None = None,\n) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/io/enums/","title":"Enums","text":""},{"location":"api/io/enums/#geoarrow.rust.io.enums","title":"geoarrow.rust.io.enums","text":""},{"location":"api/io/enums/#geoarrow.rust.io.enums.GeoParquetEncoding","title":"GeoParquetEncoding","text":"<p>               Bases: <code>StrEnum</code></p> <p>Options for geometry encoding in GeoParquet.</p>"},{"location":"api/io/enums/#geoarrow.rust.io.enums.GeoParquetEncoding.Native","title":"Native  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Native = auto()\n</code></pre> <p>Use native GeoArrow geometry types when writing GeoParquet files.</p> <p>Supported as of GeoParquet version 1.1.</p> <p>This option provides for better read and write performance and for inferring spatial partitioning from remote files. But it does not yet have widespread support.</p>"},{"location":"api/io/enums/#geoarrow.rust.io.enums.GeoParquetEncoding.WKB","title":"WKB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WKB = auto()\n</code></pre> <p>Use Well-Known Binary (WKB) encoding when writing GeoParquet files.</p>"},{"location":"api/io/functions/","title":"Functions","text":"<p>Read and write to and from geospatial file formats.</p>"},{"location":"api/io/functions/#geoarrow.rust.io","title":"geoarrow.rust.io","text":""},{"location":"api/io/functions/#geoarrow.rust.io.ObjectStore","title":"ObjectStore","text":""},{"location":"api/io/functions/#geoarrow.rust.io.ParquetDataset","title":"ParquetDataset","text":""},{"location":"api/io/functions/#geoarrow.rust.io.ParquetDataset.num_row_groups","title":"num_row_groups  <code>property</code>","text":"<pre><code>num_row_groups: int\n</code></pre> <p>The total number of row groups across all files</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetDataset.num_rows","title":"num_rows  <code>property</code>","text":"<pre><code>num_rows: int\n</code></pre> <p>The total number of rows across all files.</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetDataset.schema_arrow","title":"schema_arrow  <code>property</code>","text":"<pre><code>schema_arrow: Schema\n</code></pre> <p>Access the Arrow schema of the generated data</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetDataset.crs","title":"crs","text":"<pre><code>crs(column_name: str | None = None) -&gt; CRS\n</code></pre> <p>Access the CRS of this file.</p> <p>Parameters:</p> <ul> <li> <code>column_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The geometry column name. If there is more than one geometry column in the file, you must specify which you want to read. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CRS</code>           \u2013            <p>CRS</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetDataset.read","title":"read","text":"<pre><code>read(\n    *,\n    batch_size: int | None = None,\n    limit: int | None = None,\n    offset: int | None = None,\n    bbox: Sequence[IntFloat] | None = None,\n    bbox_paths: BboxPaths | None = None\n) -&gt; Table\n</code></pre> <p>Perform a sync read with the given options</p> <p>Parameters:</p> <ul> <li> <code>batch_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>offset</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>bbox</code>               (<code>Sequence[IntFloat] | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>bbox_paths</code>               (<code>BboxPaths | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetDataset.read_async","title":"read_async  <code>async</code>","text":"<pre><code>read_async(\n    *,\n    batch_size: int | None = None,\n    limit: int | None = None,\n    offset: int | None = None,\n    bbox: Sequence[IntFloat] | None = None,\n    bbox_paths: BboxPaths | None = None\n) -&gt; Table\n</code></pre> <p>Perform an async read with the given options</p> <p>Parameters:</p> <ul> <li> <code>batch_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>offset</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>bbox</code>               (<code>Sequence[IntFloat] | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>bbox_paths</code>               (<code>BboxPaths | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetFile","title":"ParquetFile","text":""},{"location":"api/io/functions/#geoarrow.rust.io.ParquetFile.num_row_groups","title":"num_row_groups  <code>property</code>","text":"<pre><code>num_row_groups: int\n</code></pre> <p>The number of row groups in this file.</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetFile.num_rows","title":"num_rows  <code>property</code>","text":"<pre><code>num_rows: int\n</code></pre> <p>The number of rows in this file.</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetFile.schema_arrow","title":"schema_arrow  <code>property</code>","text":"<pre><code>schema_arrow: Schema\n</code></pre> <p>Access the Arrow schema of the generated data</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetFile.crs","title":"crs","text":"<pre><code>crs(column_name: str | None = None) -&gt; CRS\n</code></pre> <p>Access the CRS of this file.</p> <p>Parameters:</p> <ul> <li> <code>column_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The geometry column name. If there is more than one geometry column in the file, you must specify which you want to read. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CRS</code>           \u2013            <p>CRS</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetFile.file_bbox","title":"file_bbox","text":"<pre><code>file_bbox() -&gt; List[float] | None\n</code></pre> <p>Access the bounding box of the given column for the entire file</p> <p>If no column name is passed, retrieves the bbox from the primary geometry column.</p> <p>An Err will be returned if the column name does not exist in the dataset None will be returned if the metadata does not contain bounding box information.</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetFile.read","title":"read","text":"<pre><code>read(\n    *,\n    batch_size: int | None = None,\n    limit: int | None = None,\n    offset: int | None = None,\n    bbox: Sequence[IntFloat] | None = None,\n    bbox_paths: BboxPaths | None = None\n) -&gt; Table\n</code></pre> <p>Perform a sync read with the given options</p> <p>Parameters:</p> <ul> <li> <code>batch_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>offset</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>bbox</code>               (<code>Sequence[IntFloat] | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>bbox_paths</code>               (<code>BboxPaths | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetFile.read_async","title":"read_async  <code>async</code>","text":"<pre><code>read_async(\n    *,\n    batch_size: int | None = None,\n    limit: int | None = None,\n    offset: int | None = None,\n    bbox: Sequence[IntFloat] | None = None,\n    bbox_paths: BboxPaths | None = None\n) -&gt; Table\n</code></pre> <p>Perform an async read with the given options</p> <p>Parameters:</p> <ul> <li> <code>batch_size</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>offset</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>bbox</code>               (<code>Sequence[IntFloat] | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> <li> <code>bbox_paths</code>               (<code>BboxPaths | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetFile.row_group_bounds","title":"row_group_bounds","text":"<pre><code>row_group_bounds(\n    row_group_idx: int, bbox_paths: BboxPaths | None = None\n) -&gt; List[float]\n</code></pre> <p>Get the bounds of a single row group.</p> <p>Parameters:</p> <ul> <li> <code>row_group_idx</code>               (<code>int</code>)           \u2013            <p>The row group index.</p> </li> <li> <code>bbox_paths</code>               (<code>BboxPaths | None</code>, default:                   <code>None</code> )           \u2013            <p>For files written with spatial partitioning, you don't need to pass in these column names, as they'll be specified in the metadata Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>The bounds of a single row group.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetFile.row_groups_bounds","title":"row_groups_bounds","text":"<pre><code>row_groups_bounds(bbox_paths: BboxPaths | None = None) -&gt; GeometryArray\n</code></pre> <p>Get the bounds of all row groups.</p> <p>As of GeoParquet 1.1 you won't need to pass in these column names, as they'll be specified in the metadata.</p> <p>Parameters:</p> <ul> <li> <code>bbox_paths</code>               (<code>BboxPaths | None</code>, default:                   <code>None</code> )           \u2013            <p>For files written with spatial partitioning, you don't need to pass in these column names, as they'll be specified in the metadata Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeometryArray</code>           \u2013            <p>A geoarrow \"box\" array with bounds of all row groups.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetWriter","title":"ParquetWriter","text":"<p>Writer interface for a single Parquet file.</p> <p>This allows you to write Parquet files that are larger than memory.</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetWriter.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this file.</p> <p>The recommended use of this class is as a context manager, which will close the file automatically.</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetWriter.is_closed","title":"is_closed","text":"<pre><code>is_closed() -&gt; bool\n</code></pre> <p>Returns <code>True</code> if the file has already been closed.</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetWriter.write_batch","title":"write_batch","text":"<pre><code>write_batch(batch: ArrowArrayExportable) -&gt; None\n</code></pre> <p>Write a single RecordBatch to the Parquet file</p>"},{"location":"api/io/functions/#geoarrow.rust.io.ParquetWriter.write_table","title":"write_table","text":"<pre><code>write_table(table: ArrowArrayExportable | ArrowStreamExportable) -&gt; None\n</code></pre> <p>Write a table or stream of batches to the Parquet file</p> <p>This accepts an Arrow RecordBatch, Table, or RecordBatchReader. If a RecordBatchReader is passed, only one batch at a time will be materialized in memory.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>description</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.read_csv","title":"read_csv","text":"<pre><code>read_csv(\n    file: str | Path | BinaryIO,\n    geometry_column_name: str,\n    *,\n    batch_size: int = 65536\n) -&gt; Table\n</code></pre> <p>Read a CSV file from a path on disk into a Table.</p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>str | Path | BinaryIO</code>)           \u2013            <p>the path to the file or a Python file object in binary read mode.</p> </li> <li> <code>geometry_column_name</code>               (<code>str</code>)           \u2013            <p>the name of the geometry column within the CSV.</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>the number of rows to include in each internal batch of the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>Table from CSV file.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.read_flatgeobuf","title":"read_flatgeobuf","text":"<pre><code>read_flatgeobuf(\n    file: Union[str, Path, BinaryIO],\n    *,\n    fs: Optional[ObjectStore] = None,\n    batch_size: int = 65536,\n    bbox: Tuple[float, float, float, float] | None = None\n) -&gt; Table\n</code></pre> <p>Read a FlatGeobuf file from a path on disk or a remote location into an Arrow Table.</p> <p>Example:</p> <p>Reading from a local path:</p> <pre><code>from geoarrow.rust.core import read_flatgeobuf\ntable = read_flatgeobuf(\"path/to/file.fgb\")\n</code></pre> <p>Reading from a Python file object:</p> <pre><code>from geoarrow.rust.core import read_flatgeobuf\n\nwith open(\"path/to/file.fgb\", \"rb\") as file:\n    table = read_flatgeobuf(file)\n</code></pre> <p>Reading from an HTTP(S) url:</p> <pre><code>from geoarrow.rust.core import read_flatgeobuf\n\nurl = \"http://flatgeobuf.org/test/data/UScounties.fgb\"\ntable = read_flatgeobuf(url)\n</code></pre> <p>Reading from a remote file on an S3 bucket.</p> <pre><code>from geoarrow.rust.core import ObjectStore, read_flatgeobuf\n\noptions = {\n    \"aws_access_key_id\": \"...\",\n    \"aws_secret_access_key\": \"...\",\n    \"aws_region\": \"...\"\n}\nfs = ObjectStore('s3://bucket', options=options)\ntable = read_flatgeobuf(\"path/in/bucket.fgb\", fs=fs)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Union[str, Path, BinaryIO]</code>)           \u2013            <p>the path to the file or a Python file object in binary read mode.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>fs</code>               (<code>Optional[ObjectStore]</code>)           \u2013            <p>an ObjectStore instance for this url. This is required only if the file is at a remote location.</p> </li> <li> <code>batch_size</code>               (<code>int</code>)           \u2013            <p>the number of rows to include in each internal batch of the table.</p> </li> <li> <code>bbox</code>               (<code>Tuple[float, float, float, float] | None</code>)           \u2013            <p>A spatial filter for reading rows, of the format (minx, miny, maxx, maxy). If set to</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>Table from FlatGeobuf file.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.read_flatgeobuf_async","title":"read_flatgeobuf_async  <code>async</code>","text":"<pre><code>read_flatgeobuf_async(\n    path: str,\n    *,\n    fs: Optional[ObjectStore] = None,\n    batch_size: int = 65536,\n    bbox: Tuple[float, float, float, float] | None = None\n) -&gt; Table\n</code></pre> <p>Read a FlatGeobuf file from a url into an Arrow Table.</p> <p>Example:</p> <p>Reading from an HTTP(S) url:</p> <pre><code>from geoarrow.rust.core import read_flatgeobuf_async\n\nurl = \"http://flatgeobuf.org/test/data/UScounties.fgb\"\ntable = await read_flatgeobuf_async(url)\n</code></pre> <p>Reading from an S3 bucket:</p> <pre><code>from geoarrow.rust.core import ObjectStore, read_flatgeobuf_async\n\noptions = {\n    \"aws_access_key_id\": \"...\",\n    \"aws_secret_access_key\": \"...\",\n    \"aws_region\": \"...\"\n}\nfs = ObjectStore('s3://bucket', options=options)\ntable = await read_flatgeobuf_async(\"path/in/bucket.fgb\", fs=fs)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>the url or relative path to a remote FlatGeobuf file. If an argument is passed for <code>fs</code>, this should be a path fragment relative to the root passed to the <code>ObjectStore</code> constructor.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>fs</code>               (<code>Optional[ObjectStore]</code>)           \u2013            <p>an ObjectStore instance for this url. This is required for non-HTTP urls.</p> </li> <li> <code>batch_size</code>               (<code>int</code>)           \u2013            <p>the number of rows to include in each internal batch of the table.</p> </li> <li> <code>bbox</code>               (<code>Tuple[float, float, float, float] | None</code>)           \u2013            <p>A spatial filter for reading rows, of the format (minx, miny, maxx, maxy). If set to</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>Table from FlatGeobuf file.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.read_geojson","title":"read_geojson","text":"<pre><code>read_geojson(\n    file: Union[str, Path, BinaryIO], *, batch_size: int = 65536\n) -&gt; Table\n</code></pre> <p>Read a GeoJSON file from a path on disk into an Arrow Table.</p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Union[str, Path, BinaryIO]</code>)           \u2013            <p>the path to the file or a Python file object in binary read mode.</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>the number of rows to include in each internal batch of the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>Table from GeoJSON file.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.read_geojson_lines","title":"read_geojson_lines","text":"<pre><code>read_geojson_lines(\n    file: Union[str, Path, BinaryIO], *, batch_size: int = 65536\n) -&gt; Table\n</code></pre> <p>Read a newline-delimited GeoJSON file from a path on disk into an Arrow Table.</p> <p>This expects a GeoJSON Feature on each line of a text file, with a newline character separating each Feature.</p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Union[str, Path, BinaryIO]</code>)           \u2013            <p>the path to the file or a Python file object in binary read mode.</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>the number of rows to include in each internal batch of the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>Table from GeoJSON file.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.read_parquet","title":"read_parquet","text":"<pre><code>read_parquet(\n    path: Union[str, Path, BinaryIO],\n    *,\n    fs: Optional[ObjectStore] = None,\n    batch_size: int = 65536\n) -&gt; Table\n</code></pre> <p>Read a GeoParquet file from a path on disk into an Arrow Table.</p> <p>Example:</p> <p>Reading from a local path:</p> <pre><code>from geoarrow.rust.core import read_parquet\ntable = read_parquet(\"path/to/file.parquet\")\n</code></pre> <p>Reading from an HTTP(S) url:</p> <pre><code>from geoarrow.rust.core import read_parquet\n\nurl = \"https://raw.githubusercontent.com/opengeospatial/geoparquet/v1.0.0/examples/example.parquet\"\ntable = read_parquet(url)\n</code></pre> <p>Reading from a remote file on an S3 bucket.</p> <pre><code>from geoarrow.rust.core import ObjectStore, read_parquet\n\noptions = {\n    \"aws_access_key_id\": \"...\",\n    \"aws_secret_access_key\": \"...\",\n    \"aws_region\": \"...\"\n}\nfs = ObjectStore('s3://bucket', options=options)\ntable = read_parquet(\"path/in/bucket.parquet\", fs=fs)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Union[str, Path, BinaryIO]</code>)           \u2013            <p>the path to the file</p> </li> <li> <code>fs</code>               (<code>Optional[ObjectStore]</code>, default:                   <code>None</code> )           \u2013            <p>the ObjectStore to read from. Defaults to None.</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>the number of rows to include in each internal batch of the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>Table from GeoParquet file.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.read_parquet_async","title":"read_parquet_async  <code>async</code>","text":"<pre><code>read_parquet_async(\n    path: Union[str, Path, BinaryIO],\n    *,\n    fs: Optional[ObjectStore] = None,\n    batch_size: int = 65536\n) -&gt; Table\n</code></pre> <p>Read a GeoParquet file from a path on disk into an Arrow Table.</p> <p>Examples:</p> <p>Reading from an HTTP(S) url:</p> <pre><code>from geoarrow.rust.core import read_parquet_async\n\nurl = \"https://raw.githubusercontent.com/opengeospatial/geoparquet/v1.0.0/examples/example.parquet\"\ntable = await read_parquet_async(url)\n</code></pre> <p>Reading from a remote file on an S3 bucket.</p> <pre><code>from geoarrow.rust.core import ObjectStore, read_parquet_async\n\noptions = {\n    \"aws_access_key_id\": \"...\",\n    \"aws_secret_access_key\": \"...\",\n    \"aws_region\": \"...\"\n}\nfs = ObjectStore('s3://bucket', options=options)\ntable = await read_parquet_async(\"path/in/bucket.parquet\", fs=fs)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Union[str, Path, BinaryIO]</code>)           \u2013            <p>the path to the file</p> </li> <li> <code>fs</code>               (<code>Optional[ObjectStore]</code>, default:                   <code>None</code> )           \u2013            <p>the ObjectStore to read from. Defaults to None.</p> </li> <li> <code>batch_size</code>               (<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>the number of rows to include in each internal batch of the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>Table from GeoParquet file.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.read_postgis","title":"read_postgis","text":"<pre><code>read_postgis(connection_url: str, sql: str) -&gt; Optional[Table]\n</code></pre> <p>Read a PostGIS query into an Arrow Table.</p> <p>Parameters:</p> <ul> <li> <code>connection_url</code>               (<code>str</code>)           \u2013            <p>description</p> </li> <li> <code>sql</code>               (<code>str</code>)           \u2013            <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Table]</code>           \u2013            <p>Table from query.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.read_postgis_async","title":"read_postgis_async  <code>async</code>","text":"<pre><code>read_postgis_async(connection_url: str, sql: str) -&gt; Optional[Table]\n</code></pre> <p>Read a PostGIS query into an Arrow Table.</p> <p>Parameters:</p> <ul> <li> <code>connection_url</code>               (<code>str</code>)           \u2013            <p>description</p> </li> <li> <code>sql</code>               (<code>str</code>)           \u2013            <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Table]</code>           \u2013            <p>Table from query.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.read_pyogrio","title":"read_pyogrio","text":"<pre><code>read_pyogrio(\n    path_or_buffer: Path | str | bytes,\n    /,\n    layer: int | str | None = None,\n    encoding: str | None = None,\n    columns: Sequence[str] | None = None,\n    read_geometry: bool = True,\n    skip_features: int = 0,\n    max_features: int | None = None,\n    where: str | None = None,\n    bbox: Tuple[float, float, float, float] | Sequence[float] | None = None,\n    mask=None,\n    fids=None,\n    sql: str | None = None,\n    sql_dialect: str | None = None,\n    return_fids=False,\n    batch_size=65536,\n    **kwargs,\n) -&gt; RecordBatchReader\n</code></pre> <p>Read from an OGR data source to an Arrow Table</p> <p>Parameters:</p> <ul> <li> <code>path_or_buffer</code>               (<code>Path | str | bytes</code>)           \u2013            <p>A dataset path or URI, or raw buffer.</p> </li> <li> <code>layer</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>If an integer is provided, it corresponds to the index of the layer with the data source. If a string is provided, it must match the name of the layer in the data source. Defaults to first layer in data source.</p> </li> <li> <code>encoding</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If present, will be used as the encoding for reading string values from the data source, unless encoding can be inferred directly from the data source.</p> </li> <li> <code>columns</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of column names to import from the data source. Column names must exactly match the names in the data source, and will be returned in the order they occur in the data source. To avoid reading any columns, pass an empty list-like.</p> </li> <li> <code>read_geometry</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, will read geometry into a GeoSeries. If False, a Pandas DataFrame will be returned instead. Default: <code>True</code>.</p> </li> <li> <code>skip_features</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of features to skip from the beginning of the file before returning features. If greater than available number of features, an empty DataFrame will be returned. Using this parameter may incur significant overhead if the driver does not support the capability to randomly seek to a specific feature, because it will need to iterate over all prior features.</p> </li> <li> <code>max_features</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Number of features to read from the file. Default: <code>None</code>.</p> </li> <li> <code>where</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Where clause to filter features in layer by attribute values. If the data source natively supports SQL, its specific SQL dialect should be used (eg. SQLite and GeoPackage: <code>SQLITE</code>, PostgreSQL). If it doesn't, the <code>OGRSQL WHERE</code> syntax should be used. Note that it is not possible to overrule the SQL dialect, this is only possible when you use the <code>sql</code> parameter.</p> <p>Examples: <code>\"ISO_A3 = 'CAN'\"</code>, <code>\"POP_EST &gt; 10000000 AND POP_EST &lt; 100000000\"</code></p> </li> <li> <code>bbox</code>               (<code>Tuple[float, float, float, float] | Sequence[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>If present, will be used to filter records whose geometry intersects this box. This must be in the same CRS as the dataset. If GEOS is present and used by GDAL, only geometries that intersect this bbox will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect this bbox will be returned. Cannot be combined with <code>mask</code> keyword.</p> </li> <li> <code>mask</code>           \u2013            <p>Shapely geometry, optional (default: <code>None</code>) If present, will be used to filter records whose geometry intersects this geometry. This must be in the same CRS as the dataset. If GEOS is present and used by GDAL, only geometries that intersect this geometry will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect the bounding box of this geometry will be returned. Requires Shapely &gt;= 2.0. Cannot be combined with <code>bbox</code> keyword.</p> </li> <li> <code>fids</code>           \u2013            <p>array-like, optional (default: <code>None</code>) Array of integer feature id (FID) values to select. Cannot be combined with other keywords to select a subset (<code>skip_features</code>, <code>max_features</code>, <code>where</code>, <code>bbox</code>, <code>mask</code>, or <code>sql</code>). Note that the starting index is driver and file specific (e.g. typically 0 for Shapefile and 1 for GeoPackage, but can still depend on the specific file). The performance of reading a large number of features usings FIDs is also driver specific.</p> </li> <li> <code>sql</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The SQL statement to execute. Look at the sql_dialect parameter for more information on the syntax to use for the query. When combined with other keywords like <code>columns</code>, <code>skip_features</code>, <code>max_features</code>, <code>where</code>, <code>bbox</code>, or <code>mask</code>, those are applied after the SQL query. Be aware that this can have an impact on performance, (e.g. filtering with the <code>bbox</code> or <code>mask</code> keywords may not use spatial indexes). Cannot be combined with the <code>layer</code> or <code>fids</code> keywords.</p> </li> <li> <code>sql_dialect</code>           \u2013            <p>str, optional (default: <code>None</code>) The SQL dialect the SQL statement is written in. Possible values:</p> <ul> <li>None: if the data source natively supports SQL, its specific SQL dialect     will be used by default (eg. SQLite and Geopackage: <code>SQLITE</code>, PostgreSQL).     If the data source doesn't natively support SQL, the <code>OGRSQL</code> dialect is     the default.</li> <li><code>'OGRSQL'</code>: can be used on any data source. Performance can suffer     when used on data sources with native support for SQL.</li> <li><code>'SQLITE'</code>: can be used on any data source. All spatialite     functions can be used. Performance can suffer on data sources with     native support for SQL, except for Geopackage and SQLite as this is     their native SQL dialect.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>RecordBatchReader</code>           \u2013            <p>Table</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.write_csv","title":"write_csv","text":"<pre><code>write_csv(table: ArrowStreamExportable, file: str | Path | BinaryIO) -&gt; None\n</code></pre> <p>Write a Table to a CSV file on disk.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>ArrowStreamExportable</code>)           \u2013            <p>the Arrow RecordBatch, Table, or RecordBatchReader to write.</p> </li> <li> <code>file</code>               (<code>str | Path | BinaryIO</code>)           \u2013            <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.write_flatgeobuf","title":"write_flatgeobuf","text":"<pre><code>write_flatgeobuf(\n    table: ArrowStreamExportable,\n    file: str | Path | BinaryIO,\n    *,\n    write_index: bool = True\n) -&gt; None\n</code></pre> <p>Write to a FlatGeobuf file on disk.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>ArrowStreamExportable</code>)           \u2013            <p>the Arrow RecordBatch, Table, or RecordBatchReader to write.</p> </li> <li> <code>file</code>               (<code>str | Path | BinaryIO</code>)           \u2013            <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>write_index</code>               (<code>bool</code>)           \u2013            <p>whether to write a spatial index in the FlatGeobuf file. Defaults to True.</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.write_geojson","title":"write_geojson","text":"<pre><code>write_geojson(\n    table: ArrowStreamExportable, file: Union[str, Path, BinaryIO]\n) -&gt; None\n</code></pre> <p>Write to a GeoJSON file on disk.</p> <p>Note that the GeoJSON specification mandates coordinates to be in the WGS84 (EPSG:4326) coordinate system, but this function will not automatically reproject into WGS84 for you.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>ArrowStreamExportable</code>)           \u2013            <p>the Arrow RecordBatch, Table, or RecordBatchReader to write.</p> </li> <li> <code>file</code>               (<code>Union[str, Path, BinaryIO]</code>)           \u2013            <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.write_geojson_lines","title":"write_geojson_lines","text":"<pre><code>write_geojson_lines(\n    table: ArrowStreamExportable, file: Union[str, Path, BinaryIO]\n) -&gt; None\n</code></pre> <p>Write to a newline-delimited GeoJSON file on disk.</p> <p>Note that the GeoJSON specification mandates coordinates to be in the WGS84 (EPSG:4326) coordinate system, but this function will not automatically reproject into WGS84 for you.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>ArrowStreamExportable</code>)           \u2013            <p>the Arrow RecordBatch, Table, or RecordBatchReader to write.</p> </li> <li> <code>file</code>               (<code>Union[str, Path, BinaryIO]</code>)           \u2013            <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"api/io/functions/#geoarrow.rust.io.write_parquet","title":"write_parquet","text":"<pre><code>write_parquet(\n    table: ArrowStreamExportable,\n    file: Union[str, Path, BinaryIO],\n    *,\n    encoding: GeoParquetEncoding | GeoParquetEncodingT = GeoParquetEncoding.WKB\n) -&gt; None\n</code></pre> <p>Write an Arrow RecordBatch, Table, or RecordBatchReader to a GeoParquet file on disk.</p> <p>If a RecordBatchReader is passed, only one batch at a time will be materialized in memory.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>ArrowStreamExportable</code>)           \u2013            <p>the table to write.</p> </li> <li> <code>file</code>               (<code>Union[str, Path, BinaryIO]</code>)           \u2013            <p>the path to the file or a Python file object in binary write mode.</p> </li> <li> <code>encoding</code>               (<code>GeoParquetEncoding | GeoParquetEncodingT</code>, default:                   <code>WKB</code> )           \u2013            <p>the geometry encoding to use. Defaults to <code>GeoParquetEncoding.WKB</code>.</p> </li> </ul>"},{"location":"api/io/types/","title":"Types","text":""},{"location":"api/io/types/#geoarrow.rust.io.types","title":"geoarrow.rust.io.types","text":""},{"location":"api/io/types/#geoarrow.rust.io.types.GeoParquetEncodingT","title":"GeoParquetEncodingT  <code>module-attribute</code>","text":"<pre><code>GeoParquetEncodingT = Literal['wkb', 'native']\n</code></pre> <p>Acceptable strings to be passed into the <code>encoding</code> parameter for <code>write_parquet</code>.</p>"},{"location":"ecosystem/geopandas/","title":"GeoPandas","text":"<p>Use the <code>from_geopandas</code> and <code>to_geopandas</code> functions to convert to and from GeoPandas.</p> <pre><code>import geopandas as gpd\nfrom geoarrow.rust.core import from_geopandas, to_geopandas\n\ngdf = gpd.GeoDataFrame(...)\ntable = from_geopandas(gdf)\nback_to_geopandas_gdf = to_geopandas(table)\n</code></pre>"},{"location":"ecosystem/lonboard/","title":"Lonboard","text":"<p>Lonboard is a Python library for fast, interactive geospatial vector data visualization in Jupyter.</p> <p></p> <p>Lonboard was designed from the ground up to be used with GeoArrow and is the reason why Lonboard is fast.</p> <p>As of Lonboard version 0.6 or later, just pass a GeoTable as the <code>table</code> parameter of a layer.</p>"},{"location":"ecosystem/lonboard/#examples","title":"Examples","text":"<pre><code>from geoarrow.rust.core import read_geojson\nfrom lonboard import Map, PathLayer\n\npath = \"/path/to/file.geojson\"\ngeo_table = read_geojson(path)\ngeo_table.geometry\n\nlayer = PathLayer(table=geo_table)\nm = Map(layer)\nm\n</code></pre> <p>Refer to lonboard's documentation for more examples.</p>"},{"location":"ecosystem/pyogrio/","title":"Pyogrio/GDAL","text":"<p>Use the <code>read_pyogrio</code> function to read an OGR-supported data source through pyogrio.</p> <p>This requires the optional <code>pyogrio</code> and <code>pyarrow</code> dependencies.</p> <pre><code>from geoarrow.rust.core import read_pyogrio, geometry_col\n\npath = \"path/to/file.shp\"\ntable = read_pyogrio(path)\ngeometry = geometry_col(table)\n</code></pre>"},{"location":"ecosystem/shapely/","title":"Shapely","text":"<p>For interoperability with Shapely, use the top-level <code>to_shapely</code> and <code>from_shapely</code> functions.</p> <p>Shapely interoperability requires <code>shapely</code> to be installed, and requires Shapely version 2.0 or higher.</p>"},{"location":"ecosystem/shapely/#examples","title":"Examples","text":"<pre><code>from geoarrow.rust.core import from_shapely, to_shapely\nimport shapely\n\nshapely_geoms = to_shapely(geoarrow_array)\ngeoarrow_array = from_shapely(shapely_geoms)\n</code></pre>"},{"location":"performance/multithreading/","title":"Multi-threading","text":"<p>A Table contains internal \"chunking\" where the first n rows for all columns are part of the first chunk, then the next n rows for all columns are part of the second chunk, and so on. The geometry column of the table is a chunked geometry array, which similarly is grouped into batches of n rows.</p> <p>Multi-threading is enabled out-of-the-box for all operations on these chunked data structures.</p> <p>This means that to take advantage of multi-threading, your table must have internal chunking. This is the default whenever reading directly from a file (you can tweak the <code>batch_size</code> argument).</p> <p>When creating a table from an existing data source, such as GeoPandas or Pyogrio, the data may not already be chunked. In the future, a <code>rechunk</code> operation will be added to assist in creating more internal chunks to ensure operations are multi-threaded.</p>"}]}