{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>geoarrow-rust</code>","text":"<p>A Python library implementing the GeoArrow specification with efficient spatial operations. This library has \"rust\" in the name because it is implemented based on the GeoArrow Rust implementation.</p>"},{"location":"#project-goals","title":"Project goals","text":"<ul> <li>Fast: Connects to algorithms implemented in GeoRust, which compile to native code.</li> <li>Parallel: Multi-threading is enabled out-of-the-box for all operations on chunked data structures.</li> <li>Self-contained: Zero Python dependencies.</li> <li>Easy to install: Distributed as static binary wheels with zero C dependencies.</li> <li>Strong, static typing: geometry arrays have a known type</li> <li>Interoperable ecosystem: Data is shared at zero cost with other Python libraries in the burgeoning GeoArrow ecosystem, such as geoarrow-c or lightning-fast map rendering.</li> </ul> <p>More specifically, it contains:</p> <ul> <li>Classes to represent GeoArrow arrays: <code>PointArray</code>, <code>LineStringArray</code>, etc.</li> <li>Classes to represent chunked GeoArrow arrays: <code>ChunkedPointArray</code>, <code>ChunkedLineStringArray</code>, etc.</li> <li>A spatial table representation, <code>GeoTable</code>, where one column is a geospatial type and Apache Arrow is used to represent attribute columns. This enables future support for table-based operations like geospatial joins.</li> <li>Rust-based algorithms for computations on GeoArrow memory.</li> <li>Rust-based parsers for various geospatial file formats.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Refer to the documentation at geoarrow.github.io/geoarrow-rs/python.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install geoarrow-rust-core\n</code></pre> <p><code>geoarrow-rust</code> is distributed with namespace packaging, meaning that each python package <code>geoarrow-rust-[submodule-name]</code> (imported as <code>geoarrow.rust.[submodule-name]</code>) can be published to PyPI independently. The benefit of this approach is that core library \u2014 which contains only pure-Rust code \u2014 can be precompiled for many platforms very easily. Then other submodules with C dependencies, like a future <code>geoarrow-rust-geos</code>, which will bind to GEOS for spatial operations, can be built and packaged independently.</p>"},{"location":"#future-work","title":"Future work:","text":"<ul> <li> 3D coordinates. Only 2D geometries are supported at this time.</li> <li> More algorithms, including spatial indexes and spatial joins.</li> <li> CRS management. This currently loses the CRS information in the GeoArrow metadata.</li> </ul>"},{"location":"#background-reading","title":"Background reading","text":"<p>Refer to the GeoArrow Python module proposal for more background information.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#020-2024-03-22","title":"[0.2.0] - 2024-03-22","text":""},{"location":"CHANGELOG/#new","title":"New!","text":""},{"location":"CHANGELOG/#new-io-support-for-reading-and-writing-to-geospatial-formats","title":"New I/O support for reading and writing to geospatial formats","text":"<ul> <li>Asynchronous FlatGeobuf reader. This also supports passing a spatial filter.</li> <li>Initial support for reading from PostGIS. Note that not all Postgres data types are supported yet. Create an issue if your query fails.</li> <li>Reading and writing newline-delimited GeoJSON.</li> <li>Pyogrio integration for reading from OGR/GDAL.</li> <li>Asynchronous GeoParquet reader for reading from remote files. By @weiji14 in geoarrow/geoarrow-rs!493</li> <li>Also new support for writing GeoParquet files.</li> <li>Most I/O readers and writers support Python file-like objects (in binary mode).</li> <li>Support for reading and writing Arrow IPC files.</li> </ul>"},{"location":"CHANGELOG/#better-interoperability-with-the-python-geospatial-ecosystem","title":"Better interoperability with the Python geospatial ecosystem.","text":"<ul> <li>Import from and export to GeoPandas GeoDataFrames. Refer to the GeoPandas interoperability documentation.</li> <li>Import from and export to Shapely arrays. Refer to the Shapely interoperability documentation.</li> <li>Better integration with Lonboard for fast visualization in Jupyter.</li> <li>All scalars, arrays, chunked arrays, and table objects implement <code>__geo_interface__</code> for interoperability with existing tools.</li> <li>Numpy interoperability for float array output from algorithms. Pass any <code>Float64Array</code> or <code>BooleanArray</code> to <code>numpy.asarray</code>. You can also pass a numpy array as vectorized input into a function like <code>line_interpolate_point</code>.</li> </ul>"},{"location":"CHANGELOG/#new-algorithms","title":"New algorithms!","text":"<ul> <li>Explode a Table where each multi-geometry expands into multiple rows of single geometries.</li> <li><code>total_bounds</code></li> <li>Unified <code>area</code> function for planar and geodesic area.</li> <li>Unified <code>simplify</code> function for multiple simplification methods. Also new support for topology-preserving simplification.</li> <li>Unified <code>length</code> function for euclidean and geodesic length calculations.</li> <li><code>frechet_distance</code> for LineString similarity.</li> <li><code>affine_transform</code>, which integrates with the Python <code>affine</code> library.</li> <li><code>line_interpolate_point</code> and <code>line_locate_point</code> for linear referencing.</li> <li><code>polylabel</code> for polygon labeling.</li> </ul>"},{"location":"CHANGELOG/#improved-display-of-python-objects","title":"Improved display of Python objects:","text":"<ul> <li>Scalars now display as SVG geometries inside Jupyter environments.</li> <li>Tables, arrays, and chunked arrays implement <code>__repr__</code> so that you can inspect data easily.</li> </ul>"},{"location":"CHANGELOG/#improved-usability","title":"Improved usability:","text":"<ul> <li><code>PointArray.from_xy</code> to simplify creating a point array from numpy arrays of coordinates.</li> <li>Index into arrays and chunked arrays with square brackets. E.g. <code>point_array[0]</code> will access the first point in the array. Negative indexing is also supported, so <code>point_array[-1]</code> will get the last item in the array.</li> <li>New top-level docs website.</li> </ul>"},{"location":"CHANGELOG/#new-contributors","title":"New Contributors","text":"<ul> <li>@Robinlovelace made their first contribution in geoarrow/geoarrow-rs!484</li> <li>@weiji14 made their first contribution in geoarrow/geoarrow-rs!493</li> </ul> <p>Full Changelog: github.com/geoarrow/geoarrow-rs/compare/py-v0.1.0...py-v0.2.0</p>"},{"location":"CHANGELOG/#010-2024-01-08","title":"[0.1.0] - 2024-01-08","text":"<ul> <li>Initial public release.</li> </ul>"},{"location":"api/core/","title":"<code>geoarrow.rust.core</code>","text":"<p>Root for <code>geoarrow.rust.core</code> API docs.</p> <p>All functionality described within this directory are part of the <code>geoarrow.rust.core</code> submodule. To use, install the <code>geoarrow-rust-core</code> PyPI package:</p> <pre><code>pip install geoarrow-rust-core\n</code></pre>"},{"location":"api/core/enums/","title":"Enums","text":""},{"location":"api/core/enums/#geoarrow.rust.core.enums","title":"geoarrow.rust.core.enums","text":""},{"location":"api/core/enums/#geoarrow.rust.core.enums.AreaMethod","title":"AreaMethod","text":"<p>             Bases: <code>StrEnum</code></p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.AreaMethod.Ellipsoidal","title":"Ellipsoidal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ellipsoidal = auto()\n</code></pre> <p>Use an ellipsoidal model of the Earth for area calculations.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.AreaMethod.Ellipsoidal--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction for the exterior   ring and a clockwise direction for interior rings. This is the standard winding   for geometries that follow the Simple Feature standard. Alternative windings may   result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect   to be dealing with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.AreaMethod.Ellipsoidal--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.AreaMethod.Ellipsoidal--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things:</p> <ol> <li>The winding of the polygon is in the clockwise direction (reverse winding). If    this is the case, and you know the polygon is smaller than half the area of    earth, you can take the absolute value of the reported area to get the correct    area.</li> <li>The polygon is larger than half the planet. In this case, the returned area of    the polygon is not correct. If you expect to be dealing with very large polygons,    please use the <code>unsigned</code> methods.</li> </ol>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.AreaMethod.Euclidean","title":"Euclidean  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Euclidean = auto()\n</code></pre> <p>Calculate planar area.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.AreaMethod.Spherical","title":"Spherical  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Spherical = auto()\n</code></pre> <p>Use a spherical model of the Earth for area calculations.</p> <p>Calculate the geodesic area of a geometry on a sphere using the algorithm presented in Some Algorithms for Polygons on a Sphere by Chamberlain and Duquette (2007).</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.AreaMethod.Spherical--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.LengthMethod","title":"LengthMethod","text":"<p>             Bases: <code>StrEnum</code></p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.LengthMethod.Ellipsoidal","title":"Ellipsoidal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ellipsoidal = auto()\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.LengthMethod.Euclidean","title":"Euclidean  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Euclidean = auto()\n</code></pre> <p>Determine the length of a geometry using planar calculations.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.LengthMethod.Haversine","title":"Haversine  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Haversine = auto()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.LengthMethod.Vincenty","title":"Vincenty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Vincenty = auto()\n</code></pre> <p>Determine the length of a geometry using Vincenty's formulae.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.SimplifyMethod","title":"SimplifyMethod","text":"<p>             Bases: <code>StrEnum</code></p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.SimplifyMethod.RDP","title":"RDP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RDP = auto()\n</code></pre> <p>Use the Ramer-Douglas-Peucker algorithm for LineString simplificatino.</p> <p>Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.SimplifyMethod.VW","title":"VW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VW = auto()\n</code></pre> <p>Use the Visvalingam-Whyatt algorithm for LineString simplification.</p> <p>See here for a graphical explanation Polygons are simplified by running the algorithm on all their constituent rings.</p> <p>This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.SimplifyMethod.VW_Preserve","title":"VW_Preserve  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VW_Preserve = auto()\n</code></pre> <p>Use a topology-preserving variant of the Visvalingam-Whyatt algorithm for LineString simplification.</p> <p>See here for a graphical explanation.</p> <p>The topology-preserving algorithm uses an R* tree to efficiently find candidate line segments which are tested for intersection with a given triangle. If intersections are found, the previous point (i.e. the left component of the current triangle) is also removed, altering the geometry and removing the intersection.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.SimplifyMethod.VW_Preserve--notes","title":"Notes","text":"<ul> <li>It is possible for the simplification algorithm to displace a Polygon's interior   ring outside its shell.</li> <li>The algorithm does not guarantee a valid output geometry, especially on   smaller geometries.</li> <li>If removal of a point causes a self-intersection, but the geometry only has <code>n +   1</code> points remaining (3 for a <code>LineString</code>, 5 for a <code>Polygon</code>), the point is   retained and the simplification process ends. This is because there is no   guarantee that removal of two points will remove the intersection, but removal of   further points would leave too few points to form a valid geometry.</li> <li>The tolerance used to remove a point is <code>epsilon</code>, in keeping with GEOS. JTS uses   <code>epsilon ^ 2</code></li> </ul>"},{"location":"api/core/functions/","title":"Top-level functions","text":""},{"location":"api/core/functions/#arraychunked-array-functions","title":"Array/Chunked Array functions","text":""},{"location":"api/core/functions/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/functions/#geoarrow.rust.core.affine_transform","title":"affine_transform  <code>builtin</code>","text":"<pre><code>affine_transform(input: AffineInputT | ArrowArrayExportable | ArrowStreamExportable, transform: AffineTransform) -&gt; AffineInputT | NativeGeometryArrayT | NativeChunkedGeometryArrayT\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>AffineInputT | ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AffineInputT | NativeGeometryArrayT | NativeChunkedGeometryArrayT</code>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with transformed</p> </li> <li> <code>AffineInputT | NativeGeometryArrayT | NativeChunkedGeometryArrayT</code>         \u2013          <p>coordinates.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.area","title":"area  <code>builtin</code>","text":"<pre><code>area(input: ArrowArrayExportable | ArrowStreamExportable, *, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array | ChunkedFloat64Array\n</code></pre> <p>Determine the area of an array of geometries</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>)         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array | ChunkedFloat64Array</code>         \u2013          <p>Array or chunked array with area values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.center","title":"center  <code>builtin</code>","text":"<pre><code>center(input: ArrowArrayExportable | ArrowStreamExportable) -&gt; PointArray | ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | ChunkedPointArray</code>         \u2013          <p>Array or chunked array with center values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.centroid","title":"centroid  <code>builtin</code>","text":"<pre><code>centroid(input: ArrowArrayExportable | ArrowStreamExportable) -&gt; PointArray | ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | ChunkedPointArray</code>         \u2013          <p>Array or chunked array with centroid values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.chaikin_smoothing","title":"chaikin_smoothing  <code>builtin</code>","text":"<pre><code>chaikin_smoothing(input: ChaikinSmoothingT | ArrowArrayExportable | ArrowStreamExportable, n_iterations: int) -&gt; LineStringArray | PolygonArray | MultiLineStringArray | MultiPolygonArray | ChunkedLineStringArray | ChunkedPolygonArray | ChunkedMultiLineStringArray | ChunkedMultiPolygonArray\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ChaikinSmoothingT | ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LineStringArray | PolygonArray | MultiLineStringArray | MultiPolygonArray | ChunkedLineStringArray | ChunkedPolygonArray | ChunkedMultiLineStringArray | ChunkedMultiPolygonArray</code>         \u2013          <p>Smoothed geometry array or chunked geometry array.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.convex_hull","title":"convex_hull  <code>builtin</code>","text":"<pre><code>convex_hull(input: ArrowArrayExportable | ArrowStreamExportable) -&gt; PolygonArray | ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PolygonArray | ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.densify","title":"densify  <code>builtin</code>","text":"<pre><code>densify(input: ArrowArrayExportable, max_distance: float) -&gt; LineStringArray | PolygonArray | MultiLineStringArray | MultiPolygonArray\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LineStringArray | PolygonArray | MultiLineStringArray | MultiPolygonArray</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.envelope","title":"envelope  <code>builtin</code>","text":"<pre><code>envelope(input: ArrowArrayExportable | ArrowStreamExportable) -&gt; RectArray | ChunkedRectArray\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RectArray | ChunkedRectArray</code>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.frechet_distance","title":"frechet_distance  <code>builtin</code>","text":"<pre><code>frechet_distance(input: ArrowArrayExportable | ArrowStreamExportable, other: BroadcastGeometry) -&gt; Float64Array | ChunkedFloat64Array\n</code></pre> <p>Determine the similarity between two arrays of <code>LineStrings</code> using the Frechet distance.</p> <p>The Fr\u00e9chet distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter \u2018densify\u2019 makes this approximation less coarse by splitting the line segments between vertices before computing the distance.</p> <p>Fr\u00e9chet distance sweep continuously along their respective curves and the direction of curves is significant. This makes it a better measure of similarity than Hausdorff distance for curve or surface matching.</p> <p>This implementation is based on Computing Discrete Frechet Distance by T. Eiter and H. Mannila.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> <li> <code>other</code>             (<code>BroadcastGeometry</code>)         \u2013          <p>the geometry or geometry array to compare against. This must contain geometries of `LineString`` type. A variety of inputs are accepted:</p> <ul> <li>A scalar <code>LineString</code></li> <li>A <code>LineStringArray</code></li> <li>A <code>ChunkedLineStringArray</code></li> <li>Any Python class that implements the Geo Interface, such as a <code>shapely</code> LineString</li> <li>Any GeoArrow array or chunked array of <code>LineString</code> type</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array | ChunkedFloat64Array</code>         \u2013          <p>Array or chunked array with float distance values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_perimeter","title":"geodesic_perimeter  <code>builtin</code>","text":"<pre><code>geodesic_perimeter(input: ArrowArrayExportable) -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/functions/#geoarrow.rust.core.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.is_empty","title":"is_empty  <code>builtin</code>","text":"<pre><code>is_empty(input: ArrowArrayExportable | ArrowStreamExportable) -&gt; BooleanArray | ChunkedBooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BooleanArray | ChunkedBooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.length","title":"length  <code>builtin</code>","text":"<pre><code>length(input: ArrowArrayExportable | ArrowStreamExportable, *, method: LengthMethod | LengthMethodT = 'euclidean') -&gt; Float64Array | ChunkedFloat64Array\n</code></pre> <p>Calculation of the length of a Line</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>LengthMethod | LengthMethodT</code>)         \u2013          <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array | ChunkedFloat64Array</code>         \u2013          <p>Array or chunked array with length values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.line_interpolate_point","title":"line_interpolate_point  <code>builtin</code>","text":"<pre><code>line_interpolate_point(input: ArrowArrayExportable | ArrowStreamExportable, fraction: float | int | ArrowArrayExportable | ArrowStreamExportable | NumpyArrayProtocolf64) -&gt; PointArray | ChunkedPointArray\n</code></pre> <p>Returns a point interpolated at given distance on a line.</p> <p>This is intended to be equivalent to <code>shapely.line_interpolate_point</code> when <code>normalized=True</code>.</p> <p>If the given fraction is  * less than zero (including negative infinity): returns the starting point  * greater than one (including infinity): returns the ending point  * If either the fraction is NaN, or any coordinates of the line are not    finite, returns <code>Point EMPTY</code>.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> <li> <code>fraction</code>             (<code>float | int | ArrowArrayExportable | ArrowStreamExportable | NumpyArrayProtocolf64</code>)         \u2013          <p>the fractional distance along the line. A variety of inputs are accepted:</p> <ul> <li>A Python <code>float</code> or <code>int</code></li> <li>A numpy <code>ndarray</code> with <code>float64</code> data type.</li> <li>An Arrow array or chunked array with <code>float64</code> data type.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | ChunkedPointArray</code>         \u2013          <p>PointArray or ChunkedPointArray with result values</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.line_locate_point","title":"line_locate_point  <code>builtin</code>","text":"<pre><code>line_locate_point(input: ArrowArrayExportable | ArrowStreamExportable, point: GeoInterfaceProtocol | ArrowArrayExportable | ArrowStreamExportable) -&gt; Float64Array | ChunkedFloat64Array\n</code></pre> <p>Returns a fraction of the line's total length representing the location of the closest point on the line to the given point.</p> <p>This is intended to be equivalent to <code>shapely.line_locate_point</code> when <code>normalized=True</code>.</p> <p>If the line has zero length the fraction returned is zero.</p> <p>If either the point's coordinates or any coordinates of the line are not finite, returns <code>NaN</code>.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> <li> <code>point</code>             (<code>GeoInterfaceProtocol | ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>the fractional distance along the line. A variety of inputs are accepted:</p> <ul> <li>A scalar <code>Point</code></li> <li>A <code>PointArray</code></li> <li>A <code>ChunkedPointArray</code></li> <li>Any Python class that implements the Geo Interface, such as a <code>shapely</code> Point</li> <li>Any GeoArrow array or chunked array of <code>Point</code> type</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array | ChunkedFloat64Array</code>         \u2013          <p>Array or chunked array with float fraction values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.polylabel","title":"polylabel  <code>builtin</code>","text":"<pre><code>polylabel(input: ArrowArrayExportable | ArrowStreamExportable, tolerance: float) -&gt; PointArray | ChunkedPointArray\n</code></pre> <p>Calculate a Polygon's ideal label position by calculating its pole of inaccessibility.</p> <p>The pole of inaccessibility is the most distant internal point from the polygon outline (not to be confused with centroid), and is useful for optimal placement of a text label on a polygon.</p> <p>The calculation uses an iterative grid-based algorithm, ported from the original JavaScript implementation.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> <li> <code>tolerance</code>             (<code>float</code>)         \u2013          <p>precision of algorithm. Refer to the original JavaScript  documentation  for more information</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | ChunkedPointArray</code>         \u2013          <p>PointArray or ChunkedPointArray with result values</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.signed_area","title":"signed_area  <code>builtin</code>","text":"<pre><code>signed_area(input: ArrowArrayExportable | ArrowStreamExportable, *, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array | ChunkedFloat64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>)         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array | ChunkedFloat64Array</code>         \u2013          <p>Array or chunked array with area values.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.simplify","title":"simplify  <code>builtin</code>","text":"<pre><code>simplify(input: SimplifyInputT | ArrowArrayExportable | ArrowStreamExportable, epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; SimplifyInputT | PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | ChunkedPointArray | ChunkedLineStringArray | ChunkedPolygonArray | ChunkedMultiPointArray | ChunkedMultiLineStringArray | ChunkedMultiPolygonArray\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>SimplifyInputT | ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array</p> </li> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SimplifyInputT | PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | ChunkedPointArray | ChunkedLineStringArray | ChunkedPolygonArray | ChunkedMultiPointArray | ChunkedMultiLineStringArray | ChunkedMultiPolygonArray</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.total_bounds","title":"total_bounds  <code>builtin</code>","text":"<pre><code>total_bounds(input: ArrowArrayExportable | ArrowStreamExportable) -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable | ArrowStreamExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/functions/#table-functions","title":"Table functions","text":""},{"location":"api/core/functions/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/functions/#geoarrow.rust.core.explode","title":"explode  <code>builtin</code>","text":"<pre><code>explode(input: ArrowStreamExportable) -&gt; GeoTable\n</code></pre> <p>Explode a table.</p> <p>This is intended to be equivalent to the <code>explode</code> function in GeoPandas.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowStreamExportable</code>)         \u2013          <p>input table</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>A new table with multi-part geometries exploded to separate rows.</p> </li> </ul>"},{"location":"api/core/interop/","title":"Interoperability","text":"<p>Interoperability with other in-memory Python</p>"},{"location":"api/core/interop/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/interop/#geoarrow.rust.core.from_ewkb","title":"from_ewkb  <code>builtin</code>","text":"<pre><code>from_ewkb(input: ArrowArrayExportable) -&gt; PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray\n</code></pre> <p>Parse an Arrow BinaryArray from EWKB to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding EWKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/interop/#geoarrow.rust.core.from_geopandas","title":"from_geopandas  <code>builtin</code>","text":"<pre><code>from_geopandas(input: gpd.GeoDataFrame) -&gt; GeoTable\n</code></pre> <p>Create a GeoArrow Table from a GeoPandas GeoDataFrame.</p>"},{"location":"api/core/interop/#geoarrow.rust.core.from_geopandas--notes","title":"Notes:","text":"<ul> <li>Currently this will always generate a non-chunked GeoArrow array. This is partly because   pyarrow.Table.from_pandas always creates a single batch.</li> <li>This requires <code>pyarrow</code> version 14 or later.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>GeoDataFrame</code>)         \u2013          <p>A GeoPandas GeoDataFrame.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>A GeoArrow Table</p> </li> </ul>"},{"location":"api/core/interop/#geoarrow.rust.core.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input) -&gt; PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray\n</code></pre> <p>Create a GeoArrow array from an array of Shapely geometries.</p>"},{"location":"api/core/interop/#geoarrow.rust.core.from_shapely--notes","title":"Notes:","text":"<ul> <li>Currently this will always generate a non-chunked GeoArrow array. Use the <code>from_shapely</code> method on a chunked GeoArrow array class to construct a chunked array.</li> <li>This will first call <code>to_ragged_array</code>, falling back to   <code>to_wkb</code> if necessary. If you know you have mixed-type geometries in your   column, use   <code>MixedGeometryArray.from_shapely</code>.</li> </ul> <p>This is because <code>to_ragged_array</code> is the fastest approach but fails on mixed-type geometries.   It supports combining Multi-* geometries with non-multi-geometries in the same array, so you   can combine e.g. Point and MultiPoint geometries in the same array, but <code>to_ragged_array</code>   doesn't work if you have Point and Polygon geometries in the same array.</p> <p>Args:</p> <p>input: Any array object accepted by Shapely, including numpy object arrays and   <code>geopandas.GeoSeries</code>.</p> <p>Returns:</p> <pre><code>A GeoArrow array\n</code></pre>"},{"location":"api/core/interop/#geoarrow.rust.core.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/interop/#geoarrow.rust.core.from_wkt","title":"from_wkt  <code>builtin</code>","text":"<pre><code>from_wkt(input: ArrowArrayExportable) -&gt; PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray\n</code></pre> <p>Parse an Arrow StringArray from WKT to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of string type holding WKT-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray | LineStringArray | PolygonArray | MultiPointArray | MultiLineStringArray | MultiPolygonArray | MixedGeometryArray | GeometryCollectionArray</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/interop/#geoarrow.rust.core.to_geopandas","title":"to_geopandas  <code>builtin</code>","text":"<pre><code>to_geopandas(input: ArrowStreamExportable) -&gt; gpd.GeoDataFrame\n</code></pre> <p>Convert a GeoArrow Table to a GeoPandas GeoDataFrame.</p>"},{"location":"api/core/interop/#geoarrow.rust.core.to_geopandas--notes","title":"Notes:","text":"<ul> <li>This requires <code>pyarrow</code> version 14 or later.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowStreamExportable</code>)         \u2013          <p>A GeoArrow Table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoDataFrame</code>         \u2013          <p>the converted GeoDataFrame</p> </li> </ul>"},{"location":"api/core/interop/#geoarrow.rust.core.to_shapely","title":"to_shapely  <code>builtin</code>","text":"<pre><code>to_shapely(input: ArrowArrayExportable) -&gt; NDArray[np.object_]\n</code></pre> <p>Convert a GeoArrow array to a numpy array of Shapely objects</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArray[object_]</code>         \u2013          <p>numpy array with Shapely objects</p> </li> </ul>"},{"location":"api/core/interop/#geoarrow.rust.core.to_wkb","title":"to_wkb  <code>builtin</code>","text":"<pre><code>to_wkb(input: ArrowArrayExportable) -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/io/","title":"I/O","text":"<p>Read and write to files on disk and databases like PostGIS.</p>"},{"location":"api/core/io/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/io/#geoarrow.rust.core.ObjectStore","title":"ObjectStore","text":"<pre><code>ObjectStore(root: str, options: Optional[Dict[str, str]] = None)\n</code></pre> <p>A generic object store interface for uniformly interacting with AWS S3, Google Cloud Storage, and Azure Blob Storage.</p> <p>To create, pass a bucket path plus authentication options into the constructor. Currently, authentication credentials are not found automatically.</p> <p>Examples:</p> <p>Reading from a FlatGeobuf file from an S3 bucket.</p> <pre><code>from geoarrow.rust.core import ObjectStore, read_flatgeobuf\n\noptions = {\n    \"aws_access_key_id\": \"...\",\n    \"aws_secret_access_key\": \"...\",\n    \"aws_region\": \"...\"\n}\nfs = ObjectStore('s3://bucket', options=options)\ntable = read_flatgeobuf(\"path/in/bucket.fgb\", fs=fs)\n</code></pre>"},{"location":"api/core/io/#geoarrow.rust.core.read_csv","title":"read_csv  <code>builtin</code>","text":"<pre><code>read_csv(file: str | Path | BinaryIO, geometry_column_name: str, *, batch_size: int = 65536) -&gt; GeoTable\n</code></pre> <p>Read a CSV file from a path on disk into a GeoTable.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>str | Path | BinaryIO</code>)         \u2013          <p>the path to the file or a Python file object in binary read mode.</p> </li> <li> <code>geometry_column_name</code>             (<code>str</code>)         \u2013          <p>the name of the geometry column within the CSV.</p> </li> <li> <code>batch_size</code>             (<code>int</code>, default:                 <code>65536</code> )         \u2013          <p>the number of rows to include in each internal batch of the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from CSV file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_flatgeobuf","title":"read_flatgeobuf  <code>builtin</code>","text":"<pre><code>read_flatgeobuf(file: Union[str, Path, BinaryIO], *, fs: Optional[ObjectStore] = None, batch_size: int = 65536, bbox: Tuple[float, float, float, float] | None = None) -&gt; GeoTable\n</code></pre> <p>Read a FlatGeobuf file from a path on disk or a remote location into a GeoTable.</p> <p>Example:</p> <p>Reading from a local path:</p> <pre><code>from geoarrow.rust.core import read_flatgeobuf\ntable = read_flatgeobuf(\"path/to/file.fgb\")\n</code></pre> <p>Reading from a Python file object:</p> <pre><code>from geoarrow.rust.core import read_flatgeobuf\n\nwith open(\"path/to/file.fgb\", \"rb\") as file:\n    table = read_flatgeobuf(file)\n</code></pre> <p>Reading from an HTTP(S) url:</p> <pre><code>from geoarrow.rust.core import read_flatgeobuf\n\nurl = \"http://flatgeobuf.org/test/data/UScounties.fgb\"\ntable = read_flatgeobuf(url)\n</code></pre> <p>Reading from a remote file on an S3 bucket.</p> <pre><code>from geoarrow.rust.core import ObjectStore, read_flatgeobuf\n\noptions = {\n    \"aws_access_key_id\": \"...\",\n    \"aws_secret_access_key\": \"...\",\n    \"aws_region\": \"...\"\n}\nfs = ObjectStore('s3://bucket', options=options)\ntable = read_flatgeobuf(\"path/in/bucket.fgb\", fs=fs)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>Union[str, Path, BinaryIO]</code>)         \u2013          <p>the path to the file or a Python file object in binary read mode.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>fs</code>             (<code>Optional[ObjectStore]</code>)         \u2013          <p>an ObjectStore instance for this url. This is required only if the file is at a remote location.</p> </li> <li> <code>batch_size</code>             (<code>int</code>)         \u2013          <p>the number of rows to include in each internal batch of the table.</p> </li> <li> <code>bbox</code>             (<code>Tuple[float, float, float, float] | None</code>)         \u2013          <p>A spatial filter for reading rows, of the format (minx, miny, maxx, maxy). If set to <code>None</code>, no spatial filtering will be performed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from FlatGeobuf file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_flatgeobuf_async","title":"read_flatgeobuf_async  <code>builtin</code>","text":"<pre><code>read_flatgeobuf_async(path: str, *, fs: Optional[ObjectStore] = None, batch_size: int = 65536, bbox: Tuple[float, float, float, float] | None = None) -&gt; GeoTable\n</code></pre> <p>Read a FlatGeobuf file from a url into a GeoTable.</p> <p>Example:</p> <p>Reading from an HTTP(S) url:</p> <pre><code>from geoarrow.rust.core import read_flatgeobuf_async\n\nurl = \"http://flatgeobuf.org/test/data/UScounties.fgb\"\ntable = await read_flatgeobuf_async(url)\n</code></pre> <p>Reading from an S3 bucket:</p> <pre><code>from geoarrow.rust.core import ObjectStore, read_flatgeobuf_async\n\noptions = {\n    \"aws_access_key_id\": \"...\",\n    \"aws_secret_access_key\": \"...\",\n    \"aws_region\": \"...\"\n}\nfs = ObjectStore('s3://bucket', options=options)\ntable = await read_flatgeobuf_async(\"path/in/bucket.fgb\", fs=fs)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>the url or relative path to a remote FlatGeobuf file. If an argument is passed for <code>fs</code>, this should be a path fragment relative to the root passed to the <code>ObjectStore</code> constructor.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>fs</code>             (<code>Optional[ObjectStore]</code>)         \u2013          <p>an ObjectStore instance for this url. This is required for non-HTTP urls.</p> </li> <li> <code>batch_size</code>             (<code>int</code>)         \u2013          <p>the number of rows to include in each internal batch of the table.</p> </li> <li> <code>bbox</code>             (<code>Tuple[float, float, float, float] | None</code>)         \u2013          <p>A spatial filter for reading rows, of the format (minx, miny, maxx, maxy). If set to <code>None</code>, no spatial filtering will be performed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from FlatGeobuf file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_geojson","title":"read_geojson  <code>builtin</code>","text":"<pre><code>read_geojson(file: Union[str, Path, BinaryIO], *, batch_size: int = 65536) -&gt; GeoTable\n</code></pre> <p>Read a GeoJSON file from a path on disk into a GeoTable.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>Union[str, Path, BinaryIO]</code>)         \u2013          <p>the path to the file or a Python file object in binary read mode.</p> </li> <li> <code>batch_size</code>             (<code>int</code>, default:                 <code>65536</code> )         \u2013          <p>the number of rows to include in each internal batch of the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from GeoJSON file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_geojson_lines","title":"read_geojson_lines  <code>builtin</code>","text":"<pre><code>read_geojson_lines(file: Union[str, Path, BinaryIO], *, batch_size: int = 65536) -&gt; GeoTable\n</code></pre> <p>Read a newline-delimited GeoJSON file from a path on disk into a GeoTable.</p> <p>This expects a GeoJSON Feature on each line of a text file, with a newline character separating each Feature.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>Union[str, Path, BinaryIO]</code>)         \u2013          <p>the path to the file or a Python file object in binary read mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from GeoJSON file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_ipc","title":"read_ipc  <code>builtin</code>","text":"<pre><code>read_ipc(file: Union[str, Path, BinaryIO]) -&gt; GeoTable\n</code></pre> <p>Read into a Table from Arrow IPC (Feather v2) file.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>Union[str, Path, BinaryIO]</code>)         \u2013          <p>the path to the file or a Python file object in binary read mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from Arrow IPC file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_ipc_stream","title":"read_ipc_stream  <code>builtin</code>","text":"<pre><code>read_ipc_stream(file: Union[str, Path, BinaryIO]) -&gt; GeoTable\n</code></pre> <p>Read into a Table from Arrow IPC record batch stream.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>Union[str, Path, BinaryIO]</code>)         \u2013          <p>the path to the file or a Python file object in binary read mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from Arrow IPC file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_parquet","title":"read_parquet  <code>builtin</code>","text":"<pre><code>read_parquet(path: str, *, fs: Optional[ObjectStore] = None, batch_size: int = 65536) -&gt; GeoTable\n</code></pre> <p>Read a GeoParquet file from a path on disk into a GeoTable.</p> <p>Example:</p> <p>Reading from a local path:</p> <pre><code>from geoarrow.rust.core import read_parquet\ntable = read_parquet(\"path/to/file.parquet\")\n</code></pre> <p>Reading from an HTTP(S) url:</p> <pre><code>from geoarrow.rust.core import read_parquet\n\nurl = \"https://raw.githubusercontent.com/opengeospatial/geoparquet/v1.0.0/examples/example.parquet\"\ntable = read_parquet(url)\n</code></pre> <p>Reading from a remote file on an S3 bucket.</p> <pre><code>from geoarrow.rust.core import ObjectStore, read_parquet\n\noptions = {\n    \"aws_access_key_id\": \"...\",\n    \"aws_secret_access_key\": \"...\",\n    \"aws_region\": \"...\"\n}\nfs = ObjectStore('s3://bucket', options=options)\ntable = read_parquet(\"path/in/bucket.parquet\", fs=fs)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>the path to the file</p> </li> <li> <code>batch_size</code>             (<code>int</code>, default:                 <code>65536</code> )         \u2013          <p>the number of rows to include in each internal batch of the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from GeoParquet file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_parquet_async","title":"read_parquet_async  <code>builtin</code>","text":"<pre><code>read_parquet_async(path: str, *, fs: Optional[ObjectStore] = None, batch_size: int = 65536) -&gt; GeoTable\n</code></pre> <p>Read a GeoParquet file from a path on disk into a GeoTable.</p> <p>Examples:</p> <p>Reading from an HTTP(S) url:</p> <pre><code>from geoarrow.rust.core import read_parquet_async\n\nurl = \"https://raw.githubusercontent.com/opengeospatial/geoparquet/v1.0.0/examples/example.parquet\"\ntable = await read_parquet_async(url)\n</code></pre> <p>Reading from a remote file on an S3 bucket.</p> <pre><code>from geoarrow.rust.core import ObjectStore, read_parquet_async\n\noptions = {\n    \"aws_access_key_id\": \"...\",\n    \"aws_secret_access_key\": \"...\",\n    \"aws_region\": \"...\"\n}\nfs = ObjectStore('s3://bucket', options=options)\ntable = await read_parquet_async(\"path/in/bucket.parquet\", fs=fs)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>path</code>             (<code>str</code>)         \u2013          <p>the path to the file</p> </li> <li> <code>batch_size</code>             (<code>int</code>, default:                 <code>65536</code> )         \u2013          <p>the number of rows to include in each internal batch of the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table from GeoParquet file.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_postgis","title":"read_postgis  <code>builtin</code>","text":"<pre><code>read_postgis(connection_url: str, sql: str) -&gt; Optional[GeoTable]\n</code></pre> <p>Read a PostGIS query into a GeoTable.</p> <p>Returns:</p> <ul> <li> <code>Optional[GeoTable]</code>         \u2013          <p>Table from query.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_postgis_async","title":"read_postgis_async  <code>builtin</code>","text":"<pre><code>read_postgis_async(connection_url: str, sql: str) -&gt; Optional[GeoTable]\n</code></pre> <p>Read a PostGIS query into a GeoTable.</p> <p>Returns:</p> <ul> <li> <code>Optional[GeoTable]</code>         \u2013          <p>Table from query.</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.read_pyogrio","title":"read_pyogrio  <code>builtin</code>","text":"<pre><code>read_pyogrio(path_or_buffer: Path | str | bytes, /, layer: int | str | None = None, encoding: str | None = None, columns: Sequence[str] | None = None, read_geometry: bool = True, skip_features: int = 0, max_features: int | None = None, where: str | None = Ellipsis, bbox: Tuple[float, float, float, float] | Sequence[float] | None = None, mask=None, fids=None, sql: str | None = None, sql_dialect: str | None = None, return_fids=False, batch_size=65536, **kwargs) -&gt; GeoTable\n</code></pre> <p>Read from an OGR data source to a GeoTable</p> <p>Parameters:</p> <ul> <li> <code>path_or_buffer</code>             (<code>Path | str | bytes</code>)         \u2013          <p>A dataset path or URI, or raw buffer.</p> </li> <li> <code>layer</code>             (<code>int | str | None</code>, default:                 <code>None</code> )         \u2013          <p>If an integer is provided, it corresponds to the index of the layer with the data source. If a string is provided, it must match the name of the layer in the data source. Defaults to first layer in data source.</p> </li> <li> <code>encoding</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>If present, will be used as the encoding for reading string values from the data source, unless encoding can be inferred directly from the data source.</p> </li> <li> <code>columns</code>             (<code>Sequence[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>List of column names to import from the data source. Column names must exactly match the names in the data source, and will be returned in the order they occur in the data source. To avoid reading any columns, pass an empty list-like.</p> </li> <li> <code>read_geometry</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If True, will read geometry into a GeoSeries. If False, a Pandas DataFrame will be returned instead. Default: <code>True</code>.</p> </li> <li> <code>skip_features</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Number of features to skip from the beginning of the file before returning features. If greater than available number of features, an empty DataFrame will be returned. Using this parameter may incur significant overhead if the driver does not support the capability to randomly seek to a specific feature, because it will need to iterate over all prior features.</p> </li> <li> <code>max_features</code>             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Number of features to read from the file. Default: <code>None</code>.</p> </li> <li> <code>where</code>             (<code>str | None</code>, default:                 <code>Ellipsis</code> )         \u2013          <p>Where clause to filter features in layer by attribute values. If the data source natively supports SQL, its specific SQL dialect should be used (eg. SQLite and GeoPackage: <code>SQLITE</code>, PostgreSQL). If it doesn't, the <code>OGRSQL WHERE</code> syntax should be used. Note that it is not possible to overrule the SQL dialect, this is only possible when you use the <code>sql</code> parameter.</p> <p>Examples: <code>\"ISO_A3 = 'CAN'\"</code>, <code>\"POP_EST &gt; 10000000 AND POP_EST &lt; 100000000\"</code></p> </li> <li> <code>bbox</code>             (<code>Tuple[float, float, float, float] | Sequence[float] | None</code>, default:                 <code>None</code> )         \u2013          <p>If present, will be used to filter records whose geometry intersects this box. This must be in the same CRS as the dataset. If GEOS is present and used by GDAL, only geometries that intersect this bbox will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect this bbox will be returned. Cannot be combined with <code>mask</code> keyword.</p> </li> <li> <code>mask</code>         \u2013          <p>Shapely geometry, optional (default: <code>None</code>) If present, will be used to filter records whose geometry intersects this geometry. This must be in the same CRS as the dataset. If GEOS is present and used by GDAL, only geometries that intersect this geometry will be returned; if GEOS is not available or not used by GDAL, all geometries with bounding boxes that intersect the bounding box of this geometry will be returned. Requires Shapely &gt;= 2.0. Cannot be combined with <code>bbox</code> keyword.</p> </li> <li> <code>fids</code>         \u2013          <p>array-like, optional (default: <code>None</code>) Array of integer feature id (FID) values to select. Cannot be combined with other keywords to select a subset (<code>skip_features</code>, <code>max_features</code>, <code>where</code>, <code>bbox</code>, <code>mask</code>, or <code>sql</code>). Note that the starting index is driver and file specific (e.g. typically 0 for Shapefile and 1 for GeoPackage, but can still depend on the specific file). The performance of reading a large number of features usings FIDs is also driver specific.</p> </li> <li> <code>sql</code>             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The SQL statement to execute. Look at the sql_dialect parameter for more information on the syntax to use for the query. When combined with other keywords like <code>columns</code>, <code>skip_features</code>, <code>max_features</code>, <code>where</code>, <code>bbox</code>, or <code>mask</code>, those are applied after the SQL query. Be aware that this can have an impact on performance, (e.g. filtering with the <code>bbox</code> or <code>mask</code> keywords may not use spatial indexes). Cannot be combined with the <code>layer</code> or <code>fids</code> keywords.</p> </li> <li> <code>sql_dialect</code>         \u2013          <p>str, optional (default: <code>None</code>) The SQL dialect the SQL statement is written in. Possible values:</p> <ul> <li>None: if the data source natively supports SQL, its specific SQL dialect     will be used by default (eg. SQLite and Geopackage: <code>SQLITE</code>, PostgreSQL).     If the data source doesn't natively support SQL, the <code>OGRSQL</code> dialect is     the default.</li> <li><code>'OGRSQL'</code>: can be used on any data source. Performance can suffer     when used on data sources with native support for SQL.</li> <li><code>'SQLITE'</code>: can be used on any data source. All spatialite     functions can be used. Performance can suffer on data sources with     native support for SQL, except for Geopackage and SQLite as this is     their native SQL dialect.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoTable</code>         \u2013          <p>Table</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.write_csv","title":"write_csv  <code>builtin</code>","text":"<pre><code>write_csv(table: ArrowStreamExportable, file: str | Path | BinaryIO) -&gt; None\n</code></pre> <p>Write a GeoTable to a CSV file on disk.</p> <p>Parameters:</p> <ul> <li> <code>table</code>             (<code>ArrowStreamExportable</code>)         \u2013          <p>the table to write.</p> </li> <li> <code>file</code>             (<code>str | Path | BinaryIO</code>)         \u2013          <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.write_flatgeobuf","title":"write_flatgeobuf  <code>builtin</code>","text":"<pre><code>write_flatgeobuf(table: ArrowStreamExportable, file: str | Path | BinaryIO, *, write_index: bool = True) -&gt; None\n</code></pre> <p>Write a GeoTable to a FlatGeobuf file on disk.</p> <p>Parameters:</p> <ul> <li> <code>table</code>             (<code>ArrowStreamExportable</code>)         \u2013          <p>the table to write.</p> </li> <li> <code>file</code>             (<code>str | Path | BinaryIO</code>)         \u2013          <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.write_geojson","title":"write_geojson  <code>builtin</code>","text":"<pre><code>write_geojson(table: ArrowStreamExportable, file: Union[str, Path, BinaryIO]) -&gt; None\n</code></pre> <p>Write a GeoTable to a GeoJSON file on disk.</p> <p>Note that the GeoJSON specification mandates coordinates to be in the WGS84 (EPSG:4326) coordinate system, but this function will not automatically reproject into WGS84 for you.</p> <p>Parameters:</p> <ul> <li> <code>table</code>             (<code>ArrowStreamExportable</code>)         \u2013          <p>the table to write.</p> </li> <li> <code>file</code>             (<code>Union[str, Path, BinaryIO]</code>)         \u2013          <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.write_geojson_lines","title":"write_geojson_lines  <code>builtin</code>","text":"<pre><code>write_geojson_lines(table: ArrowStreamExportable, file: Union[str, Path, BinaryIO]) -&gt; None\n</code></pre> <p>Write a GeoTable to a newline-delimited GeoJSON file on disk.</p> <p>Note that the GeoJSON specification mandates coordinates to be in the WGS84 (EPSG:4326) coordinate system, but this function will not automatically reproject into WGS84 for you.</p> <p>Parameters:</p> <ul> <li> <code>table</code>             (<code>ArrowStreamExportable</code>)         \u2013          <p>the table to write.</p> </li> <li> <code>file</code>             (<code>Union[str, Path, BinaryIO]</code>)         \u2013          <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.write_ipc","title":"write_ipc  <code>builtin</code>","text":"<pre><code>write_ipc(table: ArrowStreamExportable, file: Union[str, Path, BinaryIO]) -&gt; None\n</code></pre> <p>Write a GeoTable to an Arrow IPC (Feather v2) file on disk.</p> <p>Parameters:</p> <ul> <li> <code>table</code>             (<code>ArrowStreamExportable</code>)         \u2013          <p>the table to write.</p> </li> <li> <code>file</code>             (<code>Union[str, Path, BinaryIO]</code>)         \u2013          <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.write_ipc_stream","title":"write_ipc_stream  <code>builtin</code>","text":"<pre><code>write_ipc_stream(table: ArrowStreamExportable, file: Union[str, Path, BinaryIO]) -&gt; None\n</code></pre> <p>Write a GeoTable to an Arrow IPC stream</p> <p>Parameters:</p> <ul> <li> <code>table</code>             (<code>ArrowStreamExportable</code>)         \u2013          <p>the table to write.</p> </li> <li> <code>file</code>             (<code>Union[str, Path, BinaryIO]</code>)         \u2013          <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul>"},{"location":"api/core/io/#geoarrow.rust.core.write_parquet","title":"write_parquet  <code>builtin</code>","text":"<pre><code>write_parquet(table: ArrowStreamExportable, file: str) -&gt; None\n</code></pre> <p>Write a GeoTable to a GeoParquet file on disk.</p> <p>Parameters:</p> <ul> <li> <code>table</code>             (<code>ArrowStreamExportable</code>)         \u2013          <p>the table to write.</p> </li> <li> <code>file</code>             (<code>str</code>)         \u2013          <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None</p> </li> </ul>"},{"location":"api/core/table/","title":"GeoTable","text":""},{"location":"api/core/table/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/table/#geoarrow.rust.core.GeoTable","title":"GeoTable","text":"<p>A spatially-enabled table.</p> <p>This is a table, or <code>DataFrame</code>, consisting of named columns with the same length. One of these columns contains a chunked geometry array.</p> <p>This is similar to a GeoPandas <code>GeoDataFrame</code>.</p>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.geometry","title":"geometry","text":"<pre><code>geometry: ChunkedPointArray | ChunkedLineStringArray | ChunkedPolygonArray | ChunkedMultiPointArray | ChunkedMultiLineStringArray | ChunkedMultiPolygonArray | ChunkedMixedGeometryArray | ChunkedGeometryCollectionArray = &lt;attribute 'geometry' of 'geoarrow.rust.core._rust.GeoTable' objects&gt;\n</code></pre> <p>Access the geometry column of this table</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray | ChunkedLineStringArray | ChunkedPolygonArray | ChunkedMultiPointArray | ChunkedMultiLineStringArray | ChunkedMultiPolygonArray | ChunkedMixedGeometryArray | ChunkedGeometryCollectionArray</code>         \u2013          <p>A chunked geometry array</p> </li> </ul>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.num_columns","title":"num_columns","text":"<pre><code>num_columns: int = &lt;attribute 'num_columns' of 'geoarrow.rust.core._rust.GeoTable' objects&gt;\n</code></pre> <p>Number of columns in this table.</p>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(_requested_schema=None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.table()</code> to convert this array into a pyarrow table, without copying memory.</p>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.explode","title":"explode  <code>method descriptor</code>","text":"<pre><code>explode() -&gt; Self\n</code></pre> <p>Explode a table.</p> <p>This is intended to be equivalent to the <code>explode</code> function in GeoPandas.</p> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A new table with multi-part geometries exploded to separate rows.</p> </li> </ul>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(input: ArrowStreamExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowStreamExportable</code>)         \u2013          <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.from_geopandas","title":"from_geopandas  <code>builtin</code>","text":"<pre><code>from_geopandas(input: gpd.GeoDataFrame) -&gt; Self\n</code></pre> <p>Create a GeoArrow Table from a GeoPandas GeoDataFrame.</p>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.from_geopandas--notes","title":"Notes:","text":"<ul> <li>Currently this will always generate a non-chunked GeoArrow array. This is partly because   pyarrow.Table.from_pandas always creates a single batch.</li> <li>This requires <code>pyarrow</code> version 14 or later.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>GeoDataFrame</code>)         \u2013          <p>A GeoPandas GeoDataFrame.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow Table</p> </li> </ul>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.to_geopandas","title":"to_geopandas  <code>method descriptor</code>","text":"<pre><code>to_geopandas() -&gt; gpd.GeoDataFrame\n</code></pre> <p>Convert this GeoArrow Table to a GeoPandas GeoDataFrame.</p>"},{"location":"api/core/table/#geoarrow.rust.core.GeoTable.to_geopandas--notes","title":"Notes:","text":"<ul> <li>This requires <code>pyarrow</code> version 14 or later.</li> </ul> <p>Returns:</p> <ul> <li> <code>GeoDataFrame</code>         \u2013          <p>the converted GeoDataFrame</p> </li> </ul>"},{"location":"api/core/types/","title":"Types","text":""},{"location":"api/core/types/#geoarrow.rust.core.types","title":"geoarrow.rust.core.types","text":""},{"location":"api/core/types/#geoarrow.rust.core.types.AffineInputT","title":"AffineInputT  <code>module-attribute</code>","text":"<pre><code>AffineInputT = TypeVar('AffineInputT', PointArray, LineStringArray, PolygonArray, MultiPointArray, MultiLineStringArray, MultiPolygonArray, MixedGeometryArray, GeometryCollectionArray, ChunkedPointArray, ChunkedMultiPointArray, ChunkedLineStringArray, ChunkedPolygonArray, ChunkedMultiPointArray, ChunkedMultiLineStringArray, ChunkedMultiPolygonArray, ChunkedMixedGeometryArray, ChunkedGeometryCollectionArray)\n</code></pre> <p>Known geoarrow-rust types for input into <code>affine_transform</code>.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.AreaMethodT","title":"AreaMethodT  <code>module-attribute</code>","text":"<pre><code>AreaMethodT = Literal['ellipsoidal', 'euclidean', 'spherical']\n</code></pre> <p>Acceptable strings to be passed into the <code>method</code> parameter for <code>area</code> and <code>signed_area</code>.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.LengthMethodT","title":"LengthMethodT  <code>module-attribute</code>","text":"<pre><code>LengthMethodT = Literal['ellipsoidal', 'euclidean', 'haversine', 'vincenty']\n</code></pre> <p>Acceptable strings to be passed into the <code>method</code> parameter for <code>length</code>.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.SimplifyInputT","title":"SimplifyInputT  <code>module-attribute</code>","text":"<pre><code>SimplifyInputT = TypeVar('SimplifyInputT', PointArray, LineStringArray, PolygonArray, MultiPointArray, MultiLineStringArray, MultiPolygonArray, ChunkedMultiPointArray, ChunkedLineStringArray, ChunkedPolygonArray, ChunkedMultiPointArray, ChunkedMultiLineStringArray, ChunkedMultiPolygonArray)\n</code></pre> <p>Known geoarrow-rust types for input into <code>simplify</code>.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.SimplifyMethodT","title":"SimplifyMethodT  <code>module-attribute</code>","text":"<pre><code>SimplifyMethodT = Literal['rdp', 'vw', 'vw_preserve']\n</code></pre> <p>Acceptable strings to be passed into the <code>method</code> parameter for <code>simplify</code>.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.ArrowArrayExportable","title":"ArrowArrayExportable","text":"<p>             Bases: <code>Protocol</code></p> <p>An Arrow or GeoArrow array from an Arrow producer (e.g. geoarrow.c or pyarrow).</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.ArrowStreamExportable","title":"ArrowStreamExportable","text":"<p>             Bases: <code>Protocol</code></p> <p>An Arrow or GeoArrow ChunkedArray or Table from an Arrow producer (e.g. geoarrow.c or pyarrow).</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.GeoInterfaceProtocol","title":"GeoInterfaceProtocol","text":"<p>             Bases: <code>Protocol</code></p> <p>A scalar geometry that implements the Geo Interface protocol.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.NumpyArrayProtocolf64","title":"NumpyArrayProtocolf64","text":"<p>             Bases: <code>Protocol</code></p> <p>A scalar geometry that implements the Geo Interface protocol.</p>"},{"location":"api/core/geometry/array/","title":"Geometry Arrays","text":"<p>The classes on this page represent arrays of geospatial geometries.</p> <ul> <li><code>PointArray</code></li> <li><code>LineStringArray</code></li> <li><code>PolygonArray</code></li> <li><code>MultiPointArray</code></li> <li><code>MultiLineStringArray</code></li> <li><code>MultiPolygonArray</code></li> <li><code>MixedGeometryArray</code></li> <li><code>GeometryCollectionArray</code></li> <li><code>WKBArray</code></li> <li><code>RectArray</code></li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray","title":"PointArray","text":"<p>An immutable array of Point geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.PointArray' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; Point\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by <code>shapely.to_ragged_array</code>, including numpy object arrays and   <code>geopandas.GeoSeries</code></p> <p>Returns:</p> <pre><code>A new array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.from_xy","title":"from_xy  <code>builtin</code>","text":"<pre><code>from_xy(x: ArrowArrayExportable | NumpyArrayProtocolf64, y: ArrowArrayExportable | NumpyArrayProtocolf64) -&gt; Self\n</code></pre> <p>Construct a PointArray from arrays of x and y values</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length(*, method: LengthMethod | LengthMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Calculation of the length of a Line</p> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>LengthMethod | LengthMethodT</code>)         \u2013          <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with length values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PointArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray","title":"LineStringArray","text":"<p>An immutable array of LineString geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.LineStringArray' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; LineString\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.frechet_distance","title":"frechet_distance  <code>method descriptor</code>","text":"<pre><code>frechet_distance(other: BroadcastGeometry) -&gt; Float64Array\n</code></pre> <p>Determine the similarity between two arrays of <code>LineStrings</code> using the Frechet distance.</p> <p>The Fr\u00e9chet distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter \u2018densify\u2019 makes this approximation less coarse by splitting the line segments between vertices before computing the distance.</p> <p>Fr\u00e9chet distance sweep continuously along their respective curves and the direction of curves is significant. This makes it a better measure of similarity than Hausdorff distance for curve or surface matching.</p> <p>This implementation is based on Computing Discrete Frechet Distance by T. Eiter and H. Mannila.</p> <p>Parameters:</p> <ul> <li> <code>other</code>             (<code>BroadcastGeometry</code>)         \u2013          <p>the geometry or geometry array to compare against. This must contain geometries of `LineString`` type. A variety of inputs are accepted:</p> <ul> <li>A scalar <code>LineString</code></li> <li>A <code>LineStringArray</code></li> <li>A <code>ChunkedLineStringArray</code></li> <li>Any Python class that implements the Geo Interface, such as a <code>shapely</code> LineString</li> <li>Any GeoArrow array or chunked array of <code>LineString</code> type</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with float distance values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by <code>shapely.to_ragged_array</code>, including numpy object arrays and   <code>geopandas.GeoSeries</code></p> <p>Returns:</p> <pre><code>A new array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length(*, method: LengthMethod | LengthMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Calculation of the length of a Line</p> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>LengthMethod | LengthMethodT</code>)         \u2013          <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with length values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.line_interpolate_point","title":"line_interpolate_point  <code>method descriptor</code>","text":"<pre><code>line_interpolate_point(fraction: float | int | ArrowArrayExportable | NumpyArrayProtocolf64) -&gt; PointArray\n</code></pre> <p>Returns a point interpolated at given distance on a line.</p> <p>This is intended to be equivalent to <code>shapely.line_interpolate_point</code> when <code>normalized=True</code>.</p> <p>If the given fraction is  * less than zero (including negative infinity): returns the starting point  * greater than one (including infinity): returns the ending point  * If either the fraction is NaN, or any coordinates of the line are not    finite, returns <code>Point EMPTY</code>.</p> <p>Parameters:</p> <ul> <li> <code>input</code>         \u2013          <p>input geometry array or chunked geometry array</p> </li> <li> <code>fraction</code>             (<code>float | int | ArrowArrayExportable | NumpyArrayProtocolf64</code>)         \u2013          <p>the fractional distance along the line. A variety of inputs are accepted:</p> <ul> <li>A Python <code>float</code> or <code>int</code></li> <li>A numpy <code>ndarray</code> with <code>float64</code> data type.</li> <li>An Arrow array or chunked array with <code>float64</code> data type.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>PointArray with result values</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.line_locate_point","title":"line_locate_point  <code>method descriptor</code>","text":"<pre><code>line_locate_point(point: GeoInterfaceProtocol | ArrowArrayExportable) -&gt; Float64Array\n</code></pre> <p>Returns a fraction of the line's total length representing the location of the closest point on the line to the given point.</p> <p>This is intended to be equivalent to <code>shapely.line_locate_point</code> when <code>normalized=True</code>.</p> <p>If the line has zero length the fraction returned is zero.</p> <p>If either the point's coordinates or any coordinates of the line are not finite, returns <code>NaN</code>.</p> <p>Parameters:</p> <ul> <li> <code>input</code>         \u2013          <p>input geometry array or chunked geometry array</p> </li> <li> <code>point</code>             (<code>GeoInterfaceProtocol | ArrowArrayExportable</code>)         \u2013          <p>the fractional distance along the line. A variety of inputs are accepted:</p> <ul> <li>A scalar <code>Point</code></li> <li>A <code>PointArray</code></li> <li>A <code>ChunkedPointArray</code></li> <li>Any Python class that implements the Geo Interface, such as a <code>shapely</code> Point</li> <li>Any GeoArrow array or chunked array of <code>Point</code> type</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with float fraction values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.LineStringArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray","title":"PolygonArray","text":"<p>An immutable array of Polygon geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.PolygonArray' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; Polygon\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by <code>shapely.to_ragged_array</code>, including numpy object arrays and   <code>geopandas.GeoSeries</code></p> <p>Returns:</p> <pre><code>A new array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.polylabel","title":"polylabel  <code>method descriptor</code>","text":"<pre><code>polylabel(tolerance: float) -&gt; PointArray\n</code></pre> <p>Calculate a Polygon's ideal label position by calculating its pole of inaccessibility.</p> <p>The pole of inaccessibility is the most distant internal point from the polygon outline (not to be confused with centroid), and is useful for optimal placement of a text label on a polygon.</p> <p>The calculation uses an iterative grid-based algorithm, ported from the original JavaScript implementation.</p> <p>Parameters:</p> <ul> <li> <code>tolerance</code>             (<code>float</code>)         \u2013          <p>precision of algorithm. Refer to the original JavaScript  documentation  for more information</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>PointArray with result values</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.PolygonArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray","title":"MultiPointArray","text":"<p>An immutable array of MultiPoint geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.MultiPointArray' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; MultiPoint\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by <code>shapely.to_ragged_array</code>, including numpy object arrays and   <code>geopandas.GeoSeries</code></p> <p>Returns:</p> <pre><code>A new array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length(*, method: LengthMethod | LengthMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Calculation of the length of a Line</p> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>LengthMethod | LengthMethodT</code>)         \u2013          <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with length values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPointArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray","title":"MultiLineStringArray","text":"<p>An immutable array of MultiLineString geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.MultiLineStringArray' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; MultiLineString\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by <code>shapely.to_ragged_array</code>, including numpy object arrays and   <code>geopandas.GeoSeries</code></p> <p>Returns:</p> <pre><code>A new array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length(*, method: LengthMethod | LengthMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Calculation of the length of a Line</p> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>LengthMethod | LengthMethodT</code>)         \u2013          <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with length values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiLineStringArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray","title":"MultiPolygonArray","text":"<p>An immutable array of MultiPolygon geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.MultiPolygonArray' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; MultiPolygon\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by <code>shapely.to_ragged_array</code>, including numpy object arrays and   <code>geopandas.GeoSeries</code></p> <p>Returns:</p> <pre><code>A new array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.rotate_around_center","title":"rotate_around_center  <code>method descriptor</code>","text":"<pre><code>rotate_around_center(degrees)\n</code></pre> <p>Rotate a geometry around the center of its bounding box by an angle, in degrees.</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.rotate_around_centroid","title":"rotate_around_centroid  <code>method descriptor</code>","text":"<pre><code>rotate_around_centroid(degrees)\n</code></pre> <p>Rotate a geometry around its centroid by an angle, in degrees</p> <p>Positive angles are counter-clockwise, and negative angles are clockwise rotations.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.scale","title":"scale  <code>method descriptor</code>","text":"<pre><code>scale(scale_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.scale_xy","title":"scale_xy  <code>method descriptor</code>","text":"<pre><code>scale_xy(x_factor, y_factor)\n</code></pre> <p>Scale a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.skew","title":"skew  <code>method descriptor</code>","text":"<pre><code>skew(degrees)\n</code></pre> <p>An affine transformation which skews a geometry, sheared by a uniform angle along the x and y dimensions.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.skew_xy","title":"skew_xy  <code>method descriptor</code>","text":"<pre><code>skew_xy(degrees_x, degrees_y)\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>x_factor</code> and <code>y_factor</code> to distort the geometry's aspect ratio.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MultiPolygonArray.translate","title":"translate  <code>method descriptor</code>","text":"<pre><code>translate(x_offset, y_offset)\n</code></pre> <p>Translate a Geometry along its axes by the given offsets</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray","title":"MixedGeometryArray","text":"<p>An immutable array of Geometry geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.MixedGeometryArray' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; Geometry\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.from_ewkb","title":"from_ewkb  <code>builtin</code>","text":"<pre><code>from_ewkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from EWKB to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding EWKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by <code>shapely.to_wkb</code>, including numpy   object arrays and <code>geopandas.GeoSeries</code></p> <p>Returns:</p> <pre><code>A new array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.from_wkt","title":"from_wkt  <code>builtin</code>","text":"<pre><code>from_wkt(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow StringArray from WKT to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of string type holding WKT-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.MixedGeometryArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray","title":"GeometryCollectionArray","text":"<p>An immutable array of GeometryCollection geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.GeometryCollectionArray' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; GeometryCollection\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; PointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; PointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>PointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; PolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.from_ewkb","title":"from_ewkb  <code>builtin</code>","text":"<pre><code>from_ewkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from EWKB to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding EWKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by <code>shapely.to_wkb</code>, including numpy   object arrays and <code>geopandas.GeoSeries</code></p> <p>Returns:</p> <pre><code>A new array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.from_wkb","title":"from_wkb  <code>builtin</code>","text":"<pre><code>from_wkb(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow BinaryArray from WKB to its GeoArrow-native counterpart.</p> <p>This expects ISO-formatted WKB geometries.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of Binary type holding WKB-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.from_wkt","title":"from_wkt  <code>builtin</code>","text":"<pre><code>from_wkt(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Parse an Arrow StringArray from WKT to its GeoArrow-native counterpart.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>An Arrow array of string type holding WKT-formatted geometries.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>A GeoArrow-native geometry array</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; Float64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; Float64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float64Array</code>         \u2013          <p>Array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.to_wkb","title":"to_wkb  <code>method descriptor</code>","text":"<pre><code>to_wkb() -&gt; WKBArray\n</code></pre> <p>Encode a GeoArrow-native geometry array to a WKBArray, holding ISO-formatted WKB geometries.</p> <p>Returns:</p> <ul> <li> <code>WKBArray</code>         \u2013          <p>An array with WKB-formatted geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.GeometryCollectionArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray","title":"WKBArray","text":"<p>An immutable array of WKB-encoded geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; WKB\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray.from_arrow","title":"from_arrow  <code>builtin</code>","text":"<pre><code>from_arrow(input: ArrowArrayExportable) -&gt; Self\n</code></pre> <p>Construct this object from existing Arrow data</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>ArrowArrayExportable</code>)         \u2013          <p>Arrow array to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by <code>shapely.to_wkb</code>, including numpy   object arrays and <code>geopandas.GeoSeries</code></p> <p>Returns:</p> <pre><code>A new array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.WKBArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.RectArray","title":"RectArray","text":"<p>An immutable array of Rect geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.RectArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema=None)\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.RectArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.RectArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; Rect\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.RectArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.RectArray.to_polygon_array","title":"to_polygon_array  <code>method descriptor</code>","text":"<pre><code>to_polygon_array() -&gt; PolygonArray\n</code></pre> <p>Convert this array to a PolygonArray</p> <p>Returns:</p> <ul> <li> <code>PolygonArray</code>         \u2013          <p>Array with polygon geometries</p> </li> </ul>"},{"location":"api/core/geometry/array/#geoarrow.rust.core.RectArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/chunked/","title":"Chunked Geometry Arrays","text":"<p>Chunked arrays of geospatial geometries, each of the same type.</p> <ul> <li><code>ChunkedPointArray</code></li> <li><code>ChunkedLineStringArray</code></li> <li><code>ChunkedPolygonArray</code></li> <li><code>ChunkedMultiPointArray</code></li> <li><code>ChunkedMultiLineStringArray</code></li> <li><code>ChunkedMultiPolygonArray</code></li> <li><code>ChunkedMixedGeometryArray</code></li> <li><code>ChunkedGeometryCollectionArray</code></li> <li><code>ChunkedWKBArray</code></li> <li><code>ChunkedRectArray</code></li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray","title":"ChunkedPointArray","text":"<p>An immutable chunked array of Point geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; Point\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[PointArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; PointArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(input: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>Sequence[ArrowArrayExportable]</code>)         \u2013          <p>Arrow arrays to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input, *, chunk_size: int = 65536) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by   <code>shapely.to_ragged_array</code>, including numpy object   arrays and <code>geopandas.GeoSeries</code></p> <p>Other args:</p> <pre><code>chunk_size: Maximum number of items per chunk.\n</code></pre> <p>Returns:</p> <pre><code>A new chunked array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length(*, method: LengthMethod | LengthMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculation of the length of a Line</p> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>LengthMethod | LengthMethodT</code>)         \u2013          <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with length values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPointArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray","title":"ChunkedLineStringArray","text":"<p>An immutable chunked array of LineString geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; LineString\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[LineStringArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; LineStringArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.frechet_distance","title":"frechet_distance  <code>method descriptor</code>","text":"<pre><code>frechet_distance(other: BroadcastGeometry) -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the similarity between two arrays of <code>LineStrings</code> using the Frechet distance.</p> <p>The Fr\u00e9chet distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter \u2018densify\u2019 makes this approximation less coarse by splitting the line segments between vertices before computing the distance.</p> <p>Fr\u00e9chet distance sweep continuously along their respective curves and the direction of curves is significant. This makes it a better measure of similarity than Hausdorff distance for curve or surface matching.</p> <p>This implementation is based on Computing Discrete Frechet Distance by T. Eiter and H. Mannila.</p> <p>Parameters:</p> <ul> <li> <code>other</code>             (<code>BroadcastGeometry</code>)         \u2013          <p>the geometry or geometry array to compare against. This must contain geometries of `LineString`` type. A variety of inputs are accepted:</p> <ul> <li>A scalar <code>LineString</code></li> <li>A <code>LineStringArray</code></li> <li>A <code>ChunkedLineStringArray</code></li> <li>Any Python class that implements the Geo Interface, such as a <code>shapely</code> LineString</li> <li>Any GeoArrow array or chunked array of <code>LineString</code> type</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked Array with float distance values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(input: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>Sequence[ArrowArrayExportable]</code>)         \u2013          <p>Arrow arrays to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input, *, chunk_size: int = 65536) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by   <code>shapely.to_ragged_array</code>, including numpy object   arrays and <code>geopandas.GeoSeries</code></p> <p>Other args:</p> <pre><code>chunk_size: Maximum number of items per chunk.\n</code></pre> <p>Returns:</p> <pre><code>A new chunked array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length(*, method: LengthMethod | LengthMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculation of the length of a Line</p> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>LengthMethod | LengthMethodT</code>)         \u2013          <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with length values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.line_interpolate_point","title":"line_interpolate_point  <code>method descriptor</code>","text":"<pre><code>line_interpolate_point(fraction: float | int | ArrowStreamExportable) -&gt; ChunkedPointArray\n</code></pre> <p>Returns a point interpolated at given distance on a line.</p> <p>This is intended to be equivalent to <code>shapely.line_interpolate_point</code> when <code>normalized=True</code>.</p> <p>If the given fraction is  * less than zero (including negative infinity): returns the starting point  * greater than one (including infinity): returns the ending point  * If either the fraction is NaN, or any coordinates of the line are not    finite, returns <code>Point EMPTY</code>.</p> <p>Parameters:</p> <ul> <li> <code>input</code>         \u2013          <p>input geometry array or chunked geometry array</p> </li> <li> <code>fraction</code>             (<code>float | int | ArrowStreamExportable</code>)         \u2013          <p>the fractional distance along the line. A variety of inputs are accepted:</p> <ul> <li>A Python <code>float</code> or <code>int</code></li> <li>A numpy <code>ndarray</code> with <code>float64</code> data type.</li> <li>An Arrow array or chunked array with <code>float64</code> data type.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>ChunkedPointArray with result values</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.line_locate_point","title":"line_locate_point  <code>method descriptor</code>","text":"<pre><code>line_locate_point(point: GeoInterfaceProtocol | ArrowStreamExportable) -&gt; ChunkedFloat64Array\n</code></pre> <p>Returns a fraction of the line's total length representing the location of the closest point on the line to the given point.</p> <p>This is intended to be equivalent to <code>shapely.line_locate_point</code> when <code>normalized=True</code>.</p> <p>If the line has zero length the fraction returned is zero.</p> <p>If either the point's coordinates or any coordinates of the line are not finite, returns <code>NaN</code>.</p> <p>Parameters:</p> <ul> <li> <code>input</code>         \u2013          <p>input geometry array or chunked geometry array</p> </li> <li> <code>point</code>             (<code>GeoInterfaceProtocol | ArrowStreamExportable</code>)         \u2013          <p>the fractional distance along the line. A variety of inputs are accepted:</p> <ul> <li>A scalar <code>Point</code></li> <li>A <code>PointArray</code></li> <li>A <code>ChunkedPointArray</code></li> <li>Any Python class that implements the Geo Interface, such as a <code>shapely</code> Point</li> <li>Any GeoArrow array or chunked array of <code>Point</code> type</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with float fraction values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedLineStringArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray","title":"ChunkedPolygonArray","text":"<p>An immutable chunked array of Polygon geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; Polygon\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[PolygonArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; PolygonArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(input: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>Sequence[ArrowArrayExportable]</code>)         \u2013          <p>Arrow arrays to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input, *, chunk_size: int = 65536) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by   <code>shapely.to_ragged_array</code>, including numpy object   arrays and <code>geopandas.GeoSeries</code></p> <p>Other args:</p> <pre><code>chunk_size: Maximum number of items per chunk.\n</code></pre> <p>Returns:</p> <pre><code>A new chunked array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.polylabel","title":"polylabel  <code>method descriptor</code>","text":"<pre><code>polylabel(tolerance: float) -&gt; ChunkedPointArray\n</code></pre> <p>Calculate a Polygon's ideal label position by calculating its pole of inaccessibility.</p> <p>The pole of inaccessibility is the most distant internal point from the polygon outline (not to be confused with centroid), and is useful for optimal placement of a text label on a polygon.</p> <p>The calculation uses an iterative grid-based algorithm, ported from the original JavaScript implementation.</p> <p>Parameters:</p> <ul> <li> <code>tolerance</code>             (<code>float</code>)         \u2013          <p>precision of algorithm. Refer to the original JavaScript  documentation  for more information</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>ChunkedPointArray with result values</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedPolygonArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray","title":"ChunkedMultiPointArray","text":"<p>An immutable chunked array of MultiPoint geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; MultiPoint\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[MultiPointArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; MultiPointArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(input: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>Sequence[ArrowArrayExportable]</code>)         \u2013          <p>Arrow arrays to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input, *, chunk_size: int = 65536) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by   <code>shapely.to_ragged_array</code>, including numpy object   arrays and <code>geopandas.GeoSeries</code></p> <p>Other args:</p> <pre><code>chunk_size: Maximum number of items per chunk.\n</code></pre> <p>Returns:</p> <pre><code>A new chunked array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length(*, method: LengthMethod | LengthMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculation of the length of a Line</p> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>LengthMethod | LengthMethodT</code>)         \u2013          <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with length values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPointArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray","title":"ChunkedMultiLineStringArray","text":"<p>An immutable chunked array of MultiLineString geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; MultiLineString\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[MultiLineStringArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; MultiLineStringArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(input: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>Sequence[ArrowArrayExportable]</code>)         \u2013          <p>Arrow arrays to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input, *, chunk_size: int = 65536) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by   <code>shapely.to_ragged_array</code>, including numpy object   arrays and <code>geopandas.GeoSeries</code></p> <p>Other args:</p> <pre><code>chunk_size: Maximum number of items per chunk.\n</code></pre> <p>Returns:</p> <pre><code>A new chunked array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.length","title":"length  <code>method descriptor</code>","text":"<pre><code>length(*, method: LengthMethod | LengthMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Calculation of the length of a Line</p> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>LengthMethod | LengthMethodT</code>)         \u2013          <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with length values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiLineStringArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray","title":"ChunkedMultiPolygonArray","text":"<p>An immutable chunked array of MultiPolygon geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; MultiPolygon\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.chaikin_smoothing","title":"chaikin_smoothing  <code>method descriptor</code>","text":"<pre><code>chaikin_smoothing(n_iterations: int) -&gt; Self\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>n_iterations</code>             (<code>int</code>)         \u2013          <p>Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Smoothed geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[MultiPolygonArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; MultiPolygonArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.densify","title":"densify  <code>method descriptor</code>","text":"<pre><code>densify(max_distance: float) -&gt; Self\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>max_distance</code>             (<code>float</code>)         \u2013          <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Densified geometry array</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(input: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>Sequence[ArrowArrayExportable]</code>)         \u2013          <p>Arrow arrays to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input, *, chunk_size: int = 65536) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by   <code>shapely.to_ragged_array</code>, including numpy object   arrays and <code>geopandas.GeoSeries</code></p> <p>Other args:</p> <pre><code>chunk_size: Maximum number of items per chunk.\n</code></pre> <p>Returns:</p> <pre><code>A new chunked array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.simplify","title":"simplify  <code>method descriptor</code>","text":"<pre><code>simplify(epsilon: float, *, method: SimplifyMethod | SimplifyMethodT = 'rdp') -&gt; Self\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>epsilon</code>             (<code>float</code>)         \u2013          <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>             (<code>SimplifyMethod | SimplifyMethodT</code>)         \u2013          <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMultiPolygonArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray","title":"ChunkedMixedGeometryArray","text":"<p>An immutable chunked array of Geometry geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; Geometry\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[MixedGeometryArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; MixedGeometryArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(input: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>Sequence[ArrowArrayExportable]</code>)         \u2013          <p>Arrow arrays to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input, *, chunk_size: int = 65536) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by   <code>shapely.to_ragged_array</code>, including numpy object   arrays and <code>geopandas.GeoSeries</code></p> <p>Other args:</p> <pre><code>chunk_size: Maximum number of items per chunk.\n</code></pre> <p>Returns:</p> <pre><code>A new chunked array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedMixedGeometryArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray","title":"ChunkedGeometryCollectionArray","text":"<p>An immutable chunked array of GeometryCollection geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; GeometryCollection\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.affine_transform","title":"affine_transform  <code>method descriptor</code>","text":"<pre><code>affine_transform(transform)\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>other</code>         \u2013          <p>an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li>         \u2013          <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.area","title":"area  <code>method descriptor</code>","text":"<pre><code>area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Unsigned area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.center","title":"center  <code>method descriptor</code>","text":"<pre><code>center() -&gt; ChunkedPointArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with center values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.centroid","title":"centroid  <code>method descriptor</code>","text":"<pre><code>centroid() -&gt; ChunkedPointArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Returns:</p> <ul> <li> <code>ChunkedPointArray</code>         \u2013          <p>Array with centroid values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[GeometryCollectionArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.concatenate","title":"concatenate  <code>method descriptor</code>","text":"<pre><code>concatenate() -&gt; GeometryCollectionArray\n</code></pre> <p>Concatenate a chunked array into a contiguous array.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.convex_hull","title":"convex_hull  <code>method descriptor</code>","text":"<pre><code>convex_hull() -&gt; ChunkedPolygonArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Returns:</p> <ul> <li> <code>ChunkedPolygonArray</code>         \u2013          <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.envelope","title":"envelope  <code>method descriptor</code>","text":"<pre><code>envelope()\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Returns:</p> <ul> <li>         \u2013          <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(input: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>Sequence[ArrowArrayExportable]</code>)         \u2013          <p>Arrow arrays to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input, *, chunk_size: int = 65536) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by   <code>shapely.to_ragged_array</code>, including numpy object   arrays and <code>geopandas.GeoSeries</code></p> <p>Other args:</p> <pre><code>chunk_size: Maximum number of items per chunk.\n</code></pre> <p>Returns:</p> <pre><code>A new chunked array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_perimeter","title":"geodesic_perimeter  <code>method descriptor</code>","text":"<pre><code>geodesic_perimeter() -&gt; ChunkedFloat64Array\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Array with output values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; BooleanArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Returns:</p> <ul> <li> <code>BooleanArray</code>         \u2013          <p>Result array.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.signed_area","title":"signed_area  <code>method descriptor</code>","text":"<pre><code>signed_area(*, method: AreaMethod | AreaMethodT = 'euclidean') -&gt; ChunkedFloat64Array\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>method</code>             (<code>AreaMethod | AreaMethodT</code>, default:                 <code>'euclidean'</code> )         \u2013          <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ChunkedFloat64Array</code>         \u2013          <p>Chunked array with area values.</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedGeometryCollectionArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray","title":"ChunkedWKBArray","text":"<p>An immutable chunked array of WKB-encoded geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; WKB\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[WKBArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.from_arrow_arrays","title":"from_arrow_arrays  <code>builtin</code>","text":"<pre><code>from_arrow_arrays(input: Sequence[ArrowArrayExportable]) -&gt; Self\n</code></pre> <p>Construct this chunked array from existing Arrow data</p> <p>This is a temporary workaround for this pyarrow issue, where it's currently impossible to read a pyarrow <code>ChunkedArray</code> directly without adding a direct dependency on pyarrow.</p> <p>Parameters:</p> <ul> <li> <code>input</code>             (<code>Sequence[ArrowArrayExportable]</code>)         \u2013          <p>Arrow arrays to use for constructing this object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>         \u2013          <p>Self</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.from_shapely","title":"from_shapely  <code>builtin</code>","text":"<pre><code>from_shapely(input, *, chunk_size: int = 65536) -&gt; Self\n</code></pre> <p>Create this array from a shapely array</p> <p>Args:</p> <p>input: Any array object accepted by   <code>shapely.to_ragged_array</code>, including numpy object   arrays and <code>geopandas.GeoSeries</code></p> <p>Other args:</p> <pre><code>chunk_size: Maximum number of items per chunk.\n</code></pre> <p>Returns:</p> <pre><code>A new chunked array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.to_shapely","title":"to_shapely  <code>method descriptor</code>","text":"<pre><code>to_shapely() -&gt; NDArray[np.object_]\n</code></pre> <p>Convert this array to a shapely array</p> <p>Returns:</p> <pre><code>A shapely array.\n</code></pre>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedWKBArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray","title":"ChunkedRectArray","text":"<p>An immutable chunked array of Rect geometries using GeoArrow's in-memory representation.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value) -&gt; bool\n</code></pre> <p>Return self==value.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: int) -&gt; Rect\n</code></pre> <p>Return self[key].</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[RectArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/geometry/chunked/#geoarrow.rust.core.ChunkedRectArray.total_bounds","title":"total_bounds  <code>method descriptor</code>","text":"<pre><code>total_bounds() -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>         \u2013          <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/core/geometry/scalar/","title":"Geometry Scalars","text":"<p>The classes on this page represent individual geometry scalars.</p> <p>Note that operations on arrays will be more performant than operations on scalars. Use arrays and chunked arrays where possible.</p> <ul> <li><code>Point</code></li> <li><code>LineString</code></li> <li><code>Polygon</code></li> <li><code>MultiPoint</code></li> <li><code>MultiLineString</code></li> <li><code>MultiPolygon</code></li> <li><code>MixedGeometry</code></li> <li><code>GeometryCollection</code></li> <li><code>WKB</code></li> <li><code>Rect</code></li> </ul>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Point","title":"Point","text":"<p>An immutable Point scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Point.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.Point' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Point.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.LineString","title":"LineString","text":"<p>An immutable LineString scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.LineString.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.LineString' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.LineString.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Polygon","title":"Polygon","text":"<p>An immutable Polygon scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Polygon.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.Polygon' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Polygon.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.MultiPoint","title":"MultiPoint","text":"<p>An immutable MultiPoint scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.MultiPoint.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.MultiPoint' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.MultiPoint.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.MultiLineString","title":"MultiLineString","text":"<p>An immutable MultiLineString scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.MultiLineString.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.MultiLineString' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.MultiLineString.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.MultiPolygon","title":"MultiPolygon","text":"<p>An immutable MultiPolygon scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.MultiPolygon.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.MultiPolygon' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.MultiPolygon.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.GeometryCollection","title":"GeometryCollection","text":"<p>An immutable GeometryCollection scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.GeometryCollection.__geo_interface__","title":"__geo_interface__","text":"<pre><code>__geo_interface__: dict = &lt;attribute '__geo_interface__' of 'geoarrow.rust.core._rust.GeometryCollection' objects&gt;\n</code></pre> <p>Implements the \"geo interface protocol\".</p> <p>See gist.github.com/sgillies/2217756</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.GeometryCollection.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.WKB","title":"WKB","text":"<p>An immutable WKB-encoded scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Rect","title":"Rect","text":"<p>An immutable Rect scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.Rect.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/primitive/array/","title":"Primitive Arrays","text":"<p>Arrays of non-geospatial types. These exist to be used as return types from geospatial operations to maintain strong typing.</p> <ul> <li><code>BooleanArray</code></li> </ul> <ul> <li><code>Float64Array</code></li> </ul>"},{"location":"api/core/primitive/array/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/primitive/array/#geoarrow.rust.core.BooleanArray","title":"BooleanArray","text":""},{"location":"api/core/primitive/array/#geoarrow.rust.core.BooleanArray.__array__","title":"__array__  <code>method descriptor</code>","text":"<pre><code>__array__() -&gt; NDArray[np.bool_]\n</code></pre> <p>An implementation of the Array interface, for interoperability with numpy and other array libraries.</p>"},{"location":"api/core/primitive/array/#geoarrow.rust.core.BooleanArray.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/primitive/array/#geoarrow.rust.core.BooleanArray.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.bool_]\n</code></pre> <p>Copy this array to a <code>numpy</code> NDArray</p>"},{"location":"api/core/primitive/array/#geoarrow.rust.core.Float64Array","title":"Float64Array","text":""},{"location":"api/core/primitive/array/#geoarrow.rust.core.Float64Array.__array__","title":"__array__  <code>method descriptor</code>","text":"<pre><code>__array__() -&gt; NDArray[np.float64]\n</code></pre> <p>An implementation of the Array interface, for interoperability with numpy and other array libraries.</p>"},{"location":"api/core/primitive/array/#geoarrow.rust.core.Float64Array.__arrow_c_array__","title":"__arrow_c_array__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_array__(requested_schema: object | None = None) -&gt; Tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/primitive/array/#geoarrow.rust.core.Float64Array.from_numpy","title":"from_numpy  <code>builtin</code>","text":"<pre><code>from_numpy(arr: NDArray[np.float64]) -&gt; Self\n</code></pre> <p>Construct an array from a Numpy <code>ndarray</code></p>"},{"location":"api/core/primitive/array/#geoarrow.rust.core.Float64Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.float64]\n</code></pre> <p>Copy this array to a <code>numpy</code> NDArray</p>"},{"location":"api/core/primitive/chunked/","title":"Chunked Primitive Arrays","text":"<p>Chunked arrays of non-geospatial types. These exist to be used as return types from geospatial operations to maintain strong typing.</p> <ul> <li><code>ChunkedBooleanArray</code></li> </ul> <ul> <li><code>ChunkedFloat64Array</code></li> </ul>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedBooleanArray","title":"ChunkedBooleanArray","text":""},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedBooleanArray.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedBooleanArray.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[BooleanArray]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedBooleanArray.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedBooleanArray.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.bool_]\n</code></pre> <p>Copy this array to a <code>numpy</code> NDArray</p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedFloat64Array","title":"ChunkedFloat64Array","text":""},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedFloat64Array.__arrow_c_stream__","title":"__arrow_c_stream__  <code>method descriptor</code>","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example (as of the upcoming pyarrow v16), you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedFloat64Array.chunks","title":"chunks  <code>method descriptor</code>","text":"<pre><code>chunks() -&gt; List[Float64Array]\n</code></pre> <p>Convert to a list of single-chunked arrays.</p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedFloat64Array.from_numpy","title":"from_numpy  <code>builtin</code>","text":"<pre><code>from_numpy(arr: NDArray[np.float64], lengths: List[int]) -&gt; Self\n</code></pre> <p>Construct a chunked array from a Numpy <code>ndarray</code></p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedFloat64Array.num_chunks","title":"num_chunks  <code>method descriptor</code>","text":"<pre><code>num_chunks() -&gt; int\n</code></pre> <p>Number of underlying chunks.</p>"},{"location":"api/core/primitive/chunked/#geoarrow.rust.core.ChunkedFloat64Array.to_numpy","title":"to_numpy  <code>method descriptor</code>","text":"<pre><code>to_numpy() -&gt; NDArray[np.float64]\n</code></pre> <p>Copy this array to a <code>numpy</code> NDArray</p>"},{"location":"ecosystem/geopandas/","title":"GeoPandas","text":"<p>Use the <code>from_geopandas</code> and <code>to_geopandas</code> functions to convert a GeoTable from and to GeoPandas.</p> <pre><code>import geopandas as gpd\nfrom geoarrow.rust.core import from_geopandas, to_geopandas\n\ngdf = gpd.GeoDataFrame(...)\ntable = from_geopandas(gdf)\nback_to_geopandas_gdf = to_geopandas(table)\n</code></pre>"},{"location":"ecosystem/lonboard/","title":"Lonboard","text":"<p>Lonboard is a Python library for fast, interactive geospatial vector data visualization in Jupyter.</p> <p></p> <p>Lonboard was designed from the ground up to be used with GeoArrow and is the reason why Lonboard is fast.</p> <p>As of Lonboard version 0.6 or later, just pass a GeoTable as the <code>table</code> parameter of a layer.</p>"},{"location":"ecosystem/lonboard/#examples","title":"Examples","text":"<pre><code>from geoarrow.rust.core import read_geojson\nfrom lonboard import Map, PathLayer\n\npath = \"/path/to/file.geojson\"\ngeo_table = read_geojson(path)\ngeo_table.geometry\n\nlayer = PathLayer(table=geo_table)\nm = Map(layer)\nm\n</code></pre> <p>Refer to lonboard's documentation for more examples.</p>"},{"location":"ecosystem/polars/","title":"Polars","text":"<p>Well, doesn't really work right now. Crs and geometry type both get lost</p>"},{"location":"ecosystem/pyogrio/","title":"Pyogrio/GDAL","text":"<p>Use the <code>read_pyogrio</code> function to read an OGR-supported data source through pyogrio.</p> <p>This requires the optional <code>pyogrio</code> and <code>pyarrow</code> dependencies.</p> <pre><code>from geoarrow.rust.core import read_pyogrio\n\npath = \"path/to/file.shp\"\ntable = read_pyogrio(path)\ntable.geometry\n# &lt;geoarrow.rust.core._rust.ChunkedMultiLineStringArray at 0x13fb61e70&gt;\n</code></pre>"},{"location":"ecosystem/shapely/","title":"Shapely","text":"<p>For interoperability with Shapely, you have three options:</p> <ul> <li>Top-level <code>to_shapely</code> and <code>from_shapely</code> functions which aim to accept all array input.</li> <li><code>to_shapely</code> and <code>from_shapely</code> methods available on geometry arrays</li> <li><code>to_shapely</code> and <code>from_shapely</code> methods available on chunked geometry arrays</li> </ul> <p>How to choose?</p> <ul> <li> <p>If you know your data's geometry type, prefer the <code>from_shapely</code> method on a chunked array class. E.g. <code>ChunkedLineStringArray.from_shapely()</code>.</p> <p>This has type hinting and auto-completion benefits because your code editor knows what output array you'll receive. It also validates that your data match the geometry type you expect.</p> <p>It can also lead to better performance because many operations over chunked arrays are automatically multi-threading. - Top-level functions should work with all GeoArrow data structures (except tables as Shapely is geometry-only). The downside is that</p> </li> </ul> <p>Shapely interoperability requires <code>shapely</code> to be installed, and requires Shapely version 2.0 or higher.</p>"},{"location":"ecosystem/shapely/#examples","title":"Examples","text":"<pre><code>from geoarrow.rust.core import from_shapely, to_shapely\nimport shapely\n\nshapely_geoms = to_shapely(geoarrow_array)\ngeoarrow_array = from_shapely(shapely_geoms)\n</code></pre> <p>Or, if you know the geometry type:</p> <pre><code>from geoarrow.rust.core import ChunkedLineStringArray\nimport shapely\n\ngeoarrow_array = ChunkedLineStringArray.from_shapely(shapely_geoms)\nshapely_geoms = geoarrow_array.to_shapely()\n</code></pre>"},{"location":"performance/multithreading/","title":"Multi-threading","text":"<p>A Table contains internal \"chunking\" where the first n rows for all columns are part of the first chunk, then the next n rows for all columns are part of the second chunk, and so on. The geometry column of the table is a chunked geometry array, which similarly is grouped into batches of n rows.</p> <p>Multi-threading is enabled out-of-the-box for all operations on these chunked data structures.</p> <p>This means that to take advantage of multi-threading, your table must have internal chunking. This is the default whenever reading directly from a file (you can tweak the <code>batch_size</code> argument).</p> <p>When creating a table from an existing data source, such as GeoPandas or Pyogrio, the data may not already be chunked. In the future, a <code>rechunk</code> operation will be added to assist in creating more internal chunks to ensure operations are multi-threaded.</p>"}]}