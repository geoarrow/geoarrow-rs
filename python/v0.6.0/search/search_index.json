{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"geoarrow.rust","text":"<p>Python bindings to the GeoArrow Rust implementation.</p>"},{"location":"#overview","title":"Overview","text":"<p>This library contains Python bindings to the GeoArrow Rust implementation.</p> <ul> <li>Fast: Connects to algorithms implemented in GeoRust, which compile to native code.</li> <li>Self-contained: <code>pyproj</code> is the only Python dependency.</li> <li>Easy to install: Distributed as static binary wheels with zero C dependencies.</li> <li>Static typing: type hints for all operations.</li> <li>Interoperable ecosystem: Efficient data exchange with other libraries in the Python Arrow and GeoArrow ecosystems, such as geoarrow-c or lightning-fast map rendering.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>Refer to the documentation website.</p>"},{"location":"#modules","title":"Modules","text":"<p><code>geoarrow.rust</code> is distributed with namespace packaging, meaning that each Python submodule is published to PyPI independently. This allows for separation of concerns and smaller environments when only some portion of functionality is necessary.</p> <p>Existing modules:</p> <ul> <li><code>geoarrow-rust-core</code>: Data structures to store and manage geometry data in GeoArrow format.</li> <li><code>geoarrow-rust-compute</code>: Compute operations on GeoArrow data.</li> <li><code>geoarrow-rust-io</code>: Pure-rust readers and writers for geospatial file formats.</li> </ul> <p>In order to obtain relevant modules, you should install them from PyPI directly, e.g.:</p> <p><pre><code>pip install geoarrow-rust-core geoarrow-rust-compute geoarrow-rust-io\n</code></pre> See DEVELOP.md for more information on developing and building the Python bindings.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#060-2025-10-16","title":"[0.6.0] - 2025-10-16","text":""},{"location":"CHANGELOG/#whats-changed","title":"What's Changed","text":"<ul> <li>docs: include constructor docs in the table of contents by @keewis in geoarrow/geoarrow-rs!1347</li> <li>fix(geoarrow-flatgeobuf): Fix FlatGeobuf reader with missing (null) properties by @kylebarron in geoarrow/geoarrow-rs!1356</li> <li>test: Fix Python WKT and WKT tests by @kylebarron in geoarrow/geoarrow-rs!1359</li> <li>fix: Preserve import errors from Arrow C Stream by @kylebarron in geoarrow/geoarrow-rs!1360</li> <li>feat: conversion method parameter for <code>from_shapely</code> by @keewis in geoarrow/geoarrow-rs!1348</li> <li>feat(python, geoarrow-rust-core): Implement <code>geometry_col</code> by @kylebarron in geoarrow/geoarrow-rs!1381</li> <li>feat(python): Constructor for GeoChunkedArray by @kylebarron in geoarrow/geoarrow-rs!1383</li> <li>fix(python): Fix <code>__geo_interface__</code> export for GeoScalar by @kylebarron in geoarrow/geoarrow-rs!1384</li> <li>feat(python): Constuctor for GeoArray by @kylebarron in geoarrow/geoarrow-rs!1385</li> </ul>"},{"location":"CHANGELOG/#new-contributors","title":"New Contributors","text":"<ul> <li>@keewis made their first contribution in geoarrow/geoarrow-rs!1347</li> </ul> <p>Full Changelog: github.com/geoarrow/geoarrow-rs/compare/py-v0.5.3...py-v0.6.0</p>"},{"location":"CHANGELOG/#053-2025-09-25","title":"[0.5.3] - 2025-09-25","text":"<ul> <li>chore: Bump lockfiles to update wkb dependency #1342</li> </ul>"},{"location":"CHANGELOG/#052-2025-09-12","title":"[0.5.2] - 2025-09-12","text":"<ul> <li>fix(geoarrow-array): Fix persisting CRS when creating GeometryArray from Field #1326. This also fixes an internal error when downcasting a GeometryArray with a CRS.</li> <li>ci(Python): Remove Windows x86 build #1329</li> </ul>"},{"location":"CHANGELOG/#051-2025-08-11","title":"[0.5.1] - 2025-08-11","text":"<ul> <li>Build Python 3.13 wheels for Windows geoarrow/geoarrow-rs!1305</li> </ul>"},{"location":"CHANGELOG/#050-2025-08-07","title":"[0.5.0] - 2025-08-07","text":"<ul> <li>Add <code>get_type_id</code> to infer geometry types from array #1280</li> <li>Release GIL when blocking tokio runtime geoarrow/geoarrow-rs!1281</li> <li>Add <code>read_flatgeobuf</code>, <code>read_flatgeobuf_async</code>, <code>write_flatgeobuf</code> geoarrow/geoarrow-rs!1279</li> </ul>"},{"location":"CHANGELOG/#041-2025-07-17","title":"[0.4.1] - 2025-07-17","text":"<ul> <li>Added <code>path</code> property to <code>GeoParquetFile</code> class so information about each fragment of a <code>GeoParquetDataset</code> can be associated back to the original file.</li> </ul>"},{"location":"CHANGELOG/#040-2025-07-01","title":"[0.4.0] - 2025-07-01","text":"<p>This release contains the Python bindings for more or less a full rewrite of the GeoArrow Rust library.</p>"},{"location":"CHANGELOG/#new-features-magic_wand","title":"New Features :magic_wand:","text":"<ul> <li>Full support for the GeoArrow 0.2 specification, including all geometry array types and dimensions.</li> <li>See documentation for <code>GeoArray</code>, <code>GeoChunkedArray</code>, <code>GeoScalar</code>, and <code>GeometryType</code> for more details.</li> <li>Support for reading and writing GeoParquet 1.1 files, including spatial filtering, including support for reading from remote files.</li> </ul>"},{"location":"CHANGELOG/#030-2024-09-07","title":"[0.3.0] - 2024-09-07","text":""},{"location":"CHANGELOG/#new-features-magic_wand_1","title":"New Features :magic_wand:","text":"<ul> <li>Remove geometry class specializations. Instead of <code>PointArray</code>, <code>LineStringArray</code>, etc, there's now just <code>GeometryArray</code>, <code>ChunkedGeometryArray</code>, and <code>Geometry</code> (a scalar).</li> <li>Remove GeoTable class, in favor of external, generic arrow Table implementations, such as <code>arro3.core.Table</code>.</li> <li>Move to slimmer, functional API. No more geometry methods on classes.</li> <li>Don't materialize input data when writing to a file.</li> <li>New <code>GeometryType</code> class for understanding the geometry type of an array or chunked array.</li> <li>Split Python code into three modules: <code>geoarrow-rust-core</code>, <code>geoarrow-rust-compute</code> and <code>geoarrow-rust-io</code>.</li> <li>Support for Pyodide Python environment</li> <li>Support Python file objects for reading and writing GeoParquet</li> </ul>"},{"location":"CHANGELOG/#bug-fixes","title":"Bug fixes","text":"<ul> <li>Fix array indexing with negative integers by @kylebarron in geoarrow/geoarrow-rs!724</li> </ul>"},{"location":"CHANGELOG/#020-2024-03-22","title":"[0.2.0] - 2024-03-22","text":""},{"location":"CHANGELOG/#new","title":"New!","text":""},{"location":"CHANGELOG/#new-io-support-for-reading-and-writing-to-geospatial-formats","title":"New I/O support for reading and writing to geospatial formats","text":"<ul> <li>Asynchronous FlatGeobuf reader. This also supports passing a spatial filter.</li> <li>Initial support for reading from PostGIS. Note that not all Postgres data types are supported yet. Create an issue if your query fails.</li> <li>Reading and writing newline-delimited GeoJSON.</li> <li>Pyogrio integration for reading from OGR/GDAL.</li> <li>Asynchronous GeoParquet reader for reading from remote files. By @weiji14 in geoarrow/geoarrow-rs!493</li> <li>Also new support for writing GeoParquet files.</li> <li>Most I/O readers and writers support Python file-like objects (in binary mode).</li> <li>Support for reading and writing Arrow IPC files.</li> </ul>"},{"location":"CHANGELOG/#better-interoperability-with-the-python-geospatial-ecosystem","title":"Better interoperability with the Python geospatial ecosystem.","text":"<ul> <li>Import from and export to GeoPandas GeoDataFrames. Refer to the GeoPandas interoperability documentation.</li> <li>Import from and export to Shapely arrays. Refer to the Shapely interoperability documentation.</li> <li>Better integration with Lonboard for fast visualization in Jupyter.</li> <li>All scalars, arrays, chunked arrays, and table objects implement <code>__geo_interface__</code> for interoperability with existing tools.</li> <li>Numpy interoperability for float array output from algorithms. Pass any <code>Float64Array</code> or <code>BooleanArray</code> to <code>numpy.asarray</code>. You can also pass a numpy array as vectorized input into a function like <code>line_interpolate_point</code>.</li> </ul>"},{"location":"CHANGELOG/#new-algorithms","title":"New algorithms!","text":"<ul> <li>Explode a Table where each multi-geometry expands into multiple rows of single geometries.</li> <li><code>total_bounds</code></li> <li>Unified <code>area</code> function for planar and geodesic area.</li> <li>Unified <code>simplify</code> function for multiple simplification methods. Also new support for topology-preserving simplification.</li> <li>Unified <code>length</code> function for euclidean and geodesic length calculations.</li> <li><code>frechet_distance</code> for LineString similarity.</li> <li><code>affine_transform</code>, which integrates with the Python <code>affine</code> library.</li> <li><code>line_interpolate_point</code> and <code>line_locate_point</code> for linear referencing.</li> <li><code>polylabel</code> for polygon labeling.</li> </ul>"},{"location":"CHANGELOG/#improved-display-of-python-objects","title":"Improved display of Python objects:","text":"<ul> <li>Scalars now display as SVG geometries inside Jupyter environments.</li> <li>Tables, arrays, and chunked arrays implement <code>__repr__</code> so that you can inspect data easily.</li> </ul>"},{"location":"CHANGELOG/#improved-usability","title":"Improved usability:","text":"<ul> <li><code>PointArray.from_xy</code> to simplify creating a point array from numpy arrays of coordinates.</li> <li>Index into arrays and chunked arrays with square brackets. E.g. <code>point_array[0]</code> will access the first point in the array. Negative indexing is also supported, so <code>point_array[-1]</code> will get the last item in the array.</li> <li>New top-level docs website.</li> </ul>"},{"location":"CHANGELOG/#new-contributors_1","title":"New Contributors","text":"<ul> <li>@Robinlovelace made their first contribution in geoarrow/geoarrow-rs!484</li> <li>@weiji14 made their first contribution in geoarrow/geoarrow-rs!493</li> </ul> <p>Full Changelog: github.com/geoarrow/geoarrow-rs/compare/py-v0.1.0...py-v0.2.0</p>"},{"location":"CHANGELOG/#010-2024-01-08","title":"[0.1.0] - 2024-01-08","text":"<ul> <li>Initial public release.</li> </ul>"},{"location":"DEVELOP/","title":"Development","text":"<p>To install versions of the package under active development, you need to have Rust installed, e.g. with rustup:</p> <pre><code>rustup update stable\n</code></pre> <p>clone the repo and navigate into it:</p> <pre><code>git clone https://github.com/geoarrow/geoarrow-rs\ncd geoarrow-rs\n</code></pre> <p>Then enter into the <code>python</code> directory:</p> <pre><code>cd python\nuv install\nuv run maturin develop -m geoarrow-core/Cargo.toml\nuv run maturin develop -m geoarrow-compute/Cargo.toml\nuv run maturin develop -m geoarrow-io/Cargo.toml\n</code></pre>"},{"location":"DEVELOP/#documentation","title":"Documentation","text":"<p>Start docs locally:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>Deploy docs (automatically):</p> <p>Push a new tag with the format <code>py-v*</code>, such as <code>py-v0.1.0</code>.</p> <p>Deploy docs (manually):</p> <pre><code>uv run mike deploy VERSION_TAG --update-aliases --push --deploy-prefix python/\n</code></pre> <p>This only needs to be run once ever, to set the redirect from <code>https://geoarrow.org/geoarrow-rs/python/</code> to <code>https://geoarrow.org/geoarrow-rs/python/latest/</code>.</p> <pre><code>uv run mike set-default latest --deploy-prefix python/ --push\n</code></pre>"},{"location":"DEVELOP/#emscripten-python-wheels","title":"Emscripten Python wheels","text":"<p>Install rust nightly and add wasm toolchain</p> <pre><code>rustup toolchain install nightly\nrustup target add --toolchain nightly wasm32-unknown-emscripten\n</code></pre> <p>Install maturin and pyodide-build</p> <pre><code>pip install -U maturin\npip install pyodide-build\n</code></pre> <p>Clone emsdk. I clone this into a specific path at <code>~/github/emscripten-core/emsdk</code> so that it can be shared across projects.</p> <pre><code>mkdir -p ~/github/emscripten-core/\ngit clone https://github.com/emscripten-core/emsdk.git ~/github/emscripten-core/emsdk\n# Or, set this manually\nPYODIDE_EMSCRIPTEN_VERSION=$(pyodide config get emscripten_version)\n~/github/emscripten-core/emsdk/emsdk install ${PYODIDE_EMSCRIPTEN_VERSION}\n~/github/emscripten-core/emsdk/emsdk activate ${PYODIDE_EMSCRIPTEN_VERSION}\nsource ~/github/emscripten-core/emsdk/emsdk_env.sh\n</code></pre> <p>Build <code>geoarrow-rust-core</code> and <code>geoarrow-rust-io</code>:</p> <pre><code>maturin build \\\n    --release \\\n    --no-default-features \\\n    -o dist \\\n    -m geoarrow-core/Cargo.toml \\\n    --target wasm32-unknown-emscripten \\\n    -i python3.11\nmaturin build \\\n    --release \\\n    --no-default-features \\\n    -o dist \\\n    -m geoarrow-io/Cargo.toml \\\n    --target wasm32-unknown-emscripten \\\n    -i python3.11\n</code></pre>"},{"location":"api/compute/enums/","title":"Enums","text":""},{"location":"api/compute/enums/#geoarrow.rust.compute.enums","title":"geoarrow.rust.compute.enums","text":""},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod","title":"AreaMethod","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Ellipsoidal","title":"Ellipsoidal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ellipsoidal = auto()\n</code></pre> <p>Use an ellipsoidal model of the Earth for area calculations.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Ellipsoidal--assumptions","title":"Assumptions","text":"<ul> <li>Polygons are assumed to be wound in a counter-clockwise direction for the exterior   ring and a clockwise direction for interior rings. This is the standard winding   for geometries that follow the Simple Feature standard. Alternative windings may   result in a negative area. See \"Interpreting negative area values\" below.</li> <li>Polygons are assumed to be smaller than half the size of the earth. If you expect   to be dealing with polygons larger than this, please use the <code>unsigned</code> methods.</li> </ul>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Ellipsoidal--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Ellipsoidal--interpreting-negative-area-values","title":"Interpreting negative area values","text":"<p>A negative value can mean one of two things:</p> <ol> <li>The winding of the polygon is in the clockwise direction (reverse winding). If    this is the case, and you know the polygon is smaller than half the area of    earth, you can take the absolute value of the reported area to get the correct    area.</li> <li>The polygon is larger than half the planet. In this case, the returned area of    the polygon is not correct. If you expect to be dealing with very large polygons,    please use the <code>unsigned</code> methods.</li> </ol>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Euclidean","title":"Euclidean  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Euclidean = auto()\n</code></pre> <p>Calculate planar area.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Spherical","title":"Spherical  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Spherical = auto()\n</code></pre> <p>Use a spherical model of the Earth for area calculations.</p> <p>Calculate the geodesic area of a geometry on a sphere using the algorithm presented in Some Algorithms for Polygons on a Sphere by Chamberlain and Duquette (2007).</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.AreaMethod.Spherical--units","title":"Units","text":"<ul> <li>return value: meter\u00b2</li> </ul>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.LengthMethod","title":"LengthMethod","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.LengthMethod.Ellipsoidal","title":"Ellipsoidal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ellipsoidal = auto()\n</code></pre> <p>Determine the length of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013). As opposed to older methods like Vincenty, this method is accurate to a few nanometers and always converges.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.LengthMethod.Euclidean","title":"Euclidean  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Euclidean = auto()\n</code></pre> <p>Determine the length of a geometry using planar calculations.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.LengthMethod.Haversine","title":"Haversine  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Haversine = auto()\n</code></pre> <p>Determine the length of a geometry using the haversine formula.</p> <p>Note: this implementation uses a mean earth radius of 6371.088 km, based on the recommendation of the IUGG</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.LengthMethod.Vincenty","title":"Vincenty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Vincenty = auto()\n</code></pre> <p>Determine the length of a geometry using Vincenty's formulae.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.RotateOrigin","title":"RotateOrigin","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.RotateOrigin.Center","title":"Center  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Center = auto()\n</code></pre> <p>Use the center of a geometry for rotation</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.RotateOrigin.Centroid","title":"Centroid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Centroid = auto()\n</code></pre> <p>Use the centroid of a geometry for rotation</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.SimplifyMethod","title":"SimplifyMethod","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.SimplifyMethod.RDP","title":"RDP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RDP = auto()\n</code></pre> <p>Use the Ramer-Douglas-Peucker algorithm for LineString simplificatino.</p> <p>Polygons are simplified by running the RDP algorithm on all their constituent rings. This may result in invalid Polygons, and has no guarantee of preserving topology.</p> <p>Multi* objects are simplified by simplifying all their constituent geometries individually.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.SimplifyMethod.VW","title":"VW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VW = auto()\n</code></pre> <p>Use the Visvalingam-Whyatt algorithm for LineString simplification.</p> <p>See here for a graphical explanation Polygons are simplified by running the algorithm on all their constituent rings.</p> <p>This may result in invalid Polygons, and has no guarantee of preserving topology. Multi* objects are simplified by simplifying all their constituent geometries individually.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.SimplifyMethod.VW_Preserve","title":"VW_Preserve  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VW_Preserve = auto()\n</code></pre> <p>Use a topology-preserving variant of the Visvalingam-Whyatt algorithm for LineString simplification.</p> <p>See here for a graphical explanation.</p> <p>The topology-preserving algorithm uses an R* tree to efficiently find candidate line segments which are tested for intersection with a given triangle. If intersections are found, the previous point (i.e. the left component of the current triangle) is also removed, altering the geometry and removing the intersection.</p>"},{"location":"api/compute/enums/#geoarrow.rust.compute.enums.SimplifyMethod.VW_Preserve--notes","title":"Notes","text":"<ul> <li>It is possible for the simplification algorithm to displace a Polygon's interior   ring outside its shell.</li> <li>The algorithm does not guarantee a valid output geometry, especially on   smaller geometries.</li> <li>If removal of a point causes a self-intersection, but the geometry only has <code>n +   1</code> points remaining (3 for a <code>LineString</code>, 5 for a <code>Polygon</code>), the point is   retained and the simplification process ends. This is because there is no   guarantee that removal of two points will remove the intersection, but removal of   further points would leave too few points to form a valid geometry.</li> <li>The tolerance used to remove a point is <code>epsilon</code>, in keeping with GEOS. JTS uses   <code>epsilon ^ 2</code></li> </ul>"},{"location":"api/compute/functions/","title":"Functions","text":""},{"location":"api/compute/functions/#arraychunked-array-functions","title":"Array/Chunked Array functions","text":""},{"location":"api/compute/functions/#geoarrow.rust.compute","title":"geoarrow.rust.compute","text":""},{"location":"api/compute/functions/#geoarrow.rust.compute.affine_transform","title":"affine_transform","text":"<pre><code>affine_transform(\n    input: ArrowArrayExportable, transform: AffineTransform\n) -&gt; GeoArray\n</code></pre><pre><code>affine_transform(\n    input: ArrowStreamExportable, transform: AffineTransform\n) -&gt; GeoChunkedArray\n</code></pre> <pre><code>affine_transform(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    transform: AffineTransform,\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Apply an affine transformation to geometries.</p> <p>This is intended to be equivalent to <code>shapely.affinity.affine_transform</code> for 2D transforms.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array other: an affine transformation to apply to all geometries.</p> <p>This integrates with the <code>affine</code> Python library, and most users should use that integration, though it allows any input that is a tuple with 6 or 9 float values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>New GeoArrow array or chunked array with the same type as input and with</p> </li> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>transformed coordinates.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.area","title":"area","text":"<pre><code>area(\n    input: ArrowArrayExportable, *, method: AreaMethod | AreaMethodT = Euclidean\n) -&gt; Array\n</code></pre><pre><code>area(\n    input: ArrowStreamExportable,\n    *,\n    method: AreaMethod | AreaMethodT = Euclidean\n) -&gt; ChunkedArray\n</code></pre> <pre><code>area(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    *,\n    method: AreaMethod | AreaMethodT = Euclidean\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Determine the area of an array of geometries</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>               (<code>AreaMethod | AreaMethodT</code>)           \u2013            <p>The method to use for area calculation. One of \"Ellipsoidal\", \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array or chunked array with area values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.center","title":"center","text":"<pre><code>center(input: ArrowArrayExportable) -&gt; GeoArray\n</code></pre><pre><code>center(input: ArrowStreamExportable) -&gt; GeoChunkedArray\n</code></pre> <pre><code>center(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Compute the center of geometries</p> <p>This first computes the axis-aligned bounding rectangle, then takes the center of that box</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>Array or chunked array with center values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.centroid","title":"centroid","text":"<pre><code>centroid(input: ArrowArrayExportable) -&gt; GeoArray\n</code></pre><pre><code>centroid(input: ArrowStreamExportable) -&gt; GeoChunkedArray\n</code></pre> <pre><code>centroid(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Calculation of the centroid.</p> <p>The centroid is the arithmetic mean position of all points in the shape. Informally, it is the point at which a cutout of the shape could be perfectly balanced on the tip of a pin.</p> <p>The geometric centroid of a convex object always lies in the object. A non-convex object might have a centroid that is outside the object itself.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>Array or chunked array with centroid values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.chaikin_smoothing","title":"chaikin_smoothing","text":"<pre><code>chaikin_smoothing(input: ArrowArrayExportable, n_iterations: int) -&gt; GeoArray\n</code></pre><pre><code>chaikin_smoothing(\n    input: ArrowStreamExportable, n_iterations: int\n) -&gt; GeoChunkedArray\n</code></pre> <pre><code>chaikin_smoothing(\n    input: ArrowArrayExportable | ArrowStreamExportable, n_iterations: int\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Smoothen <code>LineString</code>, <code>Polygon</code>, <code>MultiLineString</code> and <code>MultiPolygon</code> using Chaikins algorithm.</p> <p>Chaikins smoothing algorithm</p> <p>Each iteration of the smoothing doubles the number of vertices of the geometry, so in some cases it may make sense to apply a simplification afterwards to remove insignificant coordinates.</p> <p>This implementation preserves the start and end vertices of an open linestring and smoothes the corner between start and end of a closed linestring.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array n_iterations: Number of iterations to use for smoothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>Smoothed geometry array or chunked geometry array.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.convex_hull","title":"convex_hull","text":"<pre><code>convex_hull(input: ArrowArrayExportable) -&gt; GeoArray\n</code></pre><pre><code>convex_hull(input: ArrowStreamExportable) -&gt; GeoChunkedArray\n</code></pre> <pre><code>convex_hull(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Returns the convex hull of a Polygon. The hull is always oriented counter-clockwise.</p> <p>This implementation uses the QuickHull algorithm, based on Barber, C. Bradford; Dobkin, David P.; Huhdanpaa, Hannu (1 December 1996) Original paper here: www.cs.princeton.edu/~dpd/Papers/BarberDobkinHuhdanpaa.pdf</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>Array with convex hull polygons.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.densify","title":"densify","text":"<pre><code>densify(input: ArrowArrayExportable, max_distance: float) -&gt; GeoArray\n</code></pre><pre><code>densify(input: ArrowStreamExportable, max_distance: float) -&gt; GeoChunkedArray\n</code></pre> <pre><code>densify(\n    input: ArrowArrayExportable, max_distance: float\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Return a new linear geometry containing both existing and new interpolated coordinates with a maximum distance of <code>max_distance</code> between them.</p> <p>Note: <code>max_distance</code> must be greater than 0.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable</code>)           \u2013            <p>input geometry array</p> </li> <li> <code>max_distance</code>               (<code>float</code>)           \u2013            <p>maximum distance between coordinates</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>Densified geometry array</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.envelope","title":"envelope","text":"<pre><code>envelope(input: ArrowArrayExportable) -&gt; GeoArray\n</code></pre><pre><code>envelope(input: ArrowStreamExportable) -&gt; GeoChunkedArray\n</code></pre> <pre><code>envelope(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Computes the minimum axis-aligned bounding box that encloses an input geometry</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>Array with axis-aligned bounding boxes.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.frechet_distance","title":"frechet_distance","text":"<pre><code>frechet_distance(\n    input: ArrowArrayExportable, other: BroadcastGeometry\n) -&gt; Array\n</code></pre><pre><code>frechet_distance(\n    input: ArrowStreamExportable, other: BroadcastGeometry\n) -&gt; ChunkedArray\n</code></pre> <pre><code>frechet_distance(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    other: BroadcastGeometry,\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Determine the similarity between two arrays of <code>LineStrings</code> using the [Frechet distance].</p> <p>The Fr\u00e9chet distance is a measure of similarity: it is the greatest distance between any point in A and the closest point in B. The discrete distance is an approximation of this metric: only vertices are considered. The parameter \u2018densify\u2019 makes this approximation less coarse by splitting the line segments between vertices before computing the distance.</p> <p>Fr\u00e9chet distance sweep continuously along their respective curves and the direction of curves is significant. This makes it a better measure of similarity than Hausdorff distance for curve or surface matching.</p> <p>This implementation is based on [Computing Discrete Frechet Distance] by T. Eiter and H. Mannila.</p> <p>[Frechet distance]: en.wikipedia.org/wiki/Fr%C3%A9chet_distance [Computing Discrete Frechet Distance]: www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array other: the geometry or geometry array to compare against. This must contain geometries of <code>LineString</code> type. A variety of inputs are accepted:</p> <ul> <li>Any Python class that implements the Geo Interface, such as a <code>shapely</code>   LineString</li> <li>Any GeoArrow array or chunked array of <code>LineString</code> type</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array or chunked array with float distance values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.geodesic_perimeter","title":"geodesic_perimeter","text":"<pre><code>geodesic_perimeter(input: ArrowArrayExportable) -&gt; Array\n</code></pre><pre><code>geodesic_perimeter(input: ArrowStreamExportable) -&gt; ChunkedArray\n</code></pre> <pre><code>geodesic_perimeter(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Determine the perimeter of a geometry on an ellipsoidal model of the earth.</p> <p>This uses the geodesic measurement methods given by Karney (2013).</p> <p>For a polygon this returns the sum of the perimeter of the exterior ring and interior rings. To get the perimeter of just the exterior ring of a polygon, do <code>polygon.exterior().geodesic_length()</code>.</p>"},{"location":"api/compute/functions/#geoarrow.rust.compute.geodesic_perimeter--units","title":"Units","text":"<ul> <li>return value: meter</li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array with output values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.is_empty","title":"is_empty","text":"<pre><code>is_empty(input: ArrowArrayExportable) -&gt; Array\n</code></pre><pre><code>is_empty(input: ArrowStreamExportable) -&gt; ChunkedArray\n</code></pre> <pre><code>is_empty(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Returns True if a geometry is an empty point, polygon, etc.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Result array.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.length","title":"length","text":"<pre><code>length(\n    input: ArrowArrayExportable,\n    *,\n    method: LengthMethod | LengthMethodT = Euclidean\n) -&gt; Array\n</code></pre><pre><code>length(\n    input: ArrowStreamExportable,\n    *,\n    method: LengthMethod | LengthMethodT = Euclidean\n) -&gt; ChunkedArray\n</code></pre> <pre><code>length(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    *,\n    method: LengthMethod | LengthMethodT = Euclidean\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Calculation of the length of a Line</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>               (<code>LengthMethod | LengthMethodT</code>)           \u2013            <p>The method to use for length calculation. One of \"Ellipsoidal\", \"Euclidean\", \"Haversine\", or \"Vincenty\". Refer to the documentation on LengthMethod for more information. Defaults to LengthMethod.Euclidean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array or chunked array with length values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.line_interpolate_point","title":"line_interpolate_point","text":"<pre><code>line_interpolate_point(\n    input: ArrowArrayExportable,\n    fraction: float | int | ArrowArrayExportable | NumpyArrayProtocolf64,\n) -&gt; GeoArray\n</code></pre><pre><code>line_interpolate_point(\n    input: ArrowStreamExportable, fraction: float | int | ArrowStreamExportable\n) -&gt; GeoChunkedArray\n</code></pre> <pre><code>line_interpolate_point(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    fraction: (\n        float\n        | int\n        | ArrowArrayExportable\n        | ArrowStreamExportable\n        | NumpyArrayProtocolf64\n    ),\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Returns a point interpolated at given distance on a line.</p> <p>This is intended to be equivalent to <code>shapely.line_interpolate_point</code> when <code>normalized=True</code>.</p> <p>If the given fraction is</p> <ul> <li>less than zero (including negative infinity): returns the starting point</li> <li>greater than one (including infinity): returns the ending point</li> <li>If either the fraction is NaN, or any coordinates of the line are not finite, returns <code>Point EMPTY</code>.</li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> <li> <code>fraction</code>               (<code>float | int | ArrowArrayExportable | ArrowStreamExportable | NumpyArrayProtocolf64</code>)           \u2013            <p>the fractional distance along the line. A variety of inputs are accepted:</p> <ul> <li>A Python <code>float</code> or <code>int</code></li> <li>A numpy <code>ndarray</code> with <code>float64</code> data type.</li> <li>An Arrow array or chunked array with <code>float64</code> data type.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>PointArray or ChunkedPointArray with result values</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.line_locate_point","title":"line_locate_point","text":"<pre><code>line_locate_point(\n    input: ArrowArrayExportable,\n    point: GeoInterfaceProtocol | ArrowArrayExportable,\n) -&gt; Array\n</code></pre><pre><code>line_locate_point(\n    input: ArrowStreamExportable,\n    point: GeoInterfaceProtocol | ArrowStreamExportable,\n) -&gt; ChunkedArray\n</code></pre> <pre><code>line_locate_point(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    point: GeoInterfaceProtocol | ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Returns a fraction of the line's total length representing the location of the closest point on the line to the given point.</p> <p>This is intended to be equivalent to <code>shapely.line_locate_point</code> when <code>normalized=True</code>.</p> <p>If the line has zero length the fraction returned is zero.</p> <p>If either the point's coordinates or any coordinates of the line are not finite, returns <code>NaN</code>.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> <li> <code>point</code>               (<code>GeoInterfaceProtocol | ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>the fractional distance along the line. A variety of inputs are accepted:</p> <ul> <li>A scalar <code>GeoScalar</code></li> <li>A <code>GeoArray</code></li> <li>A <code>GeoChunkedArray</code></li> <li>Any Python class that implements the Geo Interface, such as a <code>shapely</code> Point</li> <li>Any GeoArrow array or chunked array of <code>Point</code> type</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array or chunked array with float fraction values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.polylabel","title":"polylabel","text":"<pre><code>polylabel(input: ArrowArrayExportable, tolerance: float) -&gt; GeoArray\n</code></pre><pre><code>polylabel(input: ArrowStreamExportable, tolerance: float) -&gt; GeoChunkedArray\n</code></pre> <pre><code>polylabel(\n    input: ArrowArrayExportable | ArrowStreamExportable, tolerance: float\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Calculate a Polygon's ideal label position by calculating its pole of inaccessibility.</p> <p>The pole of inaccessibility is the most distant internal point from the polygon outline (not to be confused with centroid), and is useful for optimal placement of a text label on a polygon.</p> <p>The calculation uses an iterative grid-based algorithm, ported from the original JavaScript implementation.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> <li> <code>tolerance</code>               (<code>float</code>)           \u2013            <p>precision of algorithm. Refer to the original JavaScript documentation for more information</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>PointArray or ChunkedPointArray with result values</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.rotate","title":"rotate","text":"<pre><code>rotate(\n    geom: ArrowArrayExportable,\n    angle: float,\n    *,\n    origin: RotateOrigin | RotateOriginT | tuple[float, float]\n) -&gt; GeoArray\n</code></pre><pre><code>rotate(\n    geom: ArrowStreamExportable,\n    angle: float,\n    *,\n    origin: RotateOrigin | RotateOriginT | tuple[float, float]\n) -&gt; GeoChunkedArray\n</code></pre> <pre><code>rotate(\n    geom: ArrowArrayExportable | ArrowStreamExportable,\n    angle: float,\n    *,\n    origin: RotateOrigin | RotateOriginT | tuple[float, float]\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre>"},{"location":"api/compute/functions/#geoarrow.rust.compute.scale","title":"scale","text":"<pre><code>scale(geom: ArrowArrayExportable, xfact: float, yfact: float) -&gt; GeoArray\n</code></pre><pre><code>scale(\n    geom: ArrowStreamExportable, xfact: float, yfact: float\n) -&gt; GeoChunkedArray\n</code></pre> <pre><code>scale(\n    geom: ArrowArrayExportable | ArrowStreamExportable,\n    xfact: float,\n    yfact: float,\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Returns a scaled geometry, scaled by factors along each dimension.</p> <p>Parameters:</p> <ul> <li> <code>geom</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>description</p> </li> <li> <code>xfact</code>               (<code>float</code>)           \u2013            <p>description</p> </li> <li> <code>yfact</code>               (<code>float</code>)           \u2013            <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.signed_area","title":"signed_area","text":"<pre><code>signed_area(\n    input: ArrowArrayExportable, *, method: AreaMethod | AreaMethodT = Euclidean\n) -&gt; Array\n</code></pre><pre><code>signed_area(\n    input: ArrowStreamExportable,\n    *,\n    method: AreaMethod | AreaMethodT = Euclidean\n) -&gt; ChunkedArray\n</code></pre> <pre><code>signed_area(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    *,\n    method: AreaMethod | AreaMethodT = Euclidean\n) -&gt; Array | ChunkedArray\n</code></pre> <p>Signed area of a geometry array</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array or chunked geometry array</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>               (<code>AreaMethod | AreaMethodT</code>)           \u2013            <p>The method to use for area calculation. One of \"Ellipsoidal\" \"Euclidean\", or \"Spherical\". Refer to the documentation on AreaMethod for more information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ChunkedArray</code>           \u2013            <p>Array or chunked array with area values.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.simplify","title":"simplify","text":"<pre><code>simplify(\n    input: ArrowArrayExportable,\n    epsilon: float,\n    *,\n    method: SimplifyMethod | SimplifyMethodT = RDP\n) -&gt; GeoArray\n</code></pre><pre><code>simplify(\n    input: ArrowStreamExportable,\n    epsilon: float,\n    *,\n    method: SimplifyMethod | SimplifyMethodT = RDP\n) -&gt; GeoChunkedArray\n</code></pre> <pre><code>simplify(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    epsilon: float,\n    *,\n    method: SimplifyMethod | SimplifyMethodT = RDP\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Simplifies a geometry.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> <li> <code>epsilon</code>               (<code>float</code>)           \u2013            <p>tolerance for simplification. An epsilon less than or equal to zero will return an unaltered version of the geometry.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>method</code>               (<code>SimplifyMethod | SimplifyMethodT</code>)           \u2013            <p>The method to use for simplification calculation. One of <code>\"rdp\"</code>, <code>\"vw\"</code>, or <code>\"vw_preserve\"</code>. Refer to the documentation on SimplifyMethod for more information. Defaults to SimplifyMethod.RDP.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>Simplified geometry array.</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.skew","title":"skew","text":"<pre><code>skew(geom: ArrowArrayExportable, xs: float, ys: float) -&gt; GeoArray\n</code></pre><pre><code>skew(geom: ArrowStreamExportable, xs: float, ys: float) -&gt; GeoChunkedArray\n</code></pre> <pre><code>skew(\n    geom: ArrowArrayExportable | ArrowStreamExportable, xs: float, ys: float\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Skew a geometry from it's bounding box center, using different values for <code>xs</code> and <code>ys</code> to distort the geometry's aspect ratio.</p> <p>Parameters:</p> <ul> <li> <code>geom</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>description</p> </li> <li> <code>xs</code>               (<code>float</code>)           \u2013            <p>description</p> </li> <li> <code>ys</code>               (<code>float</code>)           \u2013            <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.total_bounds","title":"total_bounds","text":"<pre><code>total_bounds(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Computes the total bounds (extent) of the geometry.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>input geometry array</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[float, float, float, float]</code>           \u2013            <p>tuple of (xmin, ymin, xmax, ymax).</p> </li> </ul>"},{"location":"api/compute/functions/#geoarrow.rust.compute.translate","title":"translate","text":"<pre><code>translate(geom: ArrowArrayExportable, xoff: float, yoff: float) -&gt; GeoArray\n</code></pre><pre><code>translate(\n    geom: ArrowStreamExportable, xoff: float, yoff: float\n) -&gt; GeoChunkedArray\n</code></pre> <pre><code>translate(\n    geom: ArrowArrayExportable | ArrowStreamExportable, xoff: float, yoff: float\n) -&gt; GeoArray | GeoChunkedArray\n</code></pre> <p>Returns a scaled geometry, scaled by factors along each dimension.</p> <p>Parameters:</p> <ul> <li> <code>geom</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>description</p> </li> <li> <code>xoff</code>               (<code>float</code>)           \u2013            <p>description</p> </li> <li> <code>yoff</code>               (<code>float</code>)           \u2013            <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoChunkedArray</code>           \u2013            <p>description</p> </li> </ul>"},{"location":"api/compute/functions/#table-functions","title":"Table functions","text":""},{"location":"api/compute/functions/#geoarrow.rust.compute","title":"geoarrow.rust.compute","text":""},{"location":"api/compute/functions/#geoarrow.rust.compute.explode","title":"explode","text":"<pre><code>explode(input: ArrowStreamExportable) -&gt; Table\n</code></pre> <p>Explode a table.</p> <p>This is intended to be equivalent to the <code>explode</code> function in GeoPandas.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowStreamExportable</code>)           \u2013            <p>input table</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A new table with multi-part geometries exploded to separate rows.</p> </li> </ul>"},{"location":"api/compute/types/","title":"Types","text":""},{"location":"api/compute/types/#geoarrow.rust.compute.types","title":"geoarrow.rust.compute.types","text":""},{"location":"api/compute/types/#geoarrow.rust.compute.types.AreaMethodT","title":"AreaMethodT  <code>module-attribute</code>","text":"<pre><code>AreaMethodT = Literal['ellipsoidal', 'euclidean', 'spherical']\n</code></pre> <p>Acceptable strings to be passed into the <code>method</code> parameter for <code>area</code> and <code>signed_area</code>.</p>"},{"location":"api/compute/types/#geoarrow.rust.compute.types.LengthMethodT","title":"LengthMethodT  <code>module-attribute</code>","text":"<pre><code>LengthMethodT = Literal['ellipsoidal', 'euclidean', 'haversine', 'vincenty']\n</code></pre> <p>Acceptable strings to be passed into the <code>method</code> parameter for <code>length</code>.</p>"},{"location":"api/compute/types/#geoarrow.rust.compute.types.RotateOriginT","title":"RotateOriginT  <code>module-attribute</code>","text":"<pre><code>RotateOriginT = Literal['center', 'centroid']\n</code></pre> <p>Acceptable strings to be passed into the <code>origin</code> parameter for <code>rotate</code>.</p>"},{"location":"api/compute/types/#geoarrow.rust.compute.types.SimplifyMethodT","title":"SimplifyMethodT  <code>module-attribute</code>","text":"<pre><code>SimplifyMethodT = Literal['rdp', 'vw', 'vw_preserve']\n</code></pre> <p>Acceptable strings to be passed into the <code>method</code> parameter for <code>simplify</code>.</p>"},{"location":"api/compute/types/#geoarrow.rust.compute.types.GeoInterfaceProtocol","title":"GeoInterfaceProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>A scalar geometry that implements the Geo Interface protocol.</p>"},{"location":"api/compute/types/#geoarrow.rust.compute.types.NumpyArrayProtocolf64","title":"NumpyArrayProtocolf64","text":"<p>               Bases: <code>Protocol</code></p> <p>An object that implements the numpy array method.</p>"},{"location":"api/core/","title":"<code>geoarrow.rust.core</code>","text":"<p>All functionality described within this directory are part of the <code>geoarrow.rust.core</code> submodule. To use, install the <code>geoarrow-rust-core</code> PyPI package:</p> <pre><code>pip install geoarrow-rust-core\n</code></pre>"},{"location":"api/core/array/","title":"Array","text":""},{"location":"api/core/array/#geoarrow.rust.core.GeoArray","title":"geoarrow.rust.core.GeoArray","text":""},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.null_count","title":"null_count  <code>property</code>","text":"<pre><code>null_count: int\n</code></pre> <p>The number of null values in the array.</p>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.type","title":"type  <code>property</code>","text":"<pre><code>type: GeoType\n</code></pre> <p>The type of the array.</p>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.__arrow_c_array__","title":"__arrow_c_array__","text":"<pre><code>__arrow_c_array__(\n    requested_schema: object | None = None,\n) -&gt; tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.__eq__","title":"__eq__","text":"<pre><code>__eq__(value: object) -&gt; bool\n</code></pre>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(item: int) -&gt; GeoScalar\n</code></pre>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.__init__","title":"__init__","text":"<pre><code>__init__(data: ArrowArrayExportable) -&gt; None\n</code></pre> <p>Create a new GeoArray.</p> <p>At the moment this is solely an alias for <code>from_arrow()</code>.</p>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.cast","title":"cast","text":"<pre><code>cast(to_type: GeoType) -&gt; GeoArray\n</code></pre> <p>Cast to another <code>GeoType</code>.</p>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.cast--criteria","title":"Criteria:","text":"<ul> <li>Dimension must be compatible:<ul> <li>If the source array and destination type are both dimension-aware, then   their dimensions must match.</li> <li>Casts from dimension-aware to dimensionless arrays (<code>GeometryArray</code>,   <code>WkbArray</code>, <code>WkbViewArray</code>, <code>WktArray</code>, <code>WktViewArray</code>) are always   allowed.</li> </ul> </li> <li>GeoArrow metadata (i.e. CRS and edges) on the source and destination types must match.</li> </ul>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.cast--infallible-casts","title":"Infallible casts:","text":"<p>As long as the above criteria are met, these casts will always succeed without erroring.</p> <ul> <li>The same geometry type with different coord types.</li> <li>Any source array type to <code>Geometry</code>, <code>Wkb</code>, <code>LargeWkb</code>, <code>WkbView</code>, <code>Wkt</code>,   <code>LargeWkt</code>, or <code>WktView</code>.</li> <li><code>Point</code> to <code>MultiPoint</code></li> <li><code>LineString</code> to <code>MultiLineString</code></li> <li><code>Polygon</code> to <code>MultiPolygon</code></li> </ul>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.cast--fallible-casts","title":"Fallible casts:","text":"<ul> <li><code>Geometry</code> to any other native type.</li> <li>Parsing <code>WKB</code> or <code>WKT</code> to any native type other than <code>Geometry</code>.</li> <li><code>MultiPoint</code> to <code>Point</code></li> <li><code>MultiLineString</code> to <code>LineString</code></li> <li><code>MultiPolygon</code> to <code>Polygon</code></li> </ul>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.downcast","title":"downcast","text":"<pre><code>downcast(*, coord_type: CoordTypeInput = SEPARATED) -&gt; GeoArray\n</code></pre> <p>Downcast to its simplest, most-compact native geometry representation.</p> <p>If there is no simpler representation, the array is returned unchanged.</p>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.from_arrow","title":"from_arrow  <code>classmethod</code>","text":"<pre><code>from_arrow(data: ArrowArrayExportable) -&gt; GeoArray\n</code></pre> <p>Import an array from an Arrow array object.</p> <p>This uses the Arrow PyCapsule interface to import the array, so any producer that implements the protocol is supported.</p> <p>The existing array must have associated GeoArrow metadata.</p>"},{"location":"api/core/array/#geoarrow.rust.core.GeoArray.from_arrow_pycapsule","title":"from_arrow_pycapsule  <code>classmethod</code>","text":"<pre><code>from_arrow_pycapsule(schema_capsule: object, array_capsule: object) -&gt; GeoArray\n</code></pre>"},{"location":"api/core/chunked_array/","title":"Chunked Array","text":""},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray","title":"geoarrow.rust.core.GeoChunkedArray","text":"<p>A chunked GeoArrow array.</p> <p>This class is used to handle chunked arrays in GeoArrow, which can be composed of multiple chunks of data.</p>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.null_count","title":"null_count  <code>property</code>","text":"<pre><code>null_count: int\n</code></pre> <p>The number of null values in the chunked array.</p>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.num_chunks","title":"num_chunks  <code>property</code>","text":"<pre><code>num_chunks: int\n</code></pre> <p>Return the number of chunks in the array.</p>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.type","title":"type  <code>property</code>","text":"<pre><code>type: GeoType\n</code></pre> <p>Return the type of the chunked array.</p>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.__arrow_c_stream__","title":"__arrow_c_stream__","text":"<pre><code>__arrow_c_stream__(requested_schema: object | None = None) -&gt; object\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.chunked_array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.__eq__","title":"__eq__","text":"<pre><code>__eq__(value: object) -&gt; bool\n</code></pre>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(item: int) -&gt; GeoScalar\n</code></pre>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.__init__","title":"__init__","text":"<pre><code>__init__(\n    arrays: ArrowArrayExportable | ArrowStreamExportable, type: None = None\n) -&gt; None\n</code></pre><pre><code>__init__(\n    arrays: Sequence[ArrowArrayExportable],\n    type: ArrowSchemaExportable | None = None,\n) -&gt; None\n</code></pre> <pre><code>__init__(\n    arrays: (\n        ArrowArrayExportable\n        | ArrowStreamExportable\n        | Sequence[ArrowArrayExportable]\n    ),\n    type: ArrowSchemaExportable | None = None,\n) -&gt; None\n</code></pre> <p>Construct a new GeoChunkedArray.</p> <p>Parameters:</p> <ul> <li> <code>arrays</code>               (<code>ArrowArrayExportable | ArrowStreamExportable | Sequence[ArrowArrayExportable]</code>)           \u2013            <p>description</p> </li> <li> <code>type</code>               (<code>ArrowSchemaExportable | None</code>, default:                   <code>None</code> )           \u2013            <p>description. Defaults to None.</p> </li> </ul>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.cast","title":"cast","text":"<pre><code>cast(to_type: GeoType) -&gt; GeoChunkedArray\n</code></pre> <p>Cast to another <code>GeoType</code>.</p>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.cast--criteria","title":"Criteria:","text":"<ul> <li>Dimension must be compatible:<ul> <li>If the source array and destination type are both dimension-aware, then   their dimensions must match.</li> <li>Casts from dimension-aware to dimensionless arrays (<code>GeometryArray</code>,   <code>WkbArray</code>, <code>WkbViewArray</code>, <code>WktArray</code>, <code>WktViewArray</code>) are always   allowed.</li> </ul> </li> <li>GeoArrow metadata (i.e. CRS and edges) on the source and destination types must match.</li> </ul>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.cast--infallible-casts","title":"Infallible casts:","text":"<p>As long as the above criteria are met, these casts will always succeed without erroring.</p> <ul> <li>The same geometry type with different coord types.</li> <li>Any source array type to <code>Geometry</code>, <code>Wkb</code>, <code>LargeWkb</code>, <code>WkbView</code>, <code>Wkt</code>,   <code>LargeWkt</code>, or <code>WktView</code>.</li> <li><code>Point</code> to <code>MultiPoint</code></li> <li><code>LineString</code> to <code>MultiLineString</code></li> <li><code>Polygon</code> to <code>MultiPolygon</code></li> </ul>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.cast--fallible-casts","title":"Fallible casts:","text":"<ul> <li><code>Geometry</code> to any other native type.</li> <li>Parsing <code>WKB</code> or <code>WKT</code> to any native type other than <code>Geometry</code>.</li> <li><code>MultiPoint</code> to <code>Point</code></li> <li><code>MultiLineString</code> to <code>LineString</code></li> <li><code>MultiPolygon</code> to <code>Polygon</code></li> </ul>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.chunk","title":"chunk","text":"<pre><code>chunk(i: int) -&gt; GeoArray\n</code></pre> <p>Return the i-th chunk of the array.</p>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.chunks","title":"chunks","text":"<pre><code>chunks() -&gt; list[GeoArray]\n</code></pre> <p>Return all chunks of the array.</p>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.downcast","title":"downcast","text":"<pre><code>downcast(*, coord_type: CoordTypeInput = SEPARATED) -&gt; GeoChunkedArray\n</code></pre> <p>Downcast to its simplest, most-compact native geometry representation.</p> <p>If there is no simpler representation, the array is returned unchanged.</p>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.from_arrow","title":"from_arrow  <code>classmethod</code>","text":"<pre><code>from_arrow(data: ArrowStreamExportable) -&gt; GeoChunkedArray\n</code></pre> <p>Import from an Arrow chunked array/stream object.</p> <p>This uses the Arrow PyCapsule interface to import the array, so any producer that implements the protocol is supported.</p> <p>The existing array must have associated GeoArrow metadata.</p>"},{"location":"api/core/chunked_array/#geoarrow.rust.core.GeoChunkedArray.from_arrow_pycapsule","title":"from_arrow_pycapsule  <code>classmethod</code>","text":"<pre><code>from_arrow_pycapsule(capsule: object) -&gt; GeoChunkedArray\n</code></pre>"},{"location":"api/core/constructors/","title":"Constructors","text":""},{"location":"api/core/constructors/#geoarrow.rust.core","title":"geoarrow.rust.core","text":""},{"location":"api/core/constructors/#geoarrow.rust.core.CoordsInput","title":"CoordsInput  <code>module-attribute</code>","text":"<pre><code>CoordsInput = ArrayInput | Tuple[ArrayInput, ...] | List[ArrayInput]\n</code></pre> <p>Allowed coordinate input types.</p> <p>Supported input:</p> <ul> <li>Tuple or list of arrays, with each element being a primitive array containing a single coordinate dimension: <code>(x, y)</code> or <code>(x, y, z)</code>. This will create a \"separated\" GeoArrow coordinate array. Each of these underlying arrays can be an Arrow or Numpy array.</li> <li>An Arrow fixed size list array with list size 2 or 3. This will create an \"interleaved\" GeoArrow coordinate array.</li> <li>A Numpy array of shape <code>(N, 2)</code> or <code>(N, 3)</code>. This will create an \"interleaved\" GeoArrow coordinate array. The array must be in C contiguous order.</li> </ul> <p>Only float64 is supported as the numeric type of the coordinate arrays.</p>"},{"location":"api/core/constructors/#geoarrow.rust.core.points","title":"points","text":"<pre><code>points(coords: CoordsInput, *, crs: CRSInput | None = None) -&gt; GeoArray\n</code></pre> <p>Create a GeoArrow point array from parts.</p> <p>This is similar in principle to <code>shapely.points</code>.</p> <p>Parameters:</p> <ul> <li> <code>coords</code>               (<code>CoordsInput</code>)           \u2013            <p>Supported coordinate input, see <code>CoordsInput</code> for more information.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>The CRS to apply to the array. Defaults to None.</p> </li> </ul> <p>Examples:</p> <pre><code>import numpy as np\nfrom geoarrow.rust.core import points\n\n# Creating a point array with interleaved coordinates\ncoords = np.random.rand(10, 2)\npoint_arr = points(coords)\n\n# Creating a point array with separated coordinates\nx_coords = np.random.rand(10)\ny_coords = np.random.rand(10)\npoint_arr = points([x_coords, y_coords])\n\n# Creating a 3D point array with separated coordinates\nx_coords = np.random.rand(10)\ny_coords = np.random.rand(10)\nz_coords = np.random.rand(10)\npoint_arr = points([x_coords, y_coords, z_coords])\n</code></pre>"},{"location":"api/core/constructors/#geoarrow.rust.core.linestrings","title":"linestrings","text":"<pre><code>linestrings(\n    coords: CoordsInput,\n    geom_offsets: ArrayInput,\n    *,\n    crs: CRSInput | None = None\n) -&gt; GeoArray\n</code></pre> <p>Create a GeoArrow linestring array from parts.</p> <p>This is similar in principle to <code>shapely.linestrings</code>.</p> <p>Parameters:</p> <ul> <li> <code>coords</code>               (<code>CoordsInput</code>)           \u2013            <p>Supported coordinate input, see <code>CoordsInput</code> for more information.</p> </li> <li> <code>geom_offsets</code>               (<code>ArrayInput</code>)           \u2013            <p>The geometry offsets. Refer to the GeoArrow spec for more information.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>The CRS to apply to the array. Defaults to None.</p> </li> </ul> <p>Examples:</p> <pre><code>import numpy as np\nfrom geoarrow.rust.core import linestrings\n\ncoords = np.random.rand(10, 2)\n# The first LineString has 2 coordinates, the second and third LineString each\n# have 4 coordinates.\ngeom_offsets = np.array([0, 2, 6, 10], dtype=np.int32)\ngeom_arr = linestrings(coords, geom_offsets)\n</code></pre>"},{"location":"api/core/constructors/#geoarrow.rust.core.polygons","title":"polygons","text":"<pre><code>polygons(\n    coords: CoordsInput,\n    geom_offsets: ArrayInput,\n    ring_offsets: ArrayInput,\n    *,\n    crs: CRSInput | None = None\n) -&gt; GeoArray\n</code></pre> <p>Create a GeoArrow polygon array from coordinates.</p> <p>This is similar in principle to <code>shapely.polygons</code>.</p> <p>Parameters:</p> <ul> <li> <code>coords</code>               (<code>CoordsInput</code>)           \u2013            <p>Supported coordinate input, see <code>CoordsInput</code> for more information.</p> </li> <li> <code>geom_offsets</code>               (<code>ArrayInput</code>)           \u2013            <p>The geometry offsets. Refer to the GeoArrow spec for more information.</p> </li> <li> <code>ring_offsets</code>               (<code>ArrayInput</code>)           \u2013            <p>The ring offsets. Refer to the GeoArrow spec for more information.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>The CRS to apply to the array. Defaults to None.</p> </li> </ul>"},{"location":"api/core/constructors/#geoarrow.rust.core.multipoints","title":"multipoints","text":"<pre><code>multipoints(\n    coords: CoordsInput,\n    geom_offsets: ArrayInput,\n    *,\n    crs: CRSInput | None = None\n) -&gt; GeoArray\n</code></pre> <p>Create a GeoArrow multipoint array from parts.</p> <p>This is similar in principle to <code>shapely.multipoints</code>.</p> <p>Parameters:</p> <ul> <li> <code>coords</code>               (<code>CoordsInput</code>)           \u2013            <p>Supported coordinate input, see <code>CoordsInput</code> for more information.</p> </li> <li> <code>geom_offsets</code>               (<code>ArrayInput</code>)           \u2013            <p>The geometry offsets. Refer to the GeoArrow spec for more information.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>The CRS to apply to the array. Defaults to None.</p> </li> </ul>"},{"location":"api/core/constructors/#geoarrow.rust.core.multilinestrings","title":"multilinestrings","text":"<pre><code>multilinestrings(\n    coords: CoordsInput,\n    geom_offsets: ArrayInput,\n    ring_offsets: ArrayInput,\n    *,\n    crs: CRSInput | None = None\n) -&gt; GeoArray\n</code></pre> <p>Create a GeoArrow multilinestring array from parts.</p> <p>Parameters:</p> <ul> <li> <code>coords</code>               (<code>CoordsInput</code>)           \u2013            <p>Supported coordinate input, see <code>CoordsInput</code> for more information.</p> </li> <li> <code>geom_offsets</code>               (<code>ArrayInput</code>)           \u2013            <p>The geometry offsets. Refer to the GeoArrow spec for more information.</p> </li> <li> <code>ring_offsets</code>               (<code>ArrayInput</code>)           \u2013            <p>The ring offsets. Refer to the GeoArrow spec for more information.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>The CRS to apply to the array. Defaults to None.</p> </li> </ul>"},{"location":"api/core/constructors/#geoarrow.rust.core.multipolygons","title":"multipolygons","text":"<pre><code>multipolygons(\n    coords: CoordsInput,\n    geom_offsets: ArrayInput,\n    polygon_offsets: ArrayInput,\n    ring_offsets: ArrayInput,\n    *,\n    crs: CRSInput | None = None\n) -&gt; GeoArray\n</code></pre> <p>Create a GeoArrow multipolygon array from parts.</p> <p>Parameters:</p> <ul> <li> <code>coords</code>               (<code>CoordsInput</code>)           \u2013            <p>Supported coordinate input, see <code>CoordsInput</code> for more information.</p> </li> <li> <code>geom_offsets</code>               (<code>ArrayInput</code>)           \u2013            <p>The geometry offsets. Refer to the GeoArrow spec for more information.</p> </li> <li> <code>polygon_offsets</code>               (<code>ArrayInput</code>)           \u2013            <p>The polygon offsets. Refer to the GeoArrow spec for more information.</p> </li> <li> <code>ring_offsets</code>               (<code>ArrayInput</code>)           \u2013            <p>The ring offsets. Refer to the GeoArrow spec for more information.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>The CRS to apply to the array. Defaults to None.</p> </li> </ul>"},{"location":"api/core/enums/","title":"Enums","text":""},{"location":"api/core/enums/#geoarrow.rust.core.enums","title":"geoarrow.rust.core.enums","text":""},{"location":"api/core/enums/#geoarrow.rust.core.enums.CoordType","title":"CoordType","text":"<p>               Bases: <code>StrEnum</code></p> <p>Available GeoArrow coordinate types.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.CoordType.INTERLEAVED","title":"INTERLEAVED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERLEAVED = 'interleaved'\n</code></pre> <p>Interleaved coordinate layout.</p> <p>All coordinates are stored in a single buffer, as <code>XYXYXY</code>.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.CoordType.SEPARATED","title":"SEPARATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SEPARATED = 'separated'\n</code></pre> <p>Separated coordinate layout.</p> <p>Coordinates are stored in a separate buffer per dimension, e.g. <code>XXXX</code> and <code>YYYY</code>.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.Dimension","title":"Dimension","text":"<p>               Bases: <code>StrEnum</code></p> <p>Geometry dimensions.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.Dimension.XY","title":"XY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XY = 'xy'\n</code></pre> <p>Two dimensions, X and Y</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.Dimension.XYM","title":"XYM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XYM = 'xym'\n</code></pre> <p>Three dimensions, X, Y, and M</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.Dimension.XYZ","title":"XYZ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XYZ = 'xyz'\n</code></pre> <p>Three dimensions, X, Y, and Z</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.Dimension.XYZM","title":"XYZM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XYZM = 'xyzm'\n</code></pre> <p>Four dimensions, X, Y, Z, and M</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.Edges","title":"Edges","text":"<p>               Bases: <code>StrEnum</code></p> <p>Edges.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.GeometryType","title":"GeometryType","text":"<p>               Bases: <code>IntEnum</code></p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.GeometryType.BOX","title":"BOX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOX = 990\n</code></pre> <p>Box geometry type.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.GeometryType.GEOMETRY","title":"GEOMETRY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GEOMETRY = 0\n</code></pre> <p>Unknown geometry type.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.GeometryType.GEOMETRYCOLLECTION","title":"GEOMETRYCOLLECTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GEOMETRYCOLLECTION = 7\n</code></pre> <p>Geometrycollection geometry type.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.GeometryType.LINESTRING","title":"LINESTRING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LINESTRING = 2\n</code></pre> <p>Linestring geometry type.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.GeometryType.MULTILINESTRING","title":"MULTILINESTRING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MULTILINESTRING = 5\n</code></pre> <p>Multilinestring geometry type.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.GeometryType.MULTIPOINT","title":"MULTIPOINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MULTIPOINT = 4\n</code></pre> <p>Multipoint geometry type.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.GeometryType.MULTIPOLYGON","title":"MULTIPOLYGON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MULTIPOLYGON = 6\n</code></pre> <p>Multipolygon geometry type.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.GeometryType.POINT","title":"POINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POINT = 1\n</code></pre> <p>Point geometry type.</p>"},{"location":"api/core/enums/#geoarrow.rust.core.enums.GeometryType.POLYGON","title":"POLYGON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POLYGON = 3\n</code></pre> <p>Polygon geometry type.</p>"},{"location":"api/core/functions/","title":"Functions","text":"<p>Interoperability with other Python geospatial libraries (Shapely, GeoPandas) and in-memory geospatial formats (WKB, WKT).</p>"},{"location":"api/core/functions/#geoarrow.rust.core.from_wkb","title":"geoarrow.rust.core.from_wkb","text":"<pre><code>from_wkb(\n    input: ArrowArrayExportable, to_type: ArrowSchemaExportable | None = None\n) -&gt; GeoArray\n</code></pre><pre><code>from_wkb(\n    input: ArrowStreamExportable, to_type: ArrowSchemaExportable | None = None\n) -&gt; GeoArrayReader\n</code></pre> <pre><code>from_wkb(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    to_type: ArrowSchemaExportable | None = None,\n) -&gt; GeoArray | GeoArrayReader\n</code></pre> <p>Parse the WKB <code>input</code> to the provided data type.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>Input data to parse.</p> </li> <li> <code>to_type</code>               (<code>ArrowSchemaExportable | None</code>, default:                   <code>None</code> )           \u2013            <p>The target data type to parse to. By default, parses to a Geometry type array (the output of <code>geoarrow.rust.core.geometry</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoArrayReader</code>           \u2013            <p>If <code>input</code> is an Array-like, a <code>GeoArray</code> will be returned. If <code>input</code> is a Stream-like (<code>ChunkedArray</code> or <code>ArrayReader</code>), a <code>GeoArrayReader</code> will be returned.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.from_wkt","title":"geoarrow.rust.core.from_wkt","text":"<pre><code>from_wkt(\n    input: ArrowArrayExportable, to_type: ArrowSchemaExportable | None = None\n) -&gt; GeoArray\n</code></pre><pre><code>from_wkt(\n    input: ArrowStreamExportable, to_type: ArrowSchemaExportable | None = None\n) -&gt; GeoArrayReader\n</code></pre> <pre><code>from_wkt(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    to_type: ArrowSchemaExportable | None = None,\n) -&gt; GeoArray | GeoArrayReader\n</code></pre> <p>Parse the WKT <code>input</code> to the provided data type.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>Input data to parse.</p> </li> <li> <code>to_type</code>               (<code>ArrowSchemaExportable | None</code>, default:                   <code>None</code> )           \u2013            <p>The target data type to parse to. By default, parses to a Geometry type array (the output of <code>geoarrow.rust.core.geometry</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoArrayReader</code>           \u2013            <p>If <code>input</code> is an Array-like, a <code>GeoArray</code> will be returned. If <code>input</code> is a Stream-like (<code>ChunkedArray</code> or <code>ArrayReader</code>), a <code>GeoArrayReader</code> will be returned.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.to_wkb","title":"geoarrow.rust.core.to_wkb","text":"<pre><code>to_wkb(\n    input: ArrowArrayExportable,\n    wkb_type: Literal[\"wkb\", \"large_wkb\", \"wkb_view\"] = \"wkb\",\n) -&gt; GeoArray\n</code></pre><pre><code>to_wkb(\n    input: ArrowStreamExportable,\n    wkb_type: Literal[\"wkb\", \"large_wkb\", \"wkb_view\"] = \"wkb\",\n) -&gt; GeoArrayReader\n</code></pre> <pre><code>to_wkb(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    wkb_type: Literal[\"wkb\", \"large_wkb\", \"wkb_view\"] = \"wkb\",\n) -&gt; GeoArray | GeoArrayReader\n</code></pre> <p>Convert <code>input</code> to WKB.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>Input data to parse.</p> </li> <li> <code>wkb_type</code>               (<code>Literal['wkb', 'large_wkb', 'wkb_view']</code>, default:                   <code>'wkb'</code> )           \u2013            <p>The target WKB array type to convert to. Can be one of \"wkb\" (binary array with <code>i32</code> offsets), \"large_wkb\" (binary array with <code>i64</code> offsets), or \"wkb_view\" (binary view array).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoArrayReader</code>           \u2013            <p>If <code>input</code> is an Array-like, a <code>GeoArray</code> will be returned. If <code>input</code> is a Stream-like (<code>ChunkedArray</code> or <code>ArrayReader</code>), a <code>GeoArrayReader</code> will be returned.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.to_wkt","title":"geoarrow.rust.core.to_wkt","text":"<pre><code>to_wkt(\n    input: ArrowArrayExportable,\n    wkt_type: Literal[\"wkt\", \"large_wkt\", \"wkt_view\"] = \"wkt\",\n) -&gt; GeoArray\n</code></pre><pre><code>to_wkt(\n    input: ArrowStreamExportable,\n    wkt_type: Literal[\"wkt\", \"large_wkt\", \"wkt_view\"] = \"wkt\",\n) -&gt; GeoArrayReader\n</code></pre> <pre><code>to_wkt(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n    wkt_type: Literal[\"wkt\", \"large_wkt\", \"wkt_view\"] = \"wkt\",\n) -&gt; GeoArray | GeoArrayReader\n</code></pre> <p>Convert <code>input</code> to WKT.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>Input data to parse.</p> </li> <li> <code>wkt_type</code>               (<code>Literal['wkt', 'large_wkt', 'wkt_view']</code>, default:                   <code>'wkt'</code> )           \u2013            <p>The target WKT array type to convert to. Can be one of \"wkt\" (string array with <code>i32</code> offsets), \"large_wkt\" (string array with <code>i64</code> offsets), or \"wkt_view\" (string view array).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoArray | GeoArrayReader</code>           \u2013            <p>If <code>input</code> is an Array-like, a <code>GeoArray</code> will be returned. If <code>input</code> is a Stream-like (<code>ChunkedArray</code> or <code>ArrayReader</code>), a <code>GeoArrayReader</code> will be returned.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.get_crs","title":"geoarrow.rust.core.get_crs","text":"<pre><code>get_crs(\n    data: ArrowArrayExportable | ArrowStreamExportable | ArrowSchemaExportable,\n    /,\n    column: str | None = None,\n) -&gt; CRS | None\n</code></pre> <p>Get the CRS from a GeoArrow object.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>ArrowArrayExportable | ArrowStreamExportable | ArrowSchemaExportable</code>)           \u2013            <p>A GeoArrow object. This can be an Array, ChunkedArray, ArrayReader, RecordBatchReader, Table, Field, or Schema.</p> </li> <li> <code>column</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the geometry column to retrieve, if there's more than one. For Schema, Table, and RecordBatchReader inputs, there may be more than one geometry column included. If there are multiple geometry columns, you must pass this <code>column</code> parameter. If there is only one geometry column, it will be inferred. Defaults to None.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no geometry column could be found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CRS | None</code>           \u2013            <p>a pyproj CRS object.</p> </li> </ul>"},{"location":"api/core/functions/#geoarrow.rust.core.get_type_id","title":"geoarrow.rust.core.get_type_id","text":"<pre><code>get_type_id(input: ArrowArrayExportable) -&gt; Array\n</code></pre><pre><code>get_type_id(input: ArrowStreamExportable) -&gt; ArrayReader\n</code></pre> <pre><code>get_type_id(\n    input: ArrowArrayExportable | ArrowStreamExportable,\n) -&gt; Array | ArrayReader\n</code></pre> <p>Returns integer type ids for each geometry in the input.</p> <p>The returned integers match the internal ids of the GeoArrow Geometry type:</p> Type ID Geometry type 1 Point 2 LineString 3 Polygon 4 MultiPoint 5 MultiLineString 6 MultiPolygon 7 GeometryCollection 11 Point Z 12 LineString Z 13 Polygon Z 14 MultiPoint Z 15 MultiLineString Z 16 MultiPolygon Z 17 GeometryCollection Z 21 Point M 22 LineString M 23 Polygon M 24 MultiPoint M 25 MultiLineString M 26 MultiPolygon M 27 GeometryCollection M 31 Point ZM 32 LineString ZM 33 Polygon ZM 34 MultiPoint ZM 35 MultiLineString ZM 36 MultiPolygon ZM 37 GeometryCollection ZM <p>Warning</p> <p>These ids do not exactly match the result of <code>shapely.get_type_id</code>. Shapely does not distinguish between dimensions. Also the ids differ for <code>Point</code> and <code>LineString</code> compared to here.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>Input geometry array, chunked array, or stream.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array | ArrayReader</code>           \u2013            <p>An int8 Array of type ids.</p> </li> </ul>"},{"location":"api/core/geometry_type/","title":"Geometry Type","text":""},{"location":"api/core/geometry_type/#geoarrow.rust.core.GeoType","title":"geoarrow.rust.core.GeoType","text":"<p>A GeoArrow data type.</p> <p>This implements the Arrow PyCapsule interface, allowing it to be seamlessly converted to other Arrow implementations.</p>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.GeoType--converting-to-pyarrow","title":"Converting to pyarrow","text":"<p><code>geoarrow-types</code> is recommended to register GeoArrow extension types into the pyarrow type registry.</p> <pre><code>from geoarrow.types.type_pyarrow import register_extension_types\nfrom geoarrow.rust.core import point\n\npa.field(point(\"xy\"))\n# pyarrow.Field&lt;: extension&lt;geoarrow.point&lt;PointType&gt;&gt;&gt;\n\n# You may want to set the name on the field upon importing:\npa.field(point(\"xy\")).with_name(\"geometry\")\n# pyarrow.Field&lt;geometry: extension&lt;geoarrow.point&lt;PointType&gt;&gt;&gt;\n\n# Because the extension types were registered from geoarrow-types,\n# the resulting type is geoarrow-aware\npa.field(point(\"xy\", crs=\"epsg:4326\")).type.crs\n# ProjJsonCrs(EPSG:4326)\n</code></pre>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.GeoType.coord_type","title":"coord_type  <code>property</code>","text":"<pre><code>coord_type: CoordType | None\n</code></pre> <p>The coordinate type of the type.</p> <p>This will only be set if the type is a \"native\" GeoArrow type with a known coordinate type. Serialized arrays such as WKB/WKT arrays do not have a coordinate type.</p>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.GeoType.crs","title":"crs  <code>property</code>","text":"<pre><code>crs: CRS | None\n</code></pre> <p>The CRS of the type.</p>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.GeoType.dimension","title":"dimension  <code>property</code>","text":"<pre><code>dimension: Dimension | None\n</code></pre> <p>The dimension of the type.</p> <p>This will only be set if the type is a \"native\" GeoArrow type with a known dimension type. Geometry arrays and serialized arrays such as WKB/WKT arrays do not have a statically-known dimension.</p>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.GeoType.edges","title":"edges  <code>property</code>","text":"<pre><code>edges: Edges | None\n</code></pre> <p>The edge interpolation of this type.</p>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.GeoType.with_crs","title":"with_crs","text":"<pre><code>with_crs(\n    crs: CRSInput | None = None, *, edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Return a new type with the given CRS and edge interpolation.</p> <p>Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.point","title":"geoarrow.rust.core.point","text":"<pre><code>point(\n    dimension: DimensionInput,\n    *,\n    coord_type: CoordTypeInput = SEPARATED,\n    crs: CRSInput | None = None,\n    edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow Point array.</p> <p>Parameters:</p> <ul> <li> <code>dimension</code>               (<code>DimensionInput</code>)           \u2013            <p>The dimension of the array.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>coord_type</code>               (<code>CoordTypeInput</code>)           \u2013            <p>The coordinate type of the array. Defaults to <code>CoordType.SEPARATED</code>.</p> </li> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul> <p>Examples:</p> <pre><code>from geoarrow.rust.core import point\n\npoint(\"xy\")\n# GeoType(Point(dimension=\"XY\", coord_type=\"separated\"))\n\npoint(\"xy\", coord_type=\"interleaved\")\n# GeoType(Point(dimension=\"XY\", coord_type=\"interleaved\"))\n</code></pre>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.linestring","title":"geoarrow.rust.core.linestring","text":"<pre><code>linestring(\n    dimension: DimensionInput,\n    *,\n    coord_type: CoordTypeInput = SEPARATED,\n    crs: CRSInput | None = None,\n    edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow LineString array.</p> <p>Parameters:</p> <ul> <li> <code>dimension</code>               (<code>DimensionInput</code>)           \u2013            <p>The dimension of the array.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>coord_type</code>               (<code>CoordTypeInput</code>)           \u2013            <p>The coordinate type of the array. Defaults to <code>CoordType.SEPARATED</code>.</p> </li> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.polygon","title":"geoarrow.rust.core.polygon","text":"<pre><code>polygon(\n    dimension: DimensionInput,\n    *,\n    coord_type: CoordTypeInput = SEPARATED,\n    crs: CRSInput | None = None,\n    edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow Polygon array.</p> <p>Parameters:</p> <ul> <li> <code>dimension</code>               (<code>DimensionInput</code>)           \u2013            <p>The dimension of the array.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>coord_type</code>               (<code>CoordTypeInput</code>)           \u2013            <p>The coordinate type of the array. Defaults to <code>CoordType.SEPARATED</code>.</p> </li> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.multipoint","title":"geoarrow.rust.core.multipoint","text":"<pre><code>multipoint(\n    dimension: DimensionInput,\n    *,\n    coord_type: CoordTypeInput = SEPARATED,\n    crs: CRSInput | None = None,\n    edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow MultiPoint array.</p> <p>Parameters:</p> <ul> <li> <code>dimension</code>               (<code>DimensionInput</code>)           \u2013            <p>The dimension of the array.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>coord_type</code>               (<code>CoordTypeInput</code>)           \u2013            <p>The coordinate type of the array. Defaults to <code>CoordType.SEPARATED</code>.</p> </li> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.multilinestring","title":"geoarrow.rust.core.multilinestring","text":"<pre><code>multilinestring(\n    dimension: DimensionInput,\n    *,\n    coord_type: CoordTypeInput = SEPARATED,\n    crs: CRSInput | None = None,\n    edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow MultiLineString array.</p> <p>Parameters:</p> <ul> <li> <code>dimension</code>               (<code>DimensionInput</code>)           \u2013            <p>The dimension of the array.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>coord_type</code>               (<code>CoordTypeInput</code>)           \u2013            <p>The coordinate type of the array. Defaults to <code>CoordType.SEPARATED</code>.</p> </li> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.multipolygon","title":"geoarrow.rust.core.multipolygon","text":"<pre><code>multipolygon(\n    dimension: DimensionInput,\n    *,\n    coord_type: CoordTypeInput = SEPARATED,\n    crs: CRSInput | None = None,\n    edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow MultiPolygon array.</p> <p>Parameters:</p> <ul> <li> <code>dimension</code>               (<code>DimensionInput</code>)           \u2013            <p>The dimension of the array.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>coord_type</code>               (<code>CoordTypeInput</code>)           \u2013            <p>The coordinate type of the array. Defaults to <code>CoordType.SEPARATED</code>.</p> </li> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.geometry","title":"geoarrow.rust.core.geometry","text":"<pre><code>geometry(\n    *,\n    coord_type: CoordType = SEPARATED,\n    crs: CRSInput | None = None,\n    edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow Geometry array.</p> <p>Other Parameters:</p> <ul> <li> <code>coord_type</code>               (<code>CoordType</code>)           \u2013            <p>The coordinate type of the array. Defaults to <code>CoordType.SEPARATED</code>.</p> </li> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.geometrycollection","title":"geoarrow.rust.core.geometrycollection","text":"<pre><code>geometrycollection(\n    dimension: DimensionInput,\n    *,\n    coord_type: CoordTypeInput = SEPARATED,\n    crs: CRSInput | None = None,\n    edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow GeometryCollection array.</p> <p>Parameters:</p> <ul> <li> <code>dimension</code>               (<code>DimensionInput</code>)           \u2013            <p>The dimension of the array.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>coord_type</code>               (<code>CoordTypeInput</code>)           \u2013            <p>The coordinate type of the array. Defaults to <code>CoordType.SEPARATED</code>.</p> </li> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.box","title":"geoarrow.rust.core.box","text":"<pre><code>box(\n    dimension: DimensionInput,\n    *,\n    crs: CRSInput | None = None,\n    edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow Box array.</p> <p>Parameters:</p> <ul> <li> <code>dimension</code>               (<code>DimensionInput</code>)           \u2013            <p>The dimension of the array.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>)           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.wkb","title":"geoarrow.rust.core.wkb","text":"<pre><code>wkb(*, crs: CRSInput | None = None, edges: EdgesInput | None = None) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow WKB array.</p> <p>This type is backed by an Arrow BinaryArray with <code>i32</code> offsets, allowing a maximum array size of 2 GB per array chunk.</p> <p>Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.large_wkb","title":"geoarrow.rust.core.large_wkb","text":"<pre><code>large_wkb(\n    *, crs: CRSInput | None = None, edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow WKB array.</p> <p>This type is backed by an Arrow LargeBinaryArray with <code>i64</code> offsets, allowing more than 2GB of data per array chunk.</p> <p>Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.wkb_view","title":"geoarrow.rust.core.wkb_view","text":"<pre><code>wkb_view(\n    *, crs: CRSInput | None = None, edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow WKB array.</p> <p>This type is backed by an Arrow BinaryViewArray.</p> <p>Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.wkt","title":"geoarrow.rust.core.wkt","text":"<pre><code>wkt(*, crs: CRSInput | None = None, edges: EdgesInput | None = None) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow WKT array.</p> <p>This type is backed by an Arrow StringArray with <code>i32</code> offsets, allowing a maximum array size of 2 GB per array chunk.</p> <p>Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.large_wkt","title":"geoarrow.rust.core.large_wkt","text":"<pre><code>large_wkt(\n    *, crs: CRSInput | None = None, edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow WKT array.</p> <p>This type is backed by an Arrow LargeString array with <code>i64</code> offsets, allowing more than 2GB of data per array chunk.</p> <p>Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/geometry_type/#geoarrow.rust.core.wkt_view","title":"geoarrow.rust.core.wkt_view","text":"<pre><code>wkt_view(\n    *, crs: CRSInput | None = None, edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Create a new Arrow type for a GeoArrow WKT array.</p> <p>This type is backed by an Arrow StringView array.</p> <p>Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> <li> <code>edges</code>               (<code>EdgesInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/core/types/","title":"Types","text":""},{"location":"api/core/types/#geoarrow.rust.core.types","title":"geoarrow.rust.core.types","text":""},{"location":"api/core/types/#geoarrow.rust.core.types.CRSInput","title":"CRSInput  <code>module-attribute</code>","text":"<pre><code>CRSInput = Union[CRS, str, dict, int]\n</code></pre> <p>Acceptable input for the CRS parameter.</p> <p>This can be a <code>pyproj.CRS</code> object or anything that can be passed to <code>pyproj.CRS.from_user_input()</code>.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.CoordTypeInput","title":"CoordTypeInput  <code>module-attribute</code>","text":"<pre><code>CoordTypeInput = Union[CoordType, CoordTypeT]\n</code></pre> <p>Acceptable coord_type input.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.CoordTypeT","title":"CoordTypeT  <code>module-attribute</code>","text":"<pre><code>CoordTypeT = Literal['interleaved', 'separated']\n</code></pre> <p>Acceptable coord_type strings.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.DimensionInput","title":"DimensionInput  <code>module-attribute</code>","text":"<pre><code>DimensionInput = Union[Dimension, DimensionT]\n</code></pre> <p>Acceptable dimension input.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.DimensionT","title":"DimensionT  <code>module-attribute</code>","text":"<pre><code>DimensionT = Literal['XY', 'XYZ', 'XYM', 'XYZM', 'xy', 'xyz', 'xym', 'xyzm']\n</code></pre> <p>Acceptable dimension strings.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.EdgesInput","title":"EdgesInput  <code>module-attribute</code>","text":"<pre><code>EdgesInput = Union[Edges, EdgesT]\n</code></pre> <p>Acceptable edges input.</p>"},{"location":"api/core/types/#geoarrow.rust.core.types.EdgesT","title":"EdgesT  <code>module-attribute</code>","text":"<pre><code>EdgesT = Literal['andoyer', 'karney', 'spherical', 'thomas', 'vincenty']\n</code></pre> <p>Acceptable edges strings.</p>"},{"location":"api/core/geometry/scalar/","title":"Geometry","text":""},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.GeoScalar","title":"geoarrow.rust.core.GeoScalar","text":"<p>An immutable geometry scalar using GeoArrow's in-memory representation.</p> <p>Note: for best performance, do as many operations as possible on arrays or chunked arrays instead of scalars.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.GeoScalar.__geo_interface__","title":"__geo_interface__  <code>property</code>","text":"<pre><code>__geo_interface__: dict[str, object]\n</code></pre> <p>Implements the Geo Interface.</p> <p>For example, you can pass this to [<code>shapely.geometry.shape</code>].</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.GeoScalar.is_null","title":"is_null  <code>property</code>","text":"<pre><code>is_null: bool\n</code></pre> <p>Check if the scalar is null.</p> <p>Note that Arrow arrays hold a separate null bitmap, so this is separate from whether the geometry is empty.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.GeoScalar.type","title":"type  <code>property</code>","text":"<pre><code>type: GeoType\n</code></pre> <p>The type of the scalar.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.GeoScalar.__arrow_c_array__","title":"__arrow_c_array__","text":"<pre><code>__arrow_c_array__(\n    requested_schema: object | None = None,\n) -&gt; tuple[object, object]\n</code></pre> <p>An implementation of the Arrow PyCapsule Interface. This dunder method should not be called directly, but enables zero-copy data transfer to other Python libraries that understand Arrow memory.</p> <p>For example, you can call <code>pyarrow.array()</code> to convert this array into a pyarrow array, without copying memory.</p>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.GeoScalar.__eq__","title":"__eq__","text":"<pre><code>__eq__(value: object) -&gt; bool\n</code></pre>"},{"location":"api/core/geometry/scalar/#geoarrow.rust.core.GeoScalar.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre>"},{"location":"api/core/geometry/type/","title":"Type","text":""},{"location":"api/core/geometry/type/#geoarrow.rust.core.GeoType","title":"geoarrow.rust.core.GeoType","text":"<p>A GeoArrow data type.</p> <p>This implements the Arrow PyCapsule interface, allowing it to be seamlessly converted to other Arrow implementations.</p>"},{"location":"api/core/geometry/type/#geoarrow.rust.core.GeoType--converting-to-pyarrow","title":"Converting to pyarrow","text":"<p><code>geoarrow-types</code> is recommended to register GeoArrow extension types into the pyarrow type registry.</p> <pre><code>from geoarrow.types.type_pyarrow import register_extension_types\nfrom geoarrow.rust.core import point\n\npa.field(point(\"xy\"))\n# pyarrow.Field&lt;: extension&lt;geoarrow.point&lt;PointType&gt;&gt;&gt;\n\n# You may want to set the name on the field upon importing:\npa.field(point(\"xy\")).with_name(\"geometry\")\n# pyarrow.Field&lt;geometry: extension&lt;geoarrow.point&lt;PointType&gt;&gt;&gt;\n\n# Because the extension types were registered from geoarrow-types,\n# the resulting type is geoarrow-aware\npa.field(point(\"xy\", crs=\"epsg:4326\")).type.crs\n# ProjJsonCrs(EPSG:4326)\n</code></pre>"},{"location":"api/core/geometry/type/#geoarrow.rust.core.GeoType.coord_type","title":"coord_type  <code>property</code>","text":"<pre><code>coord_type: CoordType | None\n</code></pre> <p>The coordinate type of the type.</p> <p>This will only be set if the type is a \"native\" GeoArrow type with a known coordinate type. Serialized arrays such as WKB/WKT arrays do not have a coordinate type.</p>"},{"location":"api/core/geometry/type/#geoarrow.rust.core.GeoType.crs","title":"crs  <code>property</code>","text":"<pre><code>crs: CRS | None\n</code></pre> <p>The CRS of the type.</p>"},{"location":"api/core/geometry/type/#geoarrow.rust.core.GeoType.dimension","title":"dimension  <code>property</code>","text":"<pre><code>dimension: Dimension | None\n</code></pre> <p>The dimension of the type.</p> <p>This will only be set if the type is a \"native\" GeoArrow type with a known dimension type. Geometry arrays and serialized arrays such as WKB/WKT arrays do not have a statically-known dimension.</p>"},{"location":"api/core/geometry/type/#geoarrow.rust.core.GeoType.edges","title":"edges  <code>property</code>","text":"<pre><code>edges: Edges | None\n</code></pre> <p>The edge interpolation of this type.</p>"},{"location":"api/core/geometry/type/#geoarrow.rust.core.GeoType.with_crs","title":"with_crs","text":"<pre><code>with_crs(\n    crs: CRSInput | None = None, *, edges: EdgesInput | None = None\n) -&gt; GeoType\n</code></pre> <p>Return a new type with the given CRS and edge interpolation.</p> <p>Parameters:</p> <ul> <li> <code>crs</code>               (<code>CRSInput | None</code>, default:                   <code>None</code> )           \u2013            <p>the CRS of the type. Defaults to None.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>edges</code>               (<code>EdgesInput | None</code>)           \u2013            <p>the edge interpolation of the type. Defaults to None.</p> </li> </ul>"},{"location":"api/io/","title":"<code>geoarrow.rust.io</code>","text":"<p>All functionality described within this directory are part of the <code>geoarrow.rust.io</code> submodule. To use, install the <code>geoarrow-rust-io</code> PyPI package:</p> <pre><code>pip install geoarrow-rust-io\n</code></pre>"},{"location":"api/io/arrow_ipc/","title":"Arrow IPC","text":"<p>It's possible to read and write GeoArrow data to the Arrow IPC format.</p> <p>The Arrow IPC format is able to fully represent GeoArrow data. Loading such files back into memory will identically reproduce the prior data.</p> <p>Arrow IPC generically supports GeoArrow data without any extra behavior, so the functionality to read and write Arrow IPC files lives in <code>arro3</code>.</p> <p>Refer to:</p> <ul> <li><code>arro3.io.read_ipc</code></li> <li><code>arro3.io.read_ipc_stream</code></li> <li><code>arro3.io.write_ipc</code></li> <li><code>arro3.io.write_ipc_stream</code></li> </ul> <p>When saved without any internal compression, the Arrow IPC format can also be memory-mapped, enabling faster reading.</p>"},{"location":"api/io/flatgeobuf/","title":"FlatGeobuf","text":"<p>Read and write FlatGeobuf files.</p>"},{"location":"api/io/flatgeobuf/#geoarrow.rust.io.read_flatgeobuf","title":"geoarrow.rust.io.read_flatgeobuf","text":"<pre><code>read_flatgeobuf(\n    path: Union[str, Path, BinaryIO],\n    *,\n    store: Optional[ObjectStore] = None,\n    batch_size: int = 65536,\n    bbox: (\n        Tuple[int | float, int | float, int | float, int | float] | None\n    ) = None,\n    coord_type: CoordTypeInput | None = None,\n    use_view_types: bool = True,\n    max_scan_records: int | None = 1000,\n    read_geometry: bool = True,\n    columns: Optional[Sequence[str]] = None\n) -&gt; Table\n</code></pre> <p>Read a FlatGeobuf file from a path on disk or a remote location into an Arrow Table.</p> <p>Example:</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>Union[str, Path, BinaryIO]</code>)           \u2013            <p>the path to the file or a Python file object in binary read mode.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>store</code>               (<code>Optional[ObjectStore]</code>)           \u2013            <p>an ObjectStore instance for this url. This is required only if the file is at a remote location and if the store cannot be inferred.</p> </li> <li> <code>batch_size</code>               (<code>int</code>)           \u2013            <p>the number of rows to include in each internal batch of the table.</p> </li> <li> <code>bbox</code>               (<code>Tuple[int | float, int | float, int | float, int | float] | None</code>)           \u2013            <p>A spatial filter for reading rows, of the format <code>(minx, miny, maxx, maxy)</code>. If set to <code>None</code>, no spatial filtering will be performed.</p> </li> <li> <code>coord_type</code>               (<code>CoordTypeInput | None</code>)           \u2013            <p>The GeoArrow coordinate type to use for generated geometries. The default is to use \"separated\" coordinates.</p> </li> <li> <code>use_view_types</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, load string and binary columns into Arrow string view and binary view data types. These are more efficient but less widely supported than the older string and binary data types. Defaults to <code>True</code>.</p> </li> <li> <code>max_scan_records</code>               (<code>int | None</code>)           \u2013            <p>The maximum number of records to scan for schema inference. If set to <code>None</code>, all records will be scanned. Defaults to 1000.</p> <p>Most FlatGeobuf files have a schema defined in the header metadata. But for files that do not have a known schema, we need to scan some initial records to infer a schema. Reading will fail if a new property with an unknown name is found that was not in the schema. Thus, scanning fewer records will be faster, but could fail later if the inferred schema was not complete.</p> </li> <li> <code>read_geometry</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, read the geometry column. If <code>False</code>, the geometry column will be omitted from the result. Defaults to <code>True</code>.</p> </li> <li> <code>columns</code>               (<code>Optional[Sequence[str]]</code>)           \u2013            <p>An optional list of property column names to include in the result. This is separate from the geometry column, which you can turn on/off with <code>read_geometry</code>. If <code>None</code>, all columns will be included. Defaults to <code>None</code>.</p> </li> </ul> <p>Examples:</p> <p>Reading from a local path:</p> <pre><code>from geoarrow.rust.io import read_flatgeobuf\ntable = read_flatgeobuf(\"path/to/file.fgb\")\n</code></pre> <p>Reading from a Python file object:</p> <pre><code>from geoarrow.rust.io import read_flatgeobuf\n\nwith open(\"path/to/file.fgb\", \"rb\") as file:\n    table = read_flatgeobuf(file)\n</code></pre> <p>Reading from an HTTP(S) url:</p> <pre><code>from geoarrow.rust.io import read_flatgeobuf\n\nurl = \"http://flatgeobuf.org/test/data/UScounties.fgb\"\ntable = read_flatgeobuf(url)\n</code></pre> <p>Reading from a remote file with specified credentials. You can pass any <code>store</code> constructed from <code>obstore</code>, including from <code>S3Store</code>, <code>GCSStore</code>, <code>AzureStore</code>, <code>HTTPStore</code> or <code>LocalStore</code>.</p> <pre><code>from geoarrow.rust.io import read_flatgeobuf\nfrom obstore.store import S3Store\n\nstore = S3Store(\n    \"bucket-name\",\n    access_key_id=\"...\",\n    secret_access_key=\"...\",\n    region=\"...\"\n)\ntable = read_flatgeobuf(\"path/in/bucket.fgb\", store=store)\n</code></pre> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>Table from FlatGeobuf file.</p> </li> </ul>"},{"location":"api/io/flatgeobuf/#geoarrow.rust.io.read_flatgeobuf_async","title":"geoarrow.rust.io.read_flatgeobuf_async  <code>async</code>","text":"<pre><code>read_flatgeobuf_async(\n    path: str,\n    *,\n    store: Optional[ObjectStore] = None,\n    batch_size: int = 65536,\n    bbox: (\n        Tuple[int | float, int | float, int | float, int | float] | None\n    ) = None,\n    coord_type: CoordTypeInput | None = None,\n    use_view_types: bool = True,\n    max_scan_records: int | None = 1000,\n    read_geometry: bool = True,\n    columns: Optional[Sequence[str]] = None\n) -&gt; Table\n</code></pre> <p>Read a FlatGeobuf file from a url into an Arrow Table.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>the url or relative path to a remote FlatGeobuf file. If an argument is passed for <code>store</code>, this should be a path fragment relative to the prefix of the store.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>store</code>               (<code>Optional[ObjectStore]</code>)           \u2013            <p>an ObjectStore instance for this url. This is required only if the file is at a remote location and if the store cannot be inferred.</p> </li> <li> <code>batch_size</code>               (<code>int</code>)           \u2013            <p>the number of rows to include in each internal batch of the table.</p> </li> <li> <code>bbox</code>               (<code>Tuple[int | float, int | float, int | float, int | float] | None</code>)           \u2013            <p>A spatial filter for reading rows, of the format <code>(minx, miny, maxx, maxy)</code>. If set to <code>None</code>, no spatial filtering will be performed.</p> </li> <li> <code>coord_type</code>               (<code>CoordTypeInput | None</code>)           \u2013            <p>The GeoArrow coordinate type to use for generated geometries. The default is to use \"separated\" coordinates.</p> </li> <li> <code>use_view_types</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, load string and binary columns into Arrow string view and binary view data types. These are more efficient but less widely supported than the older string and binary data types. Defaults to <code>True</code>.</p> </li> <li> <code>max_scan_records</code>               (<code>int | None</code>)           \u2013            <p>The maximum number of records to scan for schema inference. If set to <code>None</code>, all records will be scanned. Defaults to 1000.</p> <p>Most FlatGeobuf files have a schema defined in the header metadata. But for files that do not have a known schema, we need to scan some initial records to infer a schema. Reading will fail if a new property with an unknown name is found that was not in the schema. Thus, scanning fewer records will be faster, but could fail later if the inferred schema was not complete.</p> </li> <li> <code>read_geometry</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, read the geometry column. If <code>False</code>, the geometry column will be omitted from the result. Defaults to <code>True</code>.</p> </li> <li> <code>columns</code>               (<code>Optional[Sequence[str]]</code>)           \u2013            <p>An optional list of property column names to include in the result. This is separate from the geometry column, which you can turn on/off with <code>read_geometry</code>. If <code>None</code>, all columns will be included. Defaults to <code>None</code>.</p> </li> </ul> <p>Examples:</p> <p>Reading from an HTTP(S) url:</p> <pre><code>from geoarrow.rust.io import read_flatgeobuf_async\n\nurl = \"http://flatgeobuf.org/test/data/UScounties.fgb\"\ntable = await read_flatgeobuf_async(url)\n</code></pre> <p>Reading from an S3 bucket:</p> <pre><code>from geoarrow.rust.io import ObjectStore, read_flatgeobuf_async\nfrom obstore.store import S3Store\n\nstore = S3Store(\n    \"bucket-name\",\n    access_key_id=\"...\",\n    secret_access_key=\"...\",\n    region=\"...\"\n)\ntable = await read_flatgeobuf_async(\"path/in/bucket.fgb\", store=store)\n</code></pre> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>Table from FlatGeobuf file.</p> </li> </ul>"},{"location":"api/io/flatgeobuf/#geoarrow.rust.io.write_flatgeobuf","title":"geoarrow.rust.io.write_flatgeobuf","text":"<pre><code>write_flatgeobuf(\n    table: ArrowStreamExportable,\n    file: str | Path | BinaryIO,\n    *,\n    write_index: bool = True,\n    promote_to_multi: bool = True,\n    title: str | None = None,\n    description: str | None = None,\n    metadata: str | None = None,\n    name: str | None = None\n) -&gt; None\n</code></pre> <p>Write to a FlatGeobuf file on disk.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>ArrowStreamExportable</code>)           \u2013            <p>the Arrow RecordBatch, Table, or RecordBatchReader to write.</p> </li> <li> <code>file</code>               (<code>str | Path | BinaryIO</code>)           \u2013            <p>the path to the file or a Python file object in binary write mode.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>write_index</code>               (<code>bool</code>)           \u2013            <p>whether to write a spatial index in the FlatGeobuf file. Defaults to True.</p> </li> <li> <code>title</code>               (<code>str | None</code>)           \u2013            <p>Dataset title. Defaults to <code>None</code>.</p> </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            <p>Dataset description (intended for free form long text).</p> </li> <li> <code>metadata</code>               (<code>str | None</code>)           \u2013            <p>Dataset metadata (intended to be application specific).</p> </li> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>the string passed to <code>FgbWriter::create</code> and is what OGR observes as the layer name of the file. By default, this will try to use the file name, but can be overrided.</p> </li> </ul>"},{"location":"api/io/gdal/","title":"GDAL","text":"<p>GDAL natively supports reading data from any vector driver as GeoArrow data, and natively supports writing data to any vector driver from GeoArrow data.</p> <p>For reading and writing, use <code>pyogrio</code>'s Arrow integration directly, which supports WKB-encoded GeoArrow data.</p>"},{"location":"api/io/geoparquet/","title":"GeoParquet","text":"<p>Read and write GeoParquet files.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetDataset","title":"geoarrow.rust.io.GeoParquetDataset","text":"<p>An interface to read from a collection GeoParquet files with the same schema.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetDataset.fragments","title":"fragments  <code>property</code>","text":"<pre><code>fragments: List[GeoParquetFile]\n</code></pre> <p>Get the list of files in this dataset.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetDataset.num_row_groups","title":"num_row_groups  <code>property</code>","text":"<pre><code>num_row_groups: int\n</code></pre> <p>The total number of row groups across all files</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetDataset.num_rows","title":"num_rows  <code>property</code>","text":"<pre><code>num_rows: int\n</code></pre> <p>The total number of rows across all files.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetDataset.crs","title":"crs","text":"<pre><code>crs(column_name: str | None = None) -&gt; CRS | None\n</code></pre> <p>Access the CRS of this file.</p> <p>Parameters:</p> <ul> <li> <code>column_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The geometry column name. If there is more than one geometry column in the file, you must specify which you want to read. Defaults to None.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetDataset.fragment","title":"fragment","text":"<pre><code>fragment(path: str) -&gt; GeoParquetFile\n</code></pre> <p>Get a single file from this dataset.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetDataset.open","title":"open  <code>classmethod</code>","text":"<pre><code>open(\n    paths: Sequence[str] | Sequence[PathInput], store: ObjectStore\n) -&gt; GeoParquetDataset\n</code></pre> <p>Construct a new ParquetDataset</p> <p>This will synchronously fetch metadata from all listed files.</p> <p>Parameters:</p> <ul> <li> <code>paths</code>               (<code>Sequence[str] | Sequence[PathInput]</code>)           \u2013            <p>a list of string URLs to read from.</p> </li> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>the file system interface to read from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoParquetDataset</code>           \u2013            <p>A new ParquetDataset object.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetDataset.read","title":"read","text":"<pre><code>read(\n    *,\n    bbox: Sequence[int | float] | None = None,\n    parse_to_native: bool = True,\n    coord_type: CoordTypeInput | None = None,\n    batch_size: int | None = None\n) -&gt; Table\n</code></pre> <p>Perform a sync read with the given options</p> <p>Other Parameters:</p> <ul> <li> <code>bbox</code>               (<code>Sequence[int | float] | None</code>)           \u2013            <p>The 2D bounding box to use for spatially-filtered reads. Requires the source GeoParquet dataset to be version 1.1 with either a bounding box column or native geometry encoding. Defaults to None.</p> </li> <li> <code>parse_to_native</code>               (<code>bool</code>)           \u2013            <p>If True, the data will be parsed to native Arrow types. Defaults to True.</p> </li> <li> <code>coord_type</code>               (<code>CoordTypeInput | None</code>)           \u2013            <p>The coordinate type to use. Defaults to separated coordinates.</p> </li> <li> <code>batch_size</code>               (<code>int | None</code>)           \u2013            <p>The number of rows in each internal batch of the table. Defaults to 1024.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetDataset.read_async","title":"read_async  <code>async</code>","text":"<pre><code>read_async(\n    *,\n    bbox: Sequence[int | float] | None = None,\n    parse_to_native: bool = True,\n    coord_type: CoordTypeInput | None = None,\n    batch_size: int | None = None\n) -&gt; Table\n</code></pre> <p>Perform an async read with the given options</p> <p>Other Parameters:</p> <ul> <li> <code>bbox</code>               (<code>Sequence[int | float] | None</code>)           \u2013            <p>The 2D bounding box to use for spatially-filtered reads. Requires the source GeoParquet dataset to be version 1.1 with either a bounding box column or native geometry encoding. Defaults to None.</p> </li> <li> <code>parse_to_native</code>               (<code>bool</code>)           \u2013            <p>If True, the data will be parsed to native Arrow types. Defaults to True.</p> </li> <li> <code>coord_type</code>               (<code>CoordTypeInput | None</code>)           \u2013            <p>The coordinate type to use. Defaults to separated coordinates.</p> </li> <li> <code>batch_size</code>               (<code>int | None</code>)           \u2013            <p>The number of rows in each internal batch of the table. Defaults to 1024.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetDataset.schema_arrow","title":"schema_arrow","text":"<pre><code>schema_arrow(\n    *, parse_to_native: bool = True, coord_type: CoordTypeInput | None = None\n) -&gt; Schema\n</code></pre> <p>Access the Arrow schema of the generated data.</p> <p>Parameters:</p> <ul> <li> <code>parse_to_native</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the schema will be parsed to native Arrow types. Defaults to True.</p> </li> <li> <code>coord_type</code>               (<code>CoordTypeInput | None</code>, default:                   <code>None</code> )           \u2013            <p>The coordinate type to use. Defaults to separated coordinates.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile","title":"geoarrow.rust.io.GeoParquetFile","text":""},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.num_row_groups","title":"num_row_groups  <code>property</code>","text":"<pre><code>num_row_groups: int\n</code></pre> <p>The number of row groups in this file.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.num_rows","title":"num_rows  <code>property</code>","text":"<pre><code>num_rows: int\n</code></pre> <p>The number of rows in this file.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>The path to the file within the provided object store.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.crs","title":"crs","text":"<pre><code>crs(column_name: str | None = None) -&gt; CRS | None\n</code></pre> <p>Access the CRS of this file.</p> <p>Parameters:</p> <ul> <li> <code>column_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The geometry column name. If there is more than one geometry column in the file, you must specify which you want to read. Defaults to None.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.file_bbox","title":"file_bbox","text":"<pre><code>file_bbox() -&gt; List[float] | None\n</code></pre> <p>Access the bounding box of the given column for the entire file</p> <p>If no column name is passed, retrieves the bbox from the primary geometry column.</p> <p>An error will be returned if the column name does not exist in the dataset. None will be returned if the metadata does not contain bounding box information.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.open","title":"open  <code>classmethod</code>","text":"<pre><code>open(path: str | PathInput, store: ObjectStore) -&gt; GeoParquetFile\n</code></pre> <p>Open a Parquet file from the given path.</p> <p>This will synchronously fetch metadata from the provided path.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | PathInput</code>)           \u2013            <p>a string URL to read from.</p> </li> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>the object store interface to read from.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.open_async","title":"open_async  <code>async</code> <code>classmethod</code>","text":"<pre><code>open_async(path: str | PathInput, store: ObjectStore) -&gt; GeoParquetFile\n</code></pre> <p>Open a Parquet file from the given path asynchronously.</p> <p>This will fetch metadata from the provided path in an async manner.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | PathInput</code>)           \u2013            <p>a string URL to read from.</p> </li> <li> <code>store</code>               (<code>ObjectStore</code>)           \u2013            <p>the object store interface to read from.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.read","title":"read","text":"<pre><code>read(\n    *,\n    batch_size: int | None = None,\n    limit: int | None = None,\n    offset: int | None = None,\n    bbox: Sequence[int | float] | None = None,\n    parse_to_native: bool = True,\n    coord_type: CoordTypeInput | None = None\n) -&gt; Table\n</code></pre> <p>Perform a synchronous read with the given options</p> <p>Other Parameters:</p> <ul> <li> <code>bbox</code>               (<code>Sequence[int | float] | None</code>)           \u2013            <p>The 2D bounding box to use for spatially-filtered reads. Requires the source GeoParquet dataset to be version 1.1 with either a bounding box column or native geometry encoding. Defaults to None.</p> </li> <li> <code>parse_to_native</code>               (<code>bool</code>)           \u2013            <p>If True, the data will be parsed to native Arrow types. Defaults to True.</p> </li> <li> <code>coord_type</code>               (<code>CoordTypeInput | None</code>)           \u2013            <p>The coordinate type to use. Defaults to separated coordinates.</p> </li> <li> <code>batch_size</code>               (<code>int | None</code>)           \u2013            <p>The number of rows in each internal batch of the table. Defaults to 1024.</p> </li> <li> <code>limit</code>               (<code>int | None</code>)           \u2013            <p>The maximum number of rows to read. Defaults to None, which means all rows will be read.</p> </li> <li> <code>offset</code>               (<code>int | None</code>)           \u2013            <p>The number of rows to skip before starting to read. Defaults to None, which means no rows will be skipped.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.read_async","title":"read_async  <code>async</code>","text":"<pre><code>read_async(\n    *,\n    bbox: Sequence[int | float] | None = None,\n    parse_to_native: bool = True,\n    coord_type: CoordTypeInput | None = None,\n    batch_size: int | None = None,\n    limit: int | None = None,\n    offset: int | None = None\n) -&gt; Table\n</code></pre> <p>Perform an async read with the given options</p> <p>Other Parameters:</p> <ul> <li> <code>bbox</code>               (<code>Sequence[int | float] | None</code>)           \u2013            <p>The 2D bounding box to use for spatially-filtered reads. Requires the source GeoParquet dataset to be version 1.1 with either a bounding box column or native geometry encoding. Defaults to None.</p> </li> <li> <code>parse_to_native</code>               (<code>bool</code>)           \u2013            <p>If True, the data will be parsed to native Arrow types. Defaults to True.</p> </li> <li> <code>coord_type</code>               (<code>CoordTypeInput | None</code>)           \u2013            <p>The coordinate type to use. Defaults to separated coordinates.</p> </li> <li> <code>batch_size</code>               (<code>int | None</code>)           \u2013            <p>The number of rows in each internal batch of the table. Defaults to 1024.</p> </li> <li> <code>limit</code>               (<code>int | None</code>)           \u2013            <p>The maximum number of rows to read. Defaults to None, which means all rows will be read.</p> </li> <li> <code>offset</code>               (<code>int | None</code>)           \u2013            <p>The number of rows to skip before starting to read. Defaults to None, which means no rows will be skipped.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.row_group_bounds","title":"row_group_bounds","text":"<pre><code>row_group_bounds(\n    row_group_idx: int, column_name: str | None = None\n) -&gt; List[float]\n</code></pre> <p>Get the bounds of a single row group.</p> <p>Parameters:</p> <ul> <li> <code>row_group_idx</code>               (<code>int</code>)           \u2013            <p>The row group index.</p> </li> <li> <code>column_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The geometry column name. If there is more than one geometry column in the file, you must specify which you want to read. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>The bounds of a single row group.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.row_groups_bounds","title":"row_groups_bounds","text":"<pre><code>row_groups_bounds(column_name: str | None = None) -&gt; Array\n</code></pre> <p>Get the bounds of all row groups.</p> <p>As of GeoParquet 1.1 you won't need to pass in these column names, as they'll be specified in the metadata.</p> <p>Parameters:</p> <ul> <li> <code>column_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The geometry column name. If there is more than one geometry column in the file, you must specify which you want to read. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>A geoarrow \"box\" array with bounds of all row groups.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetFile.schema_arrow","title":"schema_arrow","text":"<pre><code>schema_arrow(\n    *, parse_to_native: bool = True, coord_type: CoordTypeInput | None = None\n) -&gt; Schema\n</code></pre> <p>Access the Arrow schema of the generated data.</p> <p>Parameters:</p> <ul> <li> <code>parse_to_native</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the schema will be parsed to native Arrow types. Defaults to True.</p> </li> <li> <code>coord_type</code>               (<code>CoordTypeInput | None</code>, default:                   <code>None</code> )           \u2013            <p>The coordinate type to use. Defaults to separated coordinates.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetWriter","title":"geoarrow.rust.io.GeoParquetWriter","text":"<p>Writer interface for a single GeoParquet file.</p> <p>This allows you to write GeoParquet files that are larger than memory.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetWriter.__init__","title":"__init__","text":"<pre><code>__init__(\n    file: str | Path | BinaryIO,\n    schema: ArrowSchemaExportable,\n    *,\n    encoding: GeoParquetEncoding | GeoParquetEncodingT = WKB,\n    compression: (\n        Literal[\"uncompressed\", \"snappy\", \"lzo\", \"lz4\", \"lz4_raw\"] | str\n    ) = \"zstd(1)\",\n    writer_version: Literal[\"parquet_1_0\", \"parquet_2_0\"] = \"parquet_2_0\",\n    generate_covering: bool = False\n) -&gt; None\n</code></pre> <p>Create a new GeoParquetWriter.</p> <p>Note</p> <p>This currently only supports writing to local files. Directly writing to object stores will be supported in a release soon.</p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>str | Path | BinaryIO</code>)           \u2013            <p>the path to the file or a Python file object in binary write mode.</p> </li> <li> <code>schema</code>               (<code>ArrowSchemaExportable</code>)           \u2013            <p>the Arrow schema of the data to write.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>encoding</code>               (<code>GeoParquetEncoding | GeoParquetEncodingT</code>)           \u2013            <p>the geometry encoding to use. See GeoParquetEncoding for more details on supported geometry encodings.</p> </li> <li> <code>compression</code>               (<code>Literal['uncompressed', 'snappy', 'lzo', 'lz4', 'lz4_raw'] | str</code>)           \u2013            <p>the compression algorithm to use. This can be either one of the strings in the <code>Literal</code> type, or a string that contains the compression level, like <code>gzip(9)</code> or <code>brotli(11)</code> or <code>zstd(22)</code>. The default is <code>zstd(1)</code>.</p> </li> <li> <code>writer_version</code>               (<code>Literal['parquet_1_0', 'parquet_2_0']</code>)           \u2013            <p>the Parquet writer version to use. Defaults to <code>\"parquet_2_0\"</code>.</p> </li> <li> <code>generate_covering</code>               (<code>bool</code>)           \u2013            <p>If True, the writer will generate a bounding box column (covering) for the geometries in the file. This is useful for spatially-indexed reads. Defaults to False.</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetWriter.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close this file.</p> <p>This is required to ensure that all data is flushed to disk and the file is properly finalized.</p> <p>The recommended use of this class is as a context manager, which will close the file automatically.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetWriter.is_closed","title":"is_closed","text":"<pre><code>is_closed() -&gt; bool\n</code></pre> <p>Returns <code>True</code> if the file has already been closed.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetWriter.write_batch","title":"write_batch","text":"<pre><code>write_batch(batch: ArrowArrayExportable) -&gt; None\n</code></pre> <p>Write a single RecordBatch to the GeoParquet file.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.GeoParquetWriter.write_table","title":"write_table","text":"<pre><code>write_table(table: ArrowArrayExportable | ArrowStreamExportable) -&gt; None\n</code></pre> <p>Write a table or stream of batches to the Parquet file</p> <p>This accepts an Arrow RecordBatch, Table, or RecordBatchReader. If a RecordBatchReader is passed, only one batch at a time will be materialized in memory, allowing you to write large datasets without running out of memory.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>ArrowArrayExportable | ArrowStreamExportable</code>)           \u2013            <p>description</p> </li> </ul>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.enums.GeoParquetEncoding","title":"geoarrow.rust.io.enums.GeoParquetEncoding","text":"<p>               Bases: <code>StrEnum</code></p> <p>Options for geometry encoding in GeoParquet.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.enums.GeoParquetEncoding.GEOARROW","title":"GEOARROW  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GEOARROW = 'geoarrow'\n</code></pre> <p>Use native GeoArrow-based geometry types when writing GeoParquet files.</p> <p>Note</p> <p>GeoParquet ecosystem support is not as widespread for the GeoArrow encoding as for the WKB encoding.</p> <p>This is only valid when all geometries are one of the supported single-geometry type encodings (i.e., <code>\"point\"</code>, <code>\"linestring\"</code>, <code>\"polygon\"</code>, <code>\"multipoint\"</code>, <code>\"multilinestring\"</code>, <code>\"multipolygon\"</code>).</p> <p>Using this encoding may provide better performance. Performance is most likely to be improved when writing points. Writing points plus an external bounding-box column requires storing each x-y coordinate pair 3 times instead of one, so this could provide significant file size savings. There has not yet been widespread testing for other geometry types.</p> <p>These encodings correspond to the separated (struct) representation of coordinates for single-geometry type encodings. This encoding results in useful column statistics when row groups and/or files contain related features.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.enums.GeoParquetEncoding.WKB","title":"WKB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WKB = 'wkb'\n</code></pre> <p>Use Well-Known Binary (WKB) encoding when writing GeoParquet files.</p> <p>This is the preferred option for maximum portability. See upstream specification reference.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.types.GeoParquetEncodingT","title":"geoarrow.rust.io.types.GeoParquetEncodingT  <code>module-attribute</code>","text":"<pre><code>GeoParquetEncodingT = Literal['wkb', 'geoarrow']\n</code></pre> <p>Acceptable strings to be passed into the <code>encoding</code> parameter for <code>GeoParquetWriter</code>.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.PathInput","title":"geoarrow.rust.io.PathInput","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.PathInput.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre> <p>The path to the file.</p>"},{"location":"api/io/geoparquet/#geoarrow.rust.io.PathInput.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size: int\n</code></pre> <p>The size of the file in bytes.</p> <p>If this is provided, only bounded range requests will be made instead of suffix requests. This is useful for object stores that do not support suffix requests, in particular Azure.</p>"},{"location":"ecosystem/gdal/","title":"GDAL","text":"<p>GDAL natively supports reading data from any vector driver as GeoArrow data, and natively supports writing data to any vector driver from GeoArrow data.</p> <p>For reading and writing, use <code>pyogrio</code>'s Arrow integration directly, which supports WKB-encoded GeoArrow data.</p> <p>This output table can be used with any GeoArrow-compatible library, including <code>geoarrow-rust</code> but also <code>geoarrow-pyarrow</code> and <code>lonboard</code>.</p>"},{"location":"ecosystem/geopandas/","title":"GeoPandas","text":"<p>As of GeoPandas v1.0, GeoPandas natively supports GeoArrow.</p> <p>Use <code>GeoDataFrame.to_arrow</code> to convert a GeoPandas <code>GeoDataFrame</code> to a GeoArrow table object. This table object is compatible with any GeoArrow-compatible library, including <code>geoarrow-rust</code> but also <code>geoarrow-pyarrow</code> and <code>lonboard</code>.</p> <p>Use <code>GeoDataFrame.from_arrow</code> to convert a GeoArrow table back to a GeoPandas <code>GeoDataFrame</code>. This supports all GeoArrow geometry types except for the new Geometry, GeometryCollection, and Box array types introduced in GeoArrow specification version 0.2.</p>"},{"location":"ecosystem/lonboard/","title":"Lonboard","text":"<p>Lonboard is a Python library for fast, interactive geospatial vector data visualization in Jupyter.</p> <p></p> <p>Lonboard was designed from the ground up to be used with GeoArrow, and GeoArrow is the reason why Lonboard is fast.</p> <p>You can pass a GeoArrow array, chunked array, or table object to Lonboard's <code>viz</code> and it should just work. Or, alternatively, pass a GeoArrow table as the <code>table</code> parameter of a layer's constructor, like in <code>ScatterplotLayer.__init__</code>.</p> <p>Note</p> <p>Lonboard does not yet support the new Geometry and GeometryCollection array types introduced in GeoArrow specification version 0.2. It likely will soon. For now, use <code>downcast</code> to simplify geometry types.</p> <p>Lonboard does also support the WKB array type, so you can use <code>to_wkb</code> on a Geometry or GeometryCollection array.</p>"},{"location":"ecosystem/lonboard/#examples","title":"Examples","text":"<p>Passing a GeoArrow table to <code>viz</code>:</p> <pre><code>from geoarrow.rust.io import GeoParquetFile\nfrom obstore.store import HTTPStore\nfrom lonboard import viz\n\nstore = HTTPStore.from_url(\n    \"https://raw.githubusercontent.com/opengeospatial/geoparquet/v1.0.0/examples\"\n)\nfile = GeoParquetFile.open(\"example.parquet\", store=store)\ntable = file.read()\n\nm = viz(table)\nm\n</code></pre> <p>Refer to lonboard's documentation for more examples.</p>"}]}