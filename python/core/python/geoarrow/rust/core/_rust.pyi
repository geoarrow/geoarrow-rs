from __future__ import annotations

from pathlib import Path
from typing import (
    BinaryIO,
    Dict,
    List,
    Optional,
    Self,
    Sequence,
    Tuple,
    TypeVar,
    Union,
    overload,
)

try:
    import numpy as np
    from numpy.typing import NDArray
except ImportError:
    pass

try:
    import geopandas as gpd
except ImportError:
    pass

from .types import (
    AffineInputT,
    AffineTransform,
    ArrowArrayExportable,
    ArrowStreamExportable,
    AreaMethodT,
    BroadcastGeometry,
    GeoInterfaceProtocol,
    LengthMethodT,
    NativeChunkedGeometryArrayT,
    NativeGeometryArrayT,
    NumpyArrayProtocolf64,
    SimplifyInputT,
    SimplifyMethodT,
)
from .enums import AreaMethod, LengthMethod, SimplifyMethod

class Point:
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __repr__(self) -> str: ...
    def _repr_svg_(self) -> str: ...

class LineString:
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __repr__(self) -> str: ...
    def _repr_svg_(self) -> str: ...

class Polygon:
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __repr__(self) -> str: ...
    def _repr_svg_(self) -> str: ...

class MultiPoint:
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __repr__(self) -> str: ...
    def _repr_svg_(self) -> str: ...

class MultiLineString:
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __repr__(self) -> str: ...
    def _repr_svg_(self) -> str: ...

class MultiPolygon:
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __repr__(self) -> str: ...
    def _repr_svg_(self) -> str: ...

class Geometry:
    # def __arrow_c_array__(
    #     self, requested_schema: object | None = None
    # ) -> Tuple[object, object]: ...
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __repr__(self) -> str: ...
    def _repr_svg_(self) -> str: ...

class GeometryCollection:
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __repr__(self) -> str: ...
    def _repr_svg_(self) -> str: ...

class WKB:
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __eq__(self, other: Self) -> bool: ...
    def __repr__(self) -> str: ...

class Rect:
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __eq__(self, other: Self) -> bool: ...
    def __repr__(self) -> str: ...

class PointArray:
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __getitem__(self, key: int) -> Point: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def bounding_rect(self) -> RectArray: ...
    def center(self) -> PointArray: ...
    def centroid(self) -> PointArray: ...
    def convex_hull(self) -> PolygonArray: ...
    @classmethod
    def from_xy(
        cls,
        x: ArrowArrayExportable | NumpyArrayProtocolf64,
        y: ArrowArrayExportable | NumpyArrayProtocolf64,
    ) -> Self: ...
    def geodesic_perimeter(self) -> Float64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def length(
        self, *, method: LengthMethod | LengthMethodT = LengthMethod.Euclidean
    ) -> Float64Array: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_shapely(cls, input) -> Self: ...
    @classmethod
    def from_wkb(cls, input: ArrowArrayExportable) -> Self: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def to_wkb(self) -> WKBArray: ...

class LineStringArray:
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __getitem__(self, key: int) -> LineString: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def bounding_rect(self) -> RectArray: ...
    def center(self) -> PointArray: ...
    def centroid(self) -> PointArray: ...
    def chaikin_smoothing(self, n_iterations: int) -> Self: ...
    def convex_hull(self) -> PolygonArray: ...
    def densify(self, max_distance: float) -> Self: ...
    def frechet_distance(self, other: BroadcastGeometry) -> Float64Array: ...
    def geodesic_perimeter(self) -> Float64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def length(
        self, *, method: LengthMethod | LengthMethodT = LengthMethod.Euclidean
    ) -> Float64Array: ...
    def line_interpolate_point(
        self, fraction: float | int | ArrowArrayExportable | NumpyArrayProtocolf64
    ) -> PointArray: ...
    def line_locate_point(
        self, point: GeoInterfaceProtocol | ArrowArrayExportable
    ) -> Float64Array: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_shapely(cls, input) -> Self: ...
    @classmethod
    def from_wkb(cls, input: ArrowArrayExportable) -> Self: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def to_wkb(self) -> WKBArray: ...

class PolygonArray:
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __getitem__(self, key: int) -> Polygon: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def bounding_rect(self) -> RectArray: ...
    def center(self) -> PointArray: ...
    def centroid(self) -> PointArray: ...
    def chaikin_smoothing(self, n_iterations: int) -> Self: ...
    def convex_hull(self) -> PolygonArray: ...
    def densify(self, max_distance: float) -> Self: ...
    def geodesic_perimeter(self) -> Float64Array: ...
    def polylabel(self, tolerance: float) -> PointArray: ...
    def is_empty(self) -> BooleanArray: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_shapely(cls, input) -> Self: ...
    @classmethod
    def from_wkb(cls, input: ArrowArrayExportable) -> Self: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def to_wkb(self) -> WKBArray: ...

class MultiPointArray:
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __getitem__(self, key: int) -> MultiPoint: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def bounding_rect(self) -> RectArray: ...
    def center(self) -> PointArray: ...
    def centroid(self) -> PointArray: ...
    def convex_hull(self) -> PolygonArray: ...
    def geodesic_perimeter(self) -> Float64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def length(
        self, *, method: LengthMethod | LengthMethodT = LengthMethod.Euclidean
    ) -> Float64Array: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_shapely(cls, input) -> Self: ...
    @classmethod
    def from_wkb(cls, input: ArrowArrayExportable) -> Self: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def to_wkb(self) -> WKBArray: ...

class MultiLineStringArray:
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __getitem__(self, key: int) -> MultiLineString: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def bounding_rect(self) -> RectArray: ...
    def center(self) -> PointArray: ...
    def centroid(self) -> PointArray: ...
    def chaikin_smoothing(self, n_iterations: int) -> Self: ...
    def convex_hull(self) -> PolygonArray: ...
    def densify(self, max_distance: float) -> Self: ...
    def geodesic_perimeter(self) -> Float64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def length(
        self, *, method: LengthMethod | LengthMethodT = LengthMethod.Euclidean
    ) -> Float64Array: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_shapely(cls, input) -> Self: ...
    @classmethod
    def from_wkb(cls, input: ArrowArrayExportable) -> Self: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def to_wkb(self) -> WKBArray: ...

class MultiPolygonArray:
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __getitem__(self, key: int) -> MultiPolygon: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def bounding_rect(self) -> RectArray: ...
    def center(self) -> PointArray: ...
    def centroid(self) -> PointArray: ...
    def chaikin_smoothing(self, n_iterations: int) -> Self: ...
    def convex_hull(self) -> PolygonArray: ...
    def densify(self, max_distance: float) -> Self: ...
    def geodesic_perimeter(self) -> Float64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_shapely(cls, input) -> Self: ...
    @classmethod
    def from_wkb(cls, input: ArrowArrayExportable) -> Self: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def to_wkb(self) -> WKBArray: ...

class MixedGeometryArray:
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __getitem__(self, key: int) -> Geometry: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def bounding_rect(self) -> RectArray: ...
    def center(self) -> PointArray: ...
    def centroid(self) -> PointArray: ...
    def convex_hull(self) -> PolygonArray: ...
    def geodesic_perimeter(self) -> Float64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_ewkb(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_shapely(cls, input) -> Self: ...
    @classmethod
    def from_wkb(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_wkt(cls, input: ArrowArrayExportable) -> Self: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def to_wkb(self) -> WKBArray: ...

class GeometryCollectionArray:
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __getitem__(self, key: int) -> GeometryCollection: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def bounding_rect(self) -> RectArray: ...
    def center(self) -> PointArray: ...
    def centroid(self) -> PointArray: ...
    def convex_hull(self) -> PolygonArray: ...
    def geodesic_perimeter(self) -> Float64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> Float64Array: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_ewkb(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_shapely(cls, input) -> Self: ...
    @classmethod
    def from_wkb(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_wkt(cls, input: ArrowArrayExportable) -> Self: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def to_wkb(self) -> WKBArray: ...

class WKBArray:
    def __array__(self) -> NDArray[np.object_]: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> WKB: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def __repr__(self) -> str: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...
    @classmethod
    def from_arrow(cls, input: ArrowArrayExportable) -> Self: ...
    @classmethod
    def from_shapely(cls, input) -> Self: ...
    def to_shapely(self) -> NDArray[np.object_]: ...

class RectArray:
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> Rect: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def to_polygon_array(self) -> PolygonArray: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class BooleanArray:
    def __array__(self) -> NDArray[np.bool_]: ...
    def __eq__(self, other: Self) -> bool: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def to_numpy(self) -> NDArray[np.bool_]: ...

# class Float16Array:
#     def __array__(self) -> NDArray[np.float16]: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.float16]) -> Self: ...

# class Float32Array:
#     def __array__(self) -> NDArray[np.float32]: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def to_numpy(self) -> NDArray[np.float32]: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.float32]) -> Self: ...

class Float64Array:
    def __array__(self) -> NDArray[np.float64]: ...
    def __eq__(self, other: Self) -> bool: ...
    def __len__(self) -> int: ...
    def __arrow_c_array__(
        self, requested_schema: object | None = None
    ) -> Tuple[object, object]: ...
    def to_numpy(self) -> NDArray[np.float64]: ...
    @classmethod
    def from_numpy(cls, arr: NDArray[np.float64]) -> Self: ...

# class Int16Array:
#     def __array__(self) -> NDArray[np.int16]: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...
#     def to_numpy(self) -> NDArray[np.int16]: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.int16]) -> Self: ...

# class Int32Array:
#     def __array__(self) -> NDArray[np.int32]: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...
#     def to_numpy(self) -> NDArray[np.int32]: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.int32]) -> Self: ...

# class Int64Array:
#     def __array__(self) -> NDArray[np.int64]: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...
#     def to_numpy(self) -> NDArray[np.int64]: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.int64]) -> Self: ...

# class Int8Array:
#     def __array__(self) -> NDArray[np.int8]: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...
#     def to_numpy(self) -> NDArray[np.int8]: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.int8]) -> Self: ...

# class LargeStringArray:
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...

# class StringArray:
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...

# class UInt16Array:
#     def __array__(self) -> NDArray[np.uint16]: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...
#     def to_numpy(self) -> NDArray[np.uint16]: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.uint16]) -> Self: ...

# class UInt32Array:
#     def __array__(self) -> NDArray[np.uint32]: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...
#     def to_numpy(self) -> NDArray[np.uint32]: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.uint32]) -> Self: ...

# class UInt64Array:
#     def __array__(self) -> NDArray[np.uint64]: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...
#     def to_numpy(self) -> NDArray[np.uint64]: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.uint64]) -> Self: ...

# class UInt8Array:
#     def __array__(self) -> NDArray[np.uint8]: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def __arrow_c_array__(
#         self, requested_schema: object | None = None
#     ) -> Tuple[object, object]: ...
#     def to_numpy(self) -> NDArray[np.uint8]: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.uint8]) -> Self: ...

class ChunkedPointArray:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> Point: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def bounding_rect(self) -> ChunkedRectArray: ...
    def center(self) -> ChunkedPointArray: ...
    def centroid(self) -> ChunkedPointArray: ...
    def chunk(self, i: int) -> PointArray: ...
    def chunks(self) -> List[PointArray]: ...
    def concatenate(self) -> PointArray: ...
    def convex_hull(self) -> ChunkedPolygonArray: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    @classmethod
    def from_shapely(cls, input, *, chunk_size: int = 65536) -> Self: ...
    def geodesic_perimeter(self) -> ChunkedFloat64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def length(
        self, *, method: LengthMethod | LengthMethodT = LengthMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def num_chunks(self) -> int: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class ChunkedLineStringArray:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> LineString: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def bounding_rect(self) -> ChunkedRectArray: ...
    def center(self) -> ChunkedPointArray: ...
    def centroid(self) -> ChunkedPointArray: ...
    def chaikin_smoothing(self, n_iterations: int) -> Self: ...
    def chunk(self, i: int) -> LineStringArray: ...
    def chunks(self) -> List[LineStringArray]: ...
    def concatenate(self) -> LineStringArray: ...
    def convex_hull(self) -> ChunkedPolygonArray: ...
    def densify(self, max_distance: float) -> Self: ...
    def frechet_distance(self, other: BroadcastGeometry) -> ChunkedFloat64Array: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    @classmethod
    def from_shapely(cls, input, *, chunk_size: int = 65536) -> Self: ...
    def geodesic_perimeter(self) -> ChunkedFloat64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def length(
        self, *, method: LengthMethod | LengthMethodT = LengthMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def line_interpolate_point(
        self, fraction: float | int | ArrowStreamExportable
    ) -> ChunkedPointArray: ...
    def line_locate_point(
        self, point: GeoInterfaceProtocol | ArrowStreamExportable
    ) -> ChunkedFloat64Array: ...
    def num_chunks(self) -> int: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class ChunkedPolygonArray:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> Polygon: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def bounding_rect(self) -> ChunkedRectArray: ...
    def center(self) -> ChunkedPointArray: ...
    def centroid(self) -> ChunkedPointArray: ...
    def chaikin_smoothing(self, n_iterations: int) -> Self: ...
    def chunk(self, i: int) -> PolygonArray: ...
    def chunks(self) -> List[PolygonArray]: ...
    def concatenate(self) -> PolygonArray: ...
    def convex_hull(self) -> ChunkedPolygonArray: ...
    def densify(self, max_distance: float) -> Self: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    @classmethod
    def from_shapely(cls, input, *, chunk_size: int = 65536) -> Self: ...
    def geodesic_perimeter(self) -> ChunkedFloat64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def num_chunks(self) -> int: ...
    def polylabel(self, tolerance: float) -> ChunkedPointArray: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class ChunkedMultiPointArray:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> MultiPoint: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def bounding_rect(self) -> ChunkedRectArray: ...
    def center(self) -> ChunkedPointArray: ...
    def centroid(self) -> ChunkedPointArray: ...
    def chunk(self, i: int) -> MultiPointArray: ...
    def chunks(self) -> List[MultiPointArray]: ...
    def concatenate(self) -> MultiPointArray: ...
    def convex_hull(self) -> ChunkedPolygonArray: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    @classmethod
    def from_shapely(cls, input, *, chunk_size: int = 65536) -> Self: ...
    def geodesic_perimeter(self) -> ChunkedFloat64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def length(
        self, *, method: LengthMethod | LengthMethodT = LengthMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def num_chunks(self) -> int: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class ChunkedMultiLineStringArray:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> MultiLineString: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def bounding_rect(self) -> ChunkedRectArray: ...
    def center(self) -> ChunkedPointArray: ...
    def centroid(self) -> ChunkedPointArray: ...
    def chaikin_smoothing(self, n_iterations: int) -> Self: ...
    def chunk(self, i: int) -> MultiLineStringArray: ...
    def chunks(self) -> List[MultiLineStringArray]: ...
    def concatenate(self) -> MultiLineStringArray: ...
    def convex_hull(self) -> ChunkedPolygonArray: ...
    def densify(self, max_distance: float) -> Self: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    @classmethod
    def from_shapely(cls, input, *, chunk_size: int = 65536) -> Self: ...
    def geodesic_perimeter(self) -> ChunkedFloat64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def length(
        self, *, method: LengthMethod | LengthMethodT = LengthMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def num_chunks(self) -> int: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class ChunkedMultiPolygonArray:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> MultiPolygon: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def bounding_rect(self) -> ChunkedRectArray: ...
    def center(self) -> ChunkedPointArray: ...
    def centroid(self) -> ChunkedPointArray: ...
    def chaikin_smoothing(self, n_iterations: int) -> Self: ...
    def chunk(self, i: int) -> MultiPolygonArray: ...
    def chunks(self) -> List[MultiPolygonArray]: ...
    def concatenate(self) -> MultiPolygonArray: ...
    def convex_hull(self) -> ChunkedPolygonArray: ...
    def densify(self, max_distance: float) -> Self: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    @classmethod
    def from_shapely(cls, input, *, chunk_size: int = 65536) -> Self: ...
    def geodesic_perimeter(self) -> ChunkedFloat64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def num_chunks(self) -> int: ...
    def simplify(
        self,
        epsilon: float,
        *,
        method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
    ) -> Self: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class ChunkedMixedGeometryArray:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> Geometry: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def bounding_rect(self) -> ChunkedRectArray: ...
    def center(self) -> ChunkedPointArray: ...
    def centroid(self) -> ChunkedPointArray: ...
    def chunk(self, i: int) -> MixedGeometryArray: ...
    def chunks(self) -> List[MixedGeometryArray]: ...
    def concatenate(self) -> MixedGeometryArray: ...
    def convex_hull(self) -> ChunkedPolygonArray: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    @classmethod
    def from_shapely(cls, input, *, chunk_size: int = 65536) -> Self: ...
    def geodesic_perimeter(self) -> ChunkedFloat64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def num_chunks(self) -> int: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class ChunkedGeometryCollectionArray:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> GeometryCollection: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def bounding_rect(self) -> ChunkedRectArray: ...
    def center(self) -> ChunkedPointArray: ...
    def centroid(self) -> ChunkedPointArray: ...
    def chunk(self, i: int) -> GeometryCollectionArray: ...
    def chunks(self) -> List[GeometryCollectionArray]: ...
    def concatenate(self) -> GeometryCollectionArray: ...
    def convex_hull(self) -> ChunkedPolygonArray: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    @classmethod
    def from_shapely(cls, input, *, chunk_size: int = 65536) -> Self: ...
    def geodesic_perimeter(self) -> ChunkedFloat64Array: ...
    def is_empty(self) -> BooleanArray: ...
    def num_chunks(self) -> int: ...
    def signed_area(
        self, *, method: AreaMethod | AreaMethodT = AreaMethod.Euclidean
    ) -> ChunkedFloat64Array: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class ChunkedWKBArray:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __array__(self) -> NDArray[np.object_]: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> WKB: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def chunk(self, i: int) -> WKBArray: ...
    def chunks(self) -> List[WKBArray]: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    @classmethod
    def from_shapely(cls, input, *, chunk_size: int = 65536) -> Self: ...
    def num_chunks(self) -> int: ...
    def to_shapely(self) -> NDArray[np.object_]: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class ChunkedRectArray:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __getitem__(self, key: int) -> Rect: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def chunk(self, i: int) -> RectArray: ...
    def chunks(self) -> List[RectArray]: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    def num_chunks(self) -> int: ...
    def total_bounds(self) -> Tuple[float, float, float, float]: ...

class ChunkedBooleanArray:
    def __array__(self) -> NDArray[np.bool_]: ...
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __len__(self) -> int: ...
    def chunk(self, i: int) -> BooleanArray: ...
    def chunks(self) -> List[BooleanArray]: ...
    @classmethod
    def from_arrow_arrays(cls, input: Sequence[ArrowArrayExportable]) -> Self: ...
    def num_chunks(self) -> int: ...
    def to_numpy(self) -> NDArray[np.bool_]: ...

# class ChunkedFloat16Array:
#     def __array__(self) -> NDArray[np.float16]: ...
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> Float16Array: ...
#     def chunks(self) -> List[Float16Array]: ...
#     def num_chunks(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.float16], lengths: List[int]) -> Self: ...
#     def to_numpy(self) -> NDArray[np.float16]: ...

# class ChunkedFloat32Array:
#     def __array__(self) -> NDArray[np.float32]: ...
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> Float32Array: ...
#     def chunks(self) -> List[Float32Array]: ...
#     def num_chunks(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.float32], lengths: List[int]) -> Self: ...
#     def to_numpy(self) -> NDArray[np.float32]: ...

class ChunkedFloat64Array:
    def __array__(self) -> NDArray[np.float64]: ...
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    def __len__(self) -> int: ...
    def chunk(self, i: int) -> Float64Array: ...
    def chunks(self) -> List[Float64Array]: ...
    def num_chunks(self) -> int: ...
    @classmethod
    def from_numpy(cls, arr: NDArray[np.float64], lengths: List[int]) -> Self: ...
    def to_numpy(self) -> NDArray[np.float64]: ...

# class ChunkedInt16Array:
#     def __array__(self) -> NDArray[np.int16]: ...
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> Int16Array: ...
#     def chunks(self) -> List[Int16Array]: ...
#     def num_chunks(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.int16], lengths: List[int]) -> Self: ...
#     def to_numpy(self) -> NDArray[np.int16]: ...

# class ChunkedInt32Array:
#     def __array__(self) -> NDArray[np.int32]: ...
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> Int32Array: ...
#     def chunks(self) -> List[Int32Array]: ...
#     def num_chunks(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.int32], lengths: List[int]) -> Self: ...
#     def to_numpy(self) -> NDArray[np.int32]: ...

# class ChunkedInt64Array:
#     def __array__(self) -> NDArray[np.int64]: ...
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> Int64Array: ...
#     def chunks(self) -> List[Int64Array]: ...
#     def num_chunks(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.int64], lengths: List[int]) -> Self: ...
#     def to_numpy(self) -> NDArray[np.int64]: ...

# class ChunkedInt8Array:
#     def __array__(self) -> NDArray[np.int8]: ...
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> Int8Array: ...
#     def chunks(self) -> List[Int8Array]: ...
#     def num_chunks(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.int8], lengths: List[int]) -> Self: ...
#     def to_numpy(self) -> NDArray[np.int8]: ...

# class ChunkedLargeStringArray:
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> LargeStringArray: ...
#     def chunks(self) -> List[LargeStringArray]: ...
#     def num_chunks(self) -> int: ...

# class ChunkedStringArray:
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> StringArray: ...
#     def chunks(self) -> List[StringArray]: ...
#     def num_chunks(self) -> int: ...

# class ChunkedUInt16Array:
#     def __array__(self) -> NDArray[np.uint16]: ...
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> UInt16Array: ...
#     def chunks(self) -> List[UInt16Array]: ...
#     def num_chunks(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.uint16], lengths: List[int]) -> Self: ...
#     def to_numpy(self) -> NDArray[np.uint16]: ...

# class ChunkedUInt32Array:
#     def __array__(self) -> NDArray[np.uint32]: ...
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> UInt32Array: ...
#     def chunks(self) -> List[UInt32Array]: ...
#     def num_chunks(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.uint32], lengths: List[int]) -> Self: ...
#     def to_numpy(self) -> NDArray[np.uint32]: ...

# class ChunkedUInt64Array:
#     def __array__(self) -> NDArray[np.uint64]: ...
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> UInt64Array: ...
#     def chunks(self) -> List[UInt64Array]: ...
#     def num_chunks(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.uint64], lengths: List[int]) -> Self: ...
#     def to_numpy(self) -> NDArray[np.uint64]: ...

# class ChunkedUInt8Array:
#     def __array__(self) -> NDArray[np.uint8]: ...
#     def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
#     def __eq__(self, other: Self) -> bool: ...
#     def __len__(self) -> int: ...
#     def chunk(self, i: int) -> UInt8Array: ...
#     def chunks(self) -> List[UInt8Array]: ...
#     def num_chunks(self) -> int: ...
#     @classmethod
#     def from_numpy(cls, arr: NDArray[np.uint8], lengths: List[int]) -> Self: ...
#     def to_numpy(self) -> NDArray[np.uint8]: ...

class GeoTable:
    def __arrow_c_stream__(self, requested_schema: object | None = None) -> object: ...
    def __eq__(self, other: Self) -> bool: ...
    @property
    def __geo_interface__(self) -> dict: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def explode(self) -> Self: ...
    @classmethod
    def from_arrow(cls, input: ArrowStreamExportable) -> Self: ...
    @classmethod
    def from_geopandas(cls, input: gpd.GeoDataFrame) -> Self: ...
    @property
    def geometry(
        self,
    ) -> (
        ChunkedPointArray
        | ChunkedLineStringArray
        | ChunkedPolygonArray
        | ChunkedMultiPointArray
        | ChunkedMultiLineStringArray
        | ChunkedMultiPolygonArray
        | ChunkedMixedGeometryArray
        | ChunkedGeometryCollectionArray
    ): ...
    @property
    def num_columns(self) -> int: ...
    def to_geopandas(self) -> gpd.GeoDataFrame: ...

# Top-level array/chunked array functions

@overload
def affine_transform(
    input: AffineInputT,
    transform: AffineTransform,
) -> AffineInputT: ...
@overload
def affine_transform(
    input: ArrowArrayExportable,
    transform: AffineTransform,
) -> NativeGeometryArrayT: ...
@overload
def affine_transform(
    input: ArrowStreamExportable,
    transform: AffineTransform,
) -> NativeChunkedGeometryArrayT: ...
def affine_transform(
    input: AffineInputT | ArrowArrayExportable | ArrowStreamExportable,
    transform: AffineTransform,
) -> AffineInputT | NativeGeometryArrayT | NativeChunkedGeometryArrayT: ...
@overload
def area(
    input: ArrowArrayExportable,
    *,
    method: AreaMethod | AreaMethodT = AreaMethod.Euclidean,
) -> Float64Array: ...
@overload
def area(
    input: ArrowStreamExportable,
    *,
    method: AreaMethod | AreaMethodT = AreaMethod.Euclidean,
) -> ChunkedFloat64Array: ...
def area(
    input: ArrowArrayExportable | ArrowStreamExportable,
    *,
    method: AreaMethod | AreaMethodT = AreaMethod.Euclidean,
) -> Float64Array | ChunkedFloat64Array: ...
@overload
def center(input: ArrowArrayExportable) -> PointArray: ...
@overload
def center(input: ArrowStreamExportable) -> ChunkedPointArray: ...
def center(
    input: ArrowArrayExportable | ArrowStreamExportable,
) -> PointArray | ChunkedPointArray: ...
@overload
def centroid(input: ArrowArrayExportable) -> PointArray: ...
@overload
def centroid(input: ArrowStreamExportable) -> ChunkedPointArray: ...
def centroid(
    input: ArrowArrayExportable | ArrowStreamExportable,
) -> PointArray | ChunkedPointArray: ...

ChaikinSmoothingT = TypeVar(
    "ChaikinSmoothingT",
    LineStringArray,
    PolygonArray,
    MultiLineStringArray,
    MultiPolygonArray,
    ChunkedLineStringArray,
    ChunkedPolygonArray,
    ChunkedMultiLineStringArray,
    ChunkedMultiPolygonArray,
)

@overload
def chaikin_smoothing(
    input: ChaikinSmoothingT, n_iterations: int
) -> ChaikinSmoothingT: ...
@overload
def chaikin_smoothing(
    input: ArrowArrayExportable, n_iterations: int
) -> LineStringArray | PolygonArray | MultiLineStringArray | MultiPolygonArray: ...
@overload
def chaikin_smoothing(
    input: ArrowStreamExportable, n_iterations: int
) -> (
    ChunkedLineStringArray
    | ChunkedPolygonArray
    | ChunkedMultiLineStringArray
    | ChunkedMultiPolygonArray
): ...
def chaikin_smoothing(
    input: ChaikinSmoothingT | ArrowArrayExportable | ArrowStreamExportable,
    n_iterations: int,
) -> (
    LineStringArray
    | PolygonArray
    | MultiLineStringArray
    | MultiPolygonArray
    | ChunkedLineStringArray
    | ChunkedPolygonArray
    | ChunkedMultiLineStringArray
    | ChunkedMultiPolygonArray
): ...
@overload
def convex_hull(input: ArrowArrayExportable) -> PolygonArray: ...
@overload
def convex_hull(input: ArrowStreamExportable) -> ChunkedPolygonArray: ...
def convex_hull(
    input: ArrowArrayExportable | ArrowStreamExportable,
) -> PolygonArray | ChunkedPolygonArray: ...
def densify(
    input: ArrowArrayExportable, max_distance: float
) -> LineStringArray | PolygonArray | MultiLineStringArray | MultiPolygonArray: ...
@overload
def envelope(input: ArrowArrayExportable) -> RectArray: ...
@overload
def envelope(input: ArrowStreamExportable) -> ChunkedRectArray: ...
def envelope(
    input: ArrowArrayExportable | ArrowStreamExportable,
) -> RectArray | ChunkedRectArray: ...
@overload
def frechet_distance(
    input: ArrowArrayExportable,
    other: BroadcastGeometry,
) -> Float64Array: ...
@overload
def frechet_distance(
    input: ArrowStreamExportable,
    other: BroadcastGeometry,
) -> ChunkedFloat64Array: ...
def frechet_distance(
    input: ArrowArrayExportable | ArrowStreamExportable,
    other: BroadcastGeometry,
) -> Float64Array | ChunkedFloat64Array: ...
def geodesic_perimeter(input: ArrowArrayExportable) -> Float64Array: ...
@overload
def is_empty(input: ArrowArrayExportable) -> BooleanArray: ...
@overload
def is_empty(input: ArrowStreamExportable) -> ChunkedBooleanArray: ...
def is_empty(
    input: ArrowArrayExportable | ArrowStreamExportable,
) -> BooleanArray | ChunkedBooleanArray: ...
@overload
def length(
    input: ArrowArrayExportable,
    *,
    method: LengthMethod | LengthMethodT = LengthMethod.Euclidean,
) -> Float64Array: ...
@overload
def length(
    input: ArrowStreamExportable,
    *,
    method: LengthMethod | LengthMethodT = LengthMethod.Euclidean,
) -> ChunkedFloat64Array: ...
def length(
    input: ArrowArrayExportable | ArrowStreamExportable,
    *,
    method: LengthMethod | LengthMethodT = LengthMethod.Euclidean,
) -> Float64Array | ChunkedFloat64Array: ...
@overload
def line_interpolate_point(
    input: ArrowArrayExportable,
    fraction: float | int | ArrowArrayExportable | NumpyArrayProtocolf64,
) -> PointArray: ...
@overload
def line_interpolate_point(
    input: ArrowStreamExportable,
    fraction: float | int | ArrowStreamExportable,
) -> ChunkedPointArray: ...
def line_interpolate_point(
    input: ArrowArrayExportable | ArrowStreamExportable,
    fraction: float
    | int
    | ArrowArrayExportable
    | ArrowStreamExportable
    | NumpyArrayProtocolf64,
) -> PointArray | ChunkedPointArray: ...
@overload
def line_locate_point(
    input: ArrowArrayExportable, point: GeoInterfaceProtocol | ArrowArrayExportable
) -> Float64Array: ...
@overload
def line_locate_point(
    input: ArrowStreamExportable, point: GeoInterfaceProtocol | ArrowStreamExportable
) -> ChunkedFloat64Array: ...
def line_locate_point(
    input: ArrowArrayExportable | ArrowStreamExportable,
    point: GeoInterfaceProtocol | ArrowArrayExportable | ArrowStreamExportable,
) -> Float64Array | ChunkedFloat64Array: ...
@overload
def polylabel(
    input: ArrowArrayExportable,
    tolerance: float,
) -> PointArray: ...
@overload
def polylabel(
    input: ArrowStreamExportable,
    tolerance: float,
) -> ChunkedPointArray: ...
def polylabel(
    input: ArrowArrayExportable | ArrowStreamExportable,
    tolerance: float,
) -> PointArray | ChunkedPointArray: ...
@overload
def signed_area(
    input: ArrowArrayExportable,
    *,
    method: AreaMethod | AreaMethodT = AreaMethod.Euclidean,
) -> Float64Array: ...
@overload
def signed_area(
    input: ArrowStreamExportable,
    *,
    method: AreaMethod | AreaMethodT = AreaMethod.Euclidean,
) -> ChunkedFloat64Array: ...
def signed_area(
    input: ArrowArrayExportable | ArrowStreamExportable,
    *,
    method: AreaMethod | AreaMethodT = AreaMethod.Euclidean,
) -> Float64Array | ChunkedFloat64Array: ...
@overload
def simplify(
    input: SimplifyInputT,
    epsilon: float,
    *,
    method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
) -> SimplifyInputT: ...
@overload
def simplify(
    input: ArrowArrayExportable,
    epsilon: float,
    *,
    method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
) -> (
    PointArray
    | LineStringArray
    | PolygonArray
    | MultiPointArray
    | MultiLineStringArray
    | MultiPolygonArray
): ...
@overload
def simplify(
    input: ArrowStreamExportable,
    epsilon: float,
    *,
    method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
) -> (
    ChunkedPointArray
    | ChunkedLineStringArray
    | ChunkedPolygonArray
    | ChunkedMultiPointArray
    | ChunkedMultiLineStringArray
    | ChunkedMultiPolygonArray
): ...
def simplify(
    input: SimplifyInputT | ArrowArrayExportable | ArrowStreamExportable,
    epsilon: float,
    *,
    method: SimplifyMethod | SimplifyMethodT = SimplifyMethod.RDP,
) -> (
    SimplifyInputT
    | PointArray
    | LineStringArray
    | PolygonArray
    | MultiPointArray
    | MultiLineStringArray
    | MultiPolygonArray
    | ChunkedPointArray
    | ChunkedLineStringArray
    | ChunkedPolygonArray
    | ChunkedMultiPointArray
    | ChunkedMultiLineStringArray
    | ChunkedMultiPolygonArray
): ...
def total_bounds(
    input: ArrowArrayExportable | ArrowStreamExportable,
) -> Tuple[float, float, float, float]: ...

# Top-level table functions

def explode(input: ArrowStreamExportable) -> GeoTable: ...
def sjoin(left: ArrowStreamExportable, right: ArrowStreamExportable) -> GeoTable: ...

# I/O

class ParquetFile:
    def __init__(self, path: str, fs: ObjectStore) -> None: ...
    @property
    def num_rows(self) -> int: ...
    @property
    def num_row_groups(self) -> int: ...
    def file_bbox(self) -> Optional[List[float]]: ...
    async def read_async(self) -> GeoTable: ...
    def read(self) -> GeoTable: ...
    async def read_row_groups_async(self, row_groups: Sequence[int]) -> GeoTable: ...
    def read_row_groups(self, row_groups: Sequence[int]) -> GeoTable: ...

class ParquetDataset:
    def __init__(self, paths: Sequence[str], fs: ObjectStore) -> None: ...
    @property
    def num_rows(self) -> int: ...
    @property
    def num_row_groups(self) -> int: ...

class ObjectStore:
    def __init__(self, root: str, options: Optional[Dict[str, str]] = None) -> None: ...

def read_csv(
    file: str | Path | BinaryIO,
    geometry_column_name: str,
    *,
    batch_size: int = 65536,
) -> GeoTable: ...
def read_flatgeobuf(
    file: Union[str, Path, BinaryIO],
    *,
    fs: Optional[ObjectStore] = None,
    batch_size: int = 65536,
    bbox: Tuple[float, float, float, float] | None = None,
) -> GeoTable: ...
async def read_flatgeobuf_async(
    path: str,
    *,
    fs: Optional[ObjectStore] = None,
    batch_size: int = 65536,
    bbox: Tuple[float, float, float, float] | None = None,
) -> GeoTable: ...
def read_geojson(
    file: Union[str, Path, BinaryIO], *, batch_size: int = 65536
) -> GeoTable: ...
def read_geojson_lines(
    file: Union[str, Path, BinaryIO], *, batch_size: int = 65536
) -> GeoTable: ...
def read_ipc(file: Union[str, Path, BinaryIO]) -> GeoTable: ...
def read_ipc_stream(file: Union[str, Path, BinaryIO]) -> GeoTable: ...
def read_parquet(
    path: str, *, fs: Optional[ObjectStore] = None, batch_size: int = 65536
) -> GeoTable: ...
async def read_parquet_async(
    path: str, *, fs: Optional[ObjectStore] = None, batch_size: int = 65536
) -> GeoTable: ...
def read_postgis(connection_url: str, sql: str) -> Optional[GeoTable]: ...
async def read_postgis_async(connection_url: str, sql: str) -> Optional[GeoTable]: ...
def read_pyogrio(
    path_or_buffer: Path | str | bytes,
    /,
    layer: int | str | None = None,
    encoding: str | None = None,
    columns: Sequence[str] | None = None,
    read_geometry: bool = True,
    skip_features: int = 0,
    max_features: int | None = None,
    where: str | None = None,
    bbox: Tuple[float, float, float, float] | Sequence[float] | None = None,
    mask=None,
    fids=None,
    sql: str | None = None,
    sql_dialect: str | None = None,
    return_fids=False,
    batch_size=65536,
    **kwargs,
) -> GeoTable: ...
def write_csv(table: ArrowStreamExportable, file: str | Path | BinaryIO) -> None: ...
def write_flatgeobuf(
    table: ArrowStreamExportable,
    file: str | Path | BinaryIO,
    *,
    write_index: bool = True,
) -> None: ...
def write_geojson(
    table: ArrowStreamExportable, file: Union[str, Path, BinaryIO]
) -> None: ...
def write_geojson_lines(
    table: ArrowStreamExportable, file: Union[str, Path, BinaryIO]
) -> None: ...
def write_ipc(
    table: ArrowStreamExportable, file: Union[str, Path, BinaryIO]
) -> None: ...
def write_ipc_stream(
    table: ArrowStreamExportable, file: Union[str, Path, BinaryIO]
) -> None: ...
def write_parquet(table: ArrowStreamExportable, file: str) -> None: ...

# Interop
def from_ewkb(
    input: ArrowArrayExportable,
) -> (
    PointArray
    | LineStringArray
    | PolygonArray
    | MultiPointArray
    | MultiLineStringArray
    | MultiPolygonArray
    | MixedGeometryArray
    | GeometryCollectionArray
): ...
def from_geopandas(input: gpd.GeoDataFrame) -> GeoTable: ...
def from_shapely(
    input,
) -> (
    PointArray
    | LineStringArray
    | PolygonArray
    | MultiPointArray
    | MultiLineStringArray
    | MultiPolygonArray
    | MixedGeometryArray
): ...
def from_wkb(
    input: ArrowArrayExportable,
) -> (
    PointArray
    | LineStringArray
    | PolygonArray
    | MultiPointArray
    | MultiLineStringArray
    | MultiPolygonArray
    | MixedGeometryArray
    | GeometryCollectionArray
): ...
def from_wkt(
    input: ArrowArrayExportable,
) -> (
    PointArray
    | LineStringArray
    | PolygonArray
    | MultiPointArray
    | MultiLineStringArray
    | MultiPolygonArray
    | MixedGeometryArray
    | GeometryCollectionArray
): ...
def to_geopandas(input: ArrowStreamExportable) -> gpd.GeoDataFrame: ...
def to_shapely(input: ArrowArrayExportable) -> NDArray[np.object_]: ...
def to_wkb(input: ArrowArrayExportable) -> WKBArray: ...
